// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Nox.proto
// Protobuf C++ Version: 6.31.1

#include "Nox.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace NoxProto {

inline constexpr VoiceTarget_Target::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        session_{},
        group_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        channel_id_{0u},
        links_{false},
        children_{false} {}

template <typename>
PROTOBUF_CONSTEXPR VoiceTarget_Target::VoiceTarget_Target(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(VoiceTarget_Target_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VoiceTarget_TargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoiceTarget_TargetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoiceTarget_TargetDefaultTypeInternal() {}
  union {
    VoiceTarget_Target _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoiceTarget_TargetDefaultTypeInternal _VoiceTarget_Target_default_instance_;

inline constexpr Version::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        release_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        os_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        os_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        version_v2_{::uint64_t{0u}},
        version_v1_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Version::Version(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Version_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;

inline constexpr UserStats_Stats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        good_{0u},
        late_{0u},
        lost_{0u},
        resync_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserStats_Stats::UserStats_Stats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserStats_Stats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStats_StatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStats_StatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStats_StatsDefaultTypeInternal() {}
  union {
    UserStats_Stats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStats_StatsDefaultTypeInternal _UserStats_Stats_default_instance_;

inline constexpr UserState_VolumeAdjustment::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        listening_channel_{0u},
        volume_adjustment_{0} {}

template <typename>
PROTOBUF_CONSTEXPR UserState_VolumeAdjustment::UserState_VolumeAdjustment(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserState_VolumeAdjustment_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserState_VolumeAdjustmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserState_VolumeAdjustmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserState_VolumeAdjustmentDefaultTypeInternal() {}
  union {
    UserState_VolumeAdjustment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserState_VolumeAdjustmentDefaultTypeInternal _UserState_VolumeAdjustment_default_instance_;

inline constexpr UserRemove::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        actor_{0u},
        ban_{false},
        ban_certificate_{false},
        ban_ip_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UserRemove::UserRemove(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserRemoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserRemoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserRemoveDefaultTypeInternal() {}
  union {
    UserRemove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserRemoveDefaultTypeInternal _UserRemove_default_instance_;

inline constexpr UserList_User::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_seen_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        user_id_{0u},
        last_channel_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserList_User::UserList_User(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserList_User_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserList_UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserList_UserDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserList_UserDefaultTypeInternal() {}
  union {
    UserList_User _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserList_UserDefaultTypeInternal _UserList_User_default_instance_;

inline constexpr UDPTunnel::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        packet_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR UDPTunnel::UDPTunnel(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UDPTunnel_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UDPTunnelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UDPTunnelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UDPTunnelDefaultTypeInternal() {}
  union {
    UDPTunnel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UDPTunnelDefaultTypeInternal _UDPTunnel_default_instance_;

inline constexpr TextMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        session_{},
        channel_id_{},
        tree_id_{},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        actor_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TextMessage::TextMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TextMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TextMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextMessageDefaultTypeInternal() {}
  union {
    TextMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextMessageDefaultTypeInternal _TextMessage_default_instance_;

inline constexpr SuggestConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        version_v1_{0u},
        positional_{false},
        push_to_talk_{false},
        version_v2_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR SuggestConfig::SuggestConfig(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SuggestConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SuggestConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SuggestConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SuggestConfigDefaultTypeInternal() {}
  union {
    SuggestConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SuggestConfigDefaultTypeInternal _SuggestConfig_default_instance_;

inline constexpr ServerSync::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        welcome_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        max_bandwidth_{0u},
        permissions_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR ServerSync::ServerSync(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ServerSync_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ServerSyncDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerSyncDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerSyncDefaultTypeInternal() {}
  union {
    ServerSync _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerSyncDefaultTypeInternal _ServerSync_default_instance_;

inline constexpr ServerConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        welcome_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        max_bandwidth_{0u},
        message_length_{0u},
        image_message_length_{0u},
        allow_html_{false},
        recording_allowed_{false},
        max_users_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ServerConfig::ServerConfig(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ServerConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ServerConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerConfigDefaultTypeInternal() {}
  union {
    ServerConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;

inline constexpr RequestBlob::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : session_texture_{},
        session_comment_{},
        channel_description_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR RequestBlob::RequestBlob(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RequestBlob_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RequestBlobDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBlobDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBlobDefaultTypeInternal() {}
  union {
    RequestBlob _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBlobDefaultTypeInternal _RequestBlob_default_instance_;

inline constexpr Reject::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::NoxProto::Reject_RejectType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Reject::Reject(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Reject_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RejectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RejectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RejectDefaultTypeInternal() {}
  union {
    Reject _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RejectDefaultTypeInternal _Reject_default_instance_;

inline constexpr QueryUsers::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : ids_{},
        names_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR QueryUsers::QueryUsers(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(QueryUsers_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct QueryUsersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryUsersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryUsersDefaultTypeInternal() {}
  union {
    QueryUsers _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryUsersDefaultTypeInternal _QueryUsers_default_instance_;

inline constexpr PluginDataTransmission::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        receiversessions_{},
        _receiversessions_cached_byte_size_{0},
        data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dataid_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        sendersession_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR PluginDataTransmission::PluginDataTransmission(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PluginDataTransmission_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PluginDataTransmissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PluginDataTransmissionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PluginDataTransmissionDefaultTypeInternal() {}
  union {
    PluginDataTransmission _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PluginDataTransmissionDefaultTypeInternal _PluginDataTransmission_default_instance_;

inline constexpr Ping::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_{::uint64_t{0u}},
        good_{0u},
        late_{0u},
        lost_{0u},
        resync_{0u},
        udp_packets_{0u},
        tcp_packets_{0u},
        udp_ping_avg_{0},
        udp_ping_var_{0},
        tcp_ping_avg_{0},
        tcp_ping_var_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Ping::Ping(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Ping_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PingDefaultTypeInternal() {}
  union {
    Ping _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PingDefaultTypeInternal _Ping_default_instance_;

inline constexpr PermissionQuery::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channel_id_{0u},
        permissions_{0u},
        flush_{false} {}

template <typename>
PROTOBUF_CONSTEXPR PermissionQuery::PermissionQuery(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PermissionQuery_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PermissionQueryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionQueryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionQueryDefaultTypeInternal() {}
  union {
    PermissionQuery _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionQueryDefaultTypeInternal _PermissionQuery_default_instance_;

inline constexpr PermissionDenied::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        permission_{0u},
        channel_id_{0u},
        session_{0u},
        type_{static_cast< ::NoxProto::PermissionDenied_DenyType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR PermissionDenied::PermissionDenied(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PermissionDenied_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PermissionDeniedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionDeniedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionDeniedDefaultTypeInternal() {}
  union {
    PermissionDenied _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionDeniedDefaultTypeInternal _PermissionDenied_default_instance_;

inline constexpr CryptSetup::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        client_nonce_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        server_nonce_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR CryptSetup::CryptSetup(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CryptSetup_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CryptSetupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CryptSetupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CryptSetupDefaultTypeInternal() {}
  union {
    CryptSetup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptSetupDefaultTypeInternal _CryptSetup_default_instance_;

inline constexpr ContextActionModify::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        action_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        context_{0u},
        operation_{static_cast< ::NoxProto::ContextActionModify_Operation >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR ContextActionModify::ContextActionModify(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ContextActionModify_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ContextActionModifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContextActionModifyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContextActionModifyDefaultTypeInternal() {}
  union {
    ContextActionModify _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextActionModifyDefaultTypeInternal _ContextActionModify_default_instance_;

inline constexpr ContextAction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        action_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        channel_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ContextAction::ContextAction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ContextAction_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ContextActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContextActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContextActionDefaultTypeInternal() {}
  union {
    ContextAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextActionDefaultTypeInternal _ContextAction_default_instance_;

inline constexpr CodecVersion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        alpha_{0},
        beta_{0},
        opus_{false},
        prefer_alpha_{true} {}

template <typename>
PROTOBUF_CONSTEXPR CodecVersion::CodecVersion(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CodecVersion_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CodecVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CodecVersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CodecVersionDefaultTypeInternal() {}
  union {
    CodecVersion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CodecVersionDefaultTypeInternal _CodecVersion_default_instance_;

inline constexpr ChannelState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        links_{},
        links_add_{},
        links_remove_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        channel_id_{0u},
        parent_{0u},
        position_{0},
        max_users_{0u},
        temporary_{false},
        is_enter_restricted_{false},
        can_enter_{false} {}

template <typename>
PROTOBUF_CONSTEXPR ChannelState::ChannelState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChannelState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChannelStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChannelStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChannelStateDefaultTypeInternal() {}
  union {
    ChannelState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChannelStateDefaultTypeInternal _ChannelState_default_instance_;

inline constexpr ChannelRemove::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channel_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ChannelRemove::ChannelRemove(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChannelRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChannelRemoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChannelRemoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChannelRemoveDefaultTypeInternal() {}
  union {
    ChannelRemove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChannelRemoveDefaultTypeInternal _ChannelRemove_default_instance_;

inline constexpr BanList_BanEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        start_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mask_{0u},
        duration_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR BanList_BanEntry::BanList_BanEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BanList_BanEntry_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BanList_BanEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BanList_BanEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BanList_BanEntryDefaultTypeInternal() {}
  union {
    BanList_BanEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BanList_BanEntryDefaultTypeInternal _BanList_BanEntry_default_instance_;

inline constexpr Authenticate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        tokens_{},
        celt_versions_{},
        username_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        opus_{false},
        client_type_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Authenticate::Authenticate(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Authenticate_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AuthenticateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticateDefaultTypeInternal() {}
  union {
    Authenticate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticateDefaultTypeInternal _Authenticate_default_instance_;

inline constexpr ACL_ChanGroup::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        add_{},
        remove_{},
        inherited_members_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        inherited_{true},
        inherit_{true},
        inheritable_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL_ChanGroup::ACL_ChanGroup(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_ChanGroup_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACL_ChanGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACL_ChanGroupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACL_ChanGroupDefaultTypeInternal() {}
  union {
    ACL_ChanGroup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACL_ChanGroupDefaultTypeInternal _ACL_ChanGroup_default_instance_;

inline constexpr ACL_ChanACL::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        group_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        user_id_{0u},
        grant_{0u},
        deny_{0u},
        apply_here_{true},
        apply_subs_{true},
        inherited_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL_ChanACL::ACL_ChanACL(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_ChanACL_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACL_ChanACLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACL_ChanACLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACL_ChanACLDefaultTypeInternal() {}
  union {
    ACL_ChanACL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACL_ChanACLDefaultTypeInternal _ACL_ChanACL_default_instance_;

inline constexpr VoiceTarget::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        targets_{},
        id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR VoiceTarget::VoiceTarget(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(VoiceTarget_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VoiceTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoiceTargetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoiceTargetDefaultTypeInternal() {}
  union {
    VoiceTarget _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoiceTargetDefaultTypeInternal _VoiceTarget_default_instance_;

inline constexpr UserStats_RollingStats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        from_client_{nullptr},
        from_server_{nullptr},
        time_window_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserStats_RollingStats::UserStats_RollingStats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserStats_RollingStats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStats_RollingStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStats_RollingStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStats_RollingStatsDefaultTypeInternal() {}
  union {
    UserStats_RollingStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStats_RollingStatsDefaultTypeInternal _UserStats_RollingStats_default_instance_;

inline constexpr UserState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        temporary_access_tokens_{},
        listening_channel_add_{},
        listening_channel_remove_{},
        listening_volume_adjustment_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        texture_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        plugin_context_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        plugin_identity_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        comment_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        comment_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        texture_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        actor_{0u},
        user_id_{0u},
        channel_id_{0u},
        mute_{false},
        deaf_{false},
        suppress_{false},
        self_mute_{false},
        self_deaf_{false},
        priority_speaker_{false},
        recording_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UserState::UserState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStateDefaultTypeInternal() {}
  union {
    UserState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStateDefaultTypeInternal _UserState_default_instance_;

inline constexpr UserList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : users_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR UserList::UserList(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserList_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserListDefaultTypeInternal() {}
  union {
    UserList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserListDefaultTypeInternal _UserList_default_instance_;

inline constexpr BanList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        bans_{},
        query_{false} {}

template <typename>
PROTOBUF_CONSTEXPR BanList::BanList(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BanList_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BanListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BanListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BanListDefaultTypeInternal() {}
  union {
    BanList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BanListDefaultTypeInternal _BanList_default_instance_;

inline constexpr ACL::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        groups_{},
        acls_{},
        channel_id_{0u},
        query_{false},
        inherit_acls_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL::ACL(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACLDefaultTypeInternal() {}
  union {
    ACL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACLDefaultTypeInternal _ACL_default_instance_;

inline constexpr UserStats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        certificates_{},
        celt_versions_{},
        address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        from_client_{nullptr},
        from_server_{nullptr},
        version_{nullptr},
        rolling_stats_{nullptr},
        session_{0u},
        udp_packets_{0u},
        tcp_packets_{0u},
        udp_ping_avg_{0},
        udp_ping_var_{0},
        tcp_ping_avg_{0},
        tcp_ping_var_{0},
        stats_only_{false},
        strong_certificate_{false},
        opus_{false},
        bandwidth_{0u},
        onlinesecs_{0u},
        idlesecs_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserStats::UserStats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserStats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStatsDefaultTypeInternal() {}
  union {
    UserStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatsDefaultTypeInternal _UserStats_default_instance_;
}  // namespace NoxProto
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_Nox_2eproto[4];
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_Nox_2eproto = nullptr;
const ::uint32_t
    TableStruct_Nox_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_.version_v1_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_.version_v2_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_.release_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_.os_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Version, _impl_.os_version_),
        4,
        3,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UDPTunnel, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UDPTunnel, _impl_.packet_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.username_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.password_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.tokens_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.celt_versions_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.opus_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Authenticate, _impl_.client_type_),
        0,
        1,
        ~0u,
        ~0u,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_._has_bits_),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.good_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.late_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.lost_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.resync_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.udp_packets_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.tcp_packets_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.udp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.udp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.tcp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Ping, _impl_.tcp_ping_var_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::Reject, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::Reject, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::Reject, _impl_.reason_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerSync, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerSync, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerSync, _impl_.max_bandwidth_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerSync, _impl_.welcome_text_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerSync, _impl_.permissions_),
        1,
        2,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelRemove, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelRemove, _impl_.channel_id_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_._has_bits_),
        16, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.parent_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.links_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.description_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.links_add_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.links_remove_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.temporary_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.description_hash_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.max_users_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.is_enter_restricted_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ChannelState, _impl_.can_enter_),
        3,
        4,
        0,
        ~0u,
        1,
        ~0u,
        ~0u,
        7,
        5,
        2,
        6,
        8,
        9,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.ban_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.ban_certificate_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserRemove, _impl_.ban_ip_),
        1,
        2,
        0,
        3,
        4,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState_VolumeAdjustment, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState_VolumeAdjustment, _impl_.listening_channel_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState_VolumeAdjustment, _impl_.volume_adjustment_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_._has_bits_),
        26, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.mute_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.deaf_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.suppress_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.self_mute_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.self_deaf_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.texture_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.plugin_context_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.plugin_identity_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.comment_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.comment_hash_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.texture_hash_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.priority_speaker_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.recording_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.temporary_access_tokens_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.listening_channel_add_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.listening_channel_remove_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserState, _impl_.listening_volume_adjustment_),
        8,
        9,
        0,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        17,
        18,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.address_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.mask_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.start_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList_BanEntry, _impl_.duration_),
        0,
        5,
        1,
        2,
        3,
        4,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList, _impl_.bans_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::BanList, _impl_.query_),
        ~0u,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_.tree_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::TextMessage, _impl_.message_),
        1,
        ~0u,
        ~0u,
        ~0u,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.permission_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionDenied, _impl_.name_),
        2,
        3,
        4,
        0,
        5,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.inherited_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.inherit_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.inheritable_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.add_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.remove_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanGroup, _impl_.inherited_members_),
        0,
        1,
        2,
        3,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.apply_here_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.apply_subs_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.inherited_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.group_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.grant_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL_ChanACL, _impl_.deny_),
        4,
        5,
        6,
        1,
        0,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_.inherit_acls_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_.groups_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_.acls_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ACL, _impl_.query_),
        0,
        2,
        ~0u,
        ~0u,
        1,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::QueryUsers, _impl_.ids_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::QueryUsers, _impl_.names_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::CryptSetup, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::CryptSetup, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::CryptSetup, _impl_.client_nonce_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::CryptSetup, _impl_.server_nonce_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextActionModify, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextActionModify, _impl_.action_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextActionModify, _impl_.text_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextActionModify, _impl_.context_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextActionModify, _impl_.operation_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextAction, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextAction, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextAction, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ContextAction, _impl_.action_),
        1,
        2,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList_User, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList_User, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList_User, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList_User, _impl_.last_seen_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList_User, _impl_.last_channel_),
        2,
        0,
        1,
        3,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserList, _impl_.users_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_.group_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_.links_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget_Target, _impl_.children_),
        ~0u,
        1,
        0,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::VoiceTarget, _impl_.targets_),
        0,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionQuery, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionQuery, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionQuery, _impl_.permissions_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PermissionQuery, _impl_.flush_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::CodecVersion, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::CodecVersion, _impl_.alpha_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::CodecVersion, _impl_.beta_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::CodecVersion, _impl_.prefer_alpha_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::CodecVersion, _impl_.opus_),
        0,
        1,
        3,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_Stats, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_Stats, _impl_.good_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_Stats, _impl_.late_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_Stats, _impl_.lost_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_Stats, _impl_.resync_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_RollingStats, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_RollingStats, _impl_.time_window_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_RollingStats, _impl_.from_client_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats_RollingStats, _impl_.from_server_),
        2,
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_._has_bits_),
        23, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.stats_only_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.certificates_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.from_client_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.from_server_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.udp_packets_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.tcp_packets_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.udp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.udp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.tcp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.tcp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.celt_versions_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.address_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.bandwidth_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.onlinesecs_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.idlesecs_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.strong_certificate_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.opus_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::UserStats, _impl_.rolling_stats_),
        5,
        12,
        ~0u,
        1,
        2,
        6,
        7,
        8,
        9,
        10,
        11,
        3,
        ~0u,
        0,
        15,
        16,
        17,
        13,
        14,
        4,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::RequestBlob, _impl_.session_texture_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::RequestBlob, _impl_.session_comment_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::RequestBlob, _impl_.channel_description_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.max_bandwidth_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.welcome_text_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.allow_html_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.message_length_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.image_message_length_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.max_users_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::ServerConfig, _impl_.recording_allowed_),
        1,
        0,
        4,
        2,
        3,
        6,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::SuggestConfig, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::SuggestConfig, _impl_.version_v1_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::SuggestConfig, _impl_.version_v2_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::SuggestConfig, _impl_.positional_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::SuggestConfig, _impl_.push_to_talk_),
        0,
        3,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::NoxProto::PluginDataTransmission, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::NoxProto::PluginDataTransmission, _impl_.sendersession_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PluginDataTransmission, _impl_.receiversessions_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PluginDataTransmission, _impl_.data_),
        PROTOBUF_FIELD_OFFSET(::NoxProto::PluginDataTransmission, _impl_.dataid_),
        2,
        ~0u,
        0,
        1,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::NoxProto::Version)},
        {13, sizeof(::NoxProto::UDPTunnel)},
        {18, sizeof(::NoxProto::Authenticate)},
        {33, sizeof(::NoxProto::Ping)},
        {58, sizeof(::NoxProto::Reject)},
        {65, sizeof(::NoxProto::ServerSync)},
        {76, sizeof(::NoxProto::ChannelRemove)},
        {81, sizeof(::NoxProto::ChannelState)},
        {110, sizeof(::NoxProto::UserRemove)},
        {125, sizeof(::NoxProto::UserState_VolumeAdjustment)},
        {132, sizeof(::NoxProto::UserState)},
        {181, sizeof(::NoxProto::BanList_BanEntry)},
        {198, sizeof(::NoxProto::BanList)},
        {205, sizeof(::NoxProto::TextMessage)},
        {218, sizeof(::NoxProto::PermissionDenied)},
        {233, sizeof(::NoxProto::ACL_ChanGroup)},
        {250, sizeof(::NoxProto::ACL_ChanACL)},
        {267, sizeof(::NoxProto::ACL)},
        {280, sizeof(::NoxProto::QueryUsers)},
        {283, sizeof(::NoxProto::CryptSetup)},
        {292, sizeof(::NoxProto::ContextActionModify)},
        {303, sizeof(::NoxProto::ContextAction)},
        {312, sizeof(::NoxProto::UserList_User)},
        {323, sizeof(::NoxProto::UserList)},
        {325, sizeof(::NoxProto::VoiceTarget_Target)},
        {338, sizeof(::NoxProto::VoiceTarget)},
        {345, sizeof(::NoxProto::PermissionQuery)},
        {354, sizeof(::NoxProto::CodecVersion)},
        {365, sizeof(::NoxProto::UserStats_Stats)},
        {376, sizeof(::NoxProto::UserStats_RollingStats)},
        {385, sizeof(::NoxProto::UserStats)},
        {428, sizeof(::NoxProto::RequestBlob)},
        {432, sizeof(::NoxProto::ServerConfig)},
        {449, sizeof(::NoxProto::SuggestConfig)},
        {460, sizeof(::NoxProto::PluginDataTransmission)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::NoxProto::_Version_default_instance_._instance,
    &::NoxProto::_UDPTunnel_default_instance_._instance,
    &::NoxProto::_Authenticate_default_instance_._instance,
    &::NoxProto::_Ping_default_instance_._instance,
    &::NoxProto::_Reject_default_instance_._instance,
    &::NoxProto::_ServerSync_default_instance_._instance,
    &::NoxProto::_ChannelRemove_default_instance_._instance,
    &::NoxProto::_ChannelState_default_instance_._instance,
    &::NoxProto::_UserRemove_default_instance_._instance,
    &::NoxProto::_UserState_VolumeAdjustment_default_instance_._instance,
    &::NoxProto::_UserState_default_instance_._instance,
    &::NoxProto::_BanList_BanEntry_default_instance_._instance,
    &::NoxProto::_BanList_default_instance_._instance,
    &::NoxProto::_TextMessage_default_instance_._instance,
    &::NoxProto::_PermissionDenied_default_instance_._instance,
    &::NoxProto::_ACL_ChanGroup_default_instance_._instance,
    &::NoxProto::_ACL_ChanACL_default_instance_._instance,
    &::NoxProto::_ACL_default_instance_._instance,
    &::NoxProto::_QueryUsers_default_instance_._instance,
    &::NoxProto::_CryptSetup_default_instance_._instance,
    &::NoxProto::_ContextActionModify_default_instance_._instance,
    &::NoxProto::_ContextAction_default_instance_._instance,
    &::NoxProto::_UserList_User_default_instance_._instance,
    &::NoxProto::_UserList_default_instance_._instance,
    &::NoxProto::_VoiceTarget_Target_default_instance_._instance,
    &::NoxProto::_VoiceTarget_default_instance_._instance,
    &::NoxProto::_PermissionQuery_default_instance_._instance,
    &::NoxProto::_CodecVersion_default_instance_._instance,
    &::NoxProto::_UserStats_Stats_default_instance_._instance,
    &::NoxProto::_UserStats_RollingStats_default_instance_._instance,
    &::NoxProto::_UserStats_default_instance_._instance,
    &::NoxProto::_RequestBlob_default_instance_._instance,
    &::NoxProto::_ServerConfig_default_instance_._instance,
    &::NoxProto::_SuggestConfig_default_instance_._instance,
    &::NoxProto::_PluginDataTransmission_default_instance_._instance,
};
const char descriptor_table_protodef_Nox_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\tNox.proto\022\010NoxProto\"b\n\007Version\022\022\n\nvers"
    "ion_v1\030\001 \001(\r\022\022\n\nversion_v2\030\005 \001(\004\022\017\n\007rele"
    "ase\030\002 \001(\t\022\n\n\002os\030\003 \001(\t\022\022\n\nos_version\030\004 \001("
    "\t\"\033\n\tUDPTunnel\022\016\n\006packet\030\001 \002(\014\"\206\001\n\014Authe"
    "nticate\022\020\n\010username\030\001 \001(\t\022\020\n\010password\030\002 "
    "\001(\t\022\016\n\006tokens\030\003 \003(\t\022\025\n\rcelt_versions\030\004 \003"
    "(\005\022\023\n\004opus\030\005 \001(\010:\005false\022\026\n\013client_type\030\006"
    " \001(\005:\0010\"\325\001\n\004Ping\022\021\n\ttimestamp\030\001 \001(\004\022\014\n\004g"
    "ood\030\002 \001(\r\022\014\n\004late\030\003 \001(\r\022\014\n\004lost\030\004 \001(\r\022\016\n"
    "\006resync\030\005 \001(\r\022\023\n\013udp_packets\030\006 \001(\r\022\023\n\013tc"
    "p_packets\030\007 \001(\r\022\024\n\014udp_ping_avg\030\010 \001(\002\022\024\n"
    "\014udp_ping_var\030\t \001(\002\022\024\n\014tcp_ping_avg\030\n \001("
    "\002\022\024\n\014tcp_ping_var\030\013 \001(\002\"\212\002\n\006Reject\022)\n\004ty"
    "pe\030\001 \001(\0162\033.NoxProto.Reject.RejectType\022\016\n"
    "\006reason\030\002 \001(\t\"\304\001\n\nRejectType\022\010\n\004None\020\000\022\020"
    "\n\014WrongVersion\020\001\022\023\n\017InvalidUsername\020\002\022\017\n"
    "\013WrongUserPW\020\003\022\021\n\rWrongServerPW\020\004\022\021\n\rUse"
    "rnameInUse\020\005\022\016\n\nServerFull\020\006\022\021\n\rNoCertif"
    "icate\020\007\022\025\n\021AuthenticatorFail\020\010\022\024\n\020NoNewC"
    "onnections\020\t\"_\n\nServerSync\022\017\n\007session\030\001 "
    "\001(\r\022\025\n\rmax_bandwidth\030\002 \001(\r\022\024\n\014welcome_te"
    "xt\030\003 \001(\t\022\023\n\013permissions\030\004 \001(\004\"#\n\rChannel"
    "Remove\022\022\n\nchannel_id\030\001 \002(\r\"\231\002\n\014ChannelSt"
    "ate\022\022\n\nchannel_id\030\001 \001(\r\022\016\n\006parent\030\002 \001(\r\022"
    "\014\n\004name\030\003 \001(\t\022\r\n\005links\030\004 \003(\r\022\023\n\013descript"
    "ion\030\005 \001(\t\022\021\n\tlinks_add\030\006 \003(\r\022\024\n\014links_re"
    "move\030\007 \003(\r\022\030\n\ttemporary\030\010 \001(\010:\005false\022\023\n\010"
    "position\030\t \001(\005:\0010\022\030\n\020description_hash\030\n "
    "\001(\014\022\021\n\tmax_users\030\013 \001(\r\022\033\n\023is_enter_restr"
    "icted\030\014 \001(\010\022\021\n\tcan_enter\030\r \001(\010\"r\n\nUserRe"
    "move\022\017\n\007session\030\001 \002(\r\022\r\n\005actor\030\002 \001(\r\022\016\n\006"
    "reason\030\003 \001(\t\022\013\n\003ban\030\004 \001(\010\022\027\n\017ban_certifi"
    "cate\030\005 \001(\010\022\016\n\006ban_ip\030\006 \001(\010\"\343\004\n\tUserState"
    "\022\017\n\007session\030\001 \001(\r\022\r\n\005actor\030\002 \001(\r\022\014\n\004name"
    "\030\003 \001(\t\022\017\n\007user_id\030\004 \001(\r\022\022\n\nchannel_id\030\005 "
    "\001(\r\022\014\n\004mute\030\006 \001(\010\022\014\n\004deaf\030\007 \001(\010\022\020\n\010suppr"
    "ess\030\010 \001(\010\022\021\n\tself_mute\030\t \001(\010\022\021\n\tself_dea"
    "f\030\n \001(\010\022\017\n\007texture\030\013 \001(\014\022\026\n\016plugin_conte"
    "xt\030\014 \001(\014\022\027\n\017plugin_identity\030\r \001(\t\022\017\n\007com"
    "ment\030\016 \001(\t\022\014\n\004hash\030\017 \001(\t\022\024\n\014comment_hash"
    "\030\020 \001(\014\022\024\n\014texture_hash\030\021 \001(\014\022\030\n\020priority"
    "_speaker\030\022 \001(\010\022\021\n\trecording\030\023 \001(\010\022\037\n\027tem"
    "porary_access_tokens\030\024 \003(\t\022\035\n\025listening_"
    "channel_add\030\025 \003(\r\022 \n\030listening_channel_r"
    "emove\030\026 \003(\r\022I\n\033listening_volume_adjustme"
    "nt\030\027 \003(\0132$.NoxProto.UserState.VolumeAdju"
    "stment\032H\n\020VolumeAdjustment\022\031\n\021listening_"
    "channel\030\001 \001(\r\022\031\n\021volume_adjustment\030\002 \001(\002"
    "\"\301\001\n\007BanList\022(\n\004bans\030\001 \003(\0132\032.NoxProto.Ba"
    "nList.BanEntry\022\024\n\005query\030\002 \001(\010:\005false\032v\n\010"
    "BanEntry\022\017\n\007address\030\001 \002(\014\022\014\n\004mask\030\002 \002(\r\022"
    "\014\n\004name\030\003 \001(\t\022\014\n\004hash\030\004 \001(\t\022\016\n\006reason\030\005 "
    "\001(\t\022\r\n\005start\030\006 \001(\t\022\020\n\010duration\030\007 \001(\r\"c\n\013"
    "TextMessage\022\r\n\005actor\030\001 \001(\r\022\017\n\007session\030\002 "
    "\003(\r\022\022\n\nchannel_id\030\003 \003(\r\022\017\n\007tree_id\030\004 \003(\r"
    "\022\017\n\007message\030\005 \002(\t\"\244\003\n\020PermissionDenied\022\022"
    "\n\npermission\030\001 \001(\r\022\022\n\nchannel_id\030\002 \001(\r\022\017"
    "\n\007session\030\003 \001(\r\022\016\n\006reason\030\004 \001(\t\0221\n\004type\030"
    "\005 \001(\0162#.NoxProto.PermissionDenied.DenyTy"
    "pe\022\014\n\004name\030\006 \001(\t\"\205\002\n\010DenyType\022\010\n\004Text\020\000\022"
    "\016\n\nPermission\020\001\022\r\n\tSuperUser\020\002\022\017\n\013Channe"
    "lName\020\003\022\017\n\013TextTooLong\020\004\022\007\n\003H9K\020\005\022\024\n\020Tem"
    "poraryChannel\020\006\022\026\n\022MissingCertificate\020\007\022"
    "\014\n\010UserName\020\010\022\017\n\013ChannelFull\020\t\022\020\n\014Nestin"
    "gLimit\020\n\022\025\n\021ChannelCountLimit\020\013\022\030\n\024Chann"
    "elListenerLimit\020\014\022\025\n\021UserListenerLimit\020\r"
    "\"\316\003\n\003ACL\022\022\n\nchannel_id\030\001 \002(\r\022\032\n\014inherit_"
    "acls\030\002 \001(\010:\004true\022\'\n\006groups\030\003 \003(\0132\027.NoxPr"
    "oto.ACL.ChanGroup\022#\n\004acls\030\004 \003(\0132\025.NoxPro"
    "to.ACL.ChanACL\022\024\n\005query\030\005 \001(\010:\005false\032\234\001\n"
    "\tChanGroup\022\014\n\004name\030\001 \002(\t\022\027\n\tinherited\030\002 "
    "\001(\010:\004true\022\025\n\007inherit\030\003 \001(\010:\004true\022\031\n\013inhe"
    "ritable\030\004 \001(\010:\004true\022\013\n\003add\030\005 \003(\r\022\016\n\006remo"
    "ve\030\006 \003(\r\022\031\n\021inherited_members\030\007 \003(\r\032\223\001\n\007"
    "ChanACL\022\030\n\napply_here\030\001 \001(\010:\004true\022\030\n\napp"
    "ly_subs\030\002 \001(\010:\004true\022\027\n\tinherited\030\003 \001(\010:\004"
    "true\022\017\n\007user_id\030\004 \001(\r\022\r\n\005group\030\005 \001(\t\022\r\n\005"
    "grant\030\006 \001(\r\022\014\n\004deny\030\007 \001(\r\"(\n\nQueryUsers\022"
    "\013\n\003ids\030\001 \003(\r\022\r\n\005names\030\002 \003(\t\"E\n\nCryptSetu"
    "p\022\013\n\003key\030\001 \001(\014\022\024\n\014client_nonce\030\002 \001(\014\022\024\n\014"
    "server_nonce\030\003 \001(\014\"\320\001\n\023ContextActionModi"
    "fy\022\016\n\006action\030\001 \002(\t\022\014\n\004text\030\002 \001(\t\022\017\n\007cont"
    "ext\030\003 \001(\r\022:\n\toperation\030\004 \001(\0162\'.NoxProto."
    "ContextActionModify.Operation\",\n\007Context"
    "\022\n\n\006Server\020\001\022\013\n\007Channel\020\002\022\010\n\004User\020\004\" \n\tO"
    "peration\022\007\n\003Add\020\000\022\n\n\006Remove\020\001\"D\n\rContext"
    "Action\022\017\n\007session\030\001 \001(\r\022\022\n\nchannel_id\030\002 "
    "\001(\r\022\016\n\006action\030\003 \002(\t\"\202\001\n\010UserList\022&\n\005user"
    "s\030\001 \003(\0132\027.NoxProto.UserList.User\032N\n\004User"
    "\022\017\n\007user_id\030\001 \002(\r\022\014\n\004name\030\002 \001(\t\022\021\n\tlast_"
    "seen\030\003 \001(\t\022\024\n\014last_channel\030\004 \001(\r\"\265\001\n\013Voi"
    "ceTarget\022\n\n\002id\030\001 \001(\r\022-\n\007targets\030\002 \003(\0132\034."
    "NoxProto.VoiceTarget.Target\032k\n\006Target\022\017\n"
    "\007session\030\001 \003(\r\022\022\n\nchannel_id\030\002 \001(\r\022\r\n\005gr"
    "oup\030\003 \001(\t\022\024\n\005links\030\004 \001(\010:\005false\022\027\n\010child"
    "ren\030\005 \001(\010:\005false\"P\n\017PermissionQuery\022\022\n\nc"
    "hannel_id\030\001 \001(\r\022\023\n\013permissions\030\002 \001(\r\022\024\n\005"
    "flush\030\003 \001(\010:\005false\"\\\n\014CodecVersion\022\r\n\005al"
    "pha\030\001 \002(\005\022\014\n\004beta\030\002 \002(\005\022\032\n\014prefer_alpha\030"
    "\003 \002(\010:\004true\022\023\n\004opus\030\004 \001(\010:\005false\"\356\005\n\tUse"
    "rStats\022\017\n\007session\030\001 \001(\r\022\031\n\nstats_only\030\002 "
    "\001(\010:\005false\022\024\n\014certificates\030\003 \003(\014\022.\n\013from"
    "_client\030\004 \001(\0132\031.NoxProto.UserStats.Stats"
    "\022.\n\013from_server\030\005 \001(\0132\031.NoxProto.UserSta"
    "ts.Stats\022\023\n\013udp_packets\030\006 \001(\r\022\023\n\013tcp_pac"
    "kets\030\007 \001(\r\022\024\n\014udp_ping_avg\030\010 \001(\002\022\024\n\014udp_"
    "ping_var\030\t \001(\002\022\024\n\014tcp_ping_avg\030\n \001(\002\022\024\n\014"
    "tcp_ping_var\030\013 \001(\002\022\"\n\007version\030\014 \001(\0132\021.No"
    "xProto.Version\022\025\n\rcelt_versions\030\r \003(\005\022\017\n"
    "\007address\030\016 \001(\014\022\021\n\tbandwidth\030\017 \001(\r\022\022\n\nonl"
    "inesecs\030\020 \001(\r\022\020\n\010idlesecs\030\021 \001(\r\022!\n\022stron"
    "g_certificate\030\022 \001(\010:\005false\022\023\n\004opus\030\023 \001(\010"
    ":\005false\0227\n\rrolling_stats\030\024 \001(\0132 .NoxProt"
    "o.UserStats.RollingStats\032A\n\005Stats\022\014\n\004goo"
    "d\030\001 \001(\r\022\014\n\004late\030\002 \001(\r\022\014\n\004lost\030\003 \001(\r\022\016\n\006r"
    "esync\030\004 \001(\r\032\203\001\n\014RollingStats\022\023\n\013time_win"
    "dow\030\001 \001(\r\022.\n\013from_client\030\002 \001(\0132\031.NoxProt"
    "o.UserStats.Stats\022.\n\013from_server\030\003 \001(\0132\031"
    ".NoxProto.UserStats.Stats\"\\\n\013RequestBlob"
    "\022\027\n\017session_texture\030\001 \003(\r\022\027\n\017session_com"
    "ment\030\002 \003(\r\022\033\n\023channel_description\030\003 \003(\r\""
    "\263\001\n\014ServerConfig\022\025\n\rmax_bandwidth\030\001 \001(\r\022"
    "\024\n\014welcome_text\030\002 \001(\t\022\022\n\nallow_html\030\003 \001("
    "\010\022\026\n\016message_length\030\004 \001(\r\022\034\n\024image_messa"
    "ge_length\030\005 \001(\r\022\021\n\tmax_users\030\006 \001(\r\022\031\n\021re"
    "cording_allowed\030\007 \001(\010\"a\n\rSuggestConfig\022\022"
    "\n\nversion_v1\030\001 \001(\r\022\022\n\nversion_v2\030\004 \001(\004\022\022"
    "\n\npositional\030\002 \001(\010\022\024\n\014push_to_talk\030\003 \001(\010"
    "\"k\n\026PluginDataTransmission\022\025\n\rsenderSess"
    "ion\030\001 \001(\r\022\034\n\020receiverSessions\030\002 \003(\rB\002\020\001\022"
    "\014\n\004data\030\003 \001(\014\022\016\n\006dataID\030\004 \001(\tB\002H\001"
};
static ::absl::once_flag descriptor_table_Nox_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_Nox_2eproto = {
    false,
    false,
    5233,
    descriptor_table_protodef_Nox_2eproto,
    "Nox.proto",
    &descriptor_table_Nox_2eproto_once,
    nullptr,
    0,
    35,
    schemas,
    file_default_instances,
    TableStruct_Nox_2eproto::offsets,
    file_level_enum_descriptors_Nox_2eproto,
    file_level_service_descriptors_Nox_2eproto,
};
namespace NoxProto {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Reject_RejectType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Nox_2eproto);
  return file_level_enum_descriptors_Nox_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Reject_RejectType_internal_data_[] = {
    655360u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PermissionDenied_DenyType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Nox_2eproto);
  return file_level_enum_descriptors_Nox_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t PermissionDenied_DenyType_internal_data_[] = {
    917504u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Context_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Nox_2eproto);
  return file_level_enum_descriptors_Nox_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t ContextActionModify_Context_internal_data_[] = {
    131073u, 32u, 2u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Operation_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Nox_2eproto);
  return file_level_enum_descriptors_Nox_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t ContextActionModify_Operation_internal_data_[] = {
    131072u, 0u, };
// ===================================================================

class Version::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Version>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Version, _impl_._has_bits_);
};

Version::Version(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Version_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.Version)
}
PROTOBUF_NDEBUG_INLINE Version::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::Version& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        release_(arena, from.release_),
        os_(arena, from.os_),
        os_version_(arena, from.os_version_) {}

Version::Version(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Version& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Version_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Version* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, version_v2_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, version_v2_),
           offsetof(Impl_, version_v1_) -
               offsetof(Impl_, version_v2_) +
               sizeof(Impl_::version_v1_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.Version)
}
PROTOBUF_NDEBUG_INLINE Version::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        release_(arena),
        os_(arena),
        os_version_(arena) {}

inline void Version::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, version_v2_),
           0,
           offsetof(Impl_, version_v1_) -
               offsetof(Impl_, version_v2_) +
               sizeof(Impl_::version_v1_));
}
Version::~Version() {
  // @@protoc_insertion_point(destructor:NoxProto.Version)
  SharedDtor(*this);
}
inline void Version::SharedDtor(MessageLite& self) {
  Version& this_ = static_cast<Version&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.release_.Destroy();
  this_._impl_.os_.Destroy();
  this_._impl_.os_version_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Version::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Version(arena);
}
constexpr auto Version::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Version),
                                            alignof(Version));
}
constexpr auto Version::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Version_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Version::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Version>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Version::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Version>(), &Version::ByteSizeLong,
              &Version::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Version, _impl_._cached_size_),
          false,
      },
      &Version::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Version_class_data_ =
        Version::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Version::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Version_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Version_class_data_.tc_table);
  return Version_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 44, 2>
Version::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Version, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Version_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::Version>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 version_v1 = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Version, _impl_.version_v1_), 4>(),
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v1_)}},
    // optional string release = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.release_)}},
    // optional string os = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.os_)}},
    // optional string os_version = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 2, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.os_version_)}},
    // optional uint64 version_v2 = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Version, _impl_.version_v2_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v2_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 version_v1 = 1;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v1_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string release = 2;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.release_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string os = 3;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.os_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string os_version = 4;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.os_version_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint64 version_v2 = 5;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v2_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
    "\20\0\7\2\12\0\0\0"
    "NoxProto.Version"
    "release"
    "os"
    "os_version"
  }},
};
PROTOBUF_NOINLINE void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.Version)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.release_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.os_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x00000018u) != 0) {
    ::memset(&_impl_.version_v2_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.version_v1_) -
        reinterpret_cast<char*>(&_impl_.version_v2_)) + sizeof(_impl_.version_v1_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Version::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Version::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.Version)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 version_v1 = 1;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_version_v1(), target);
  }

  // optional string release = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_release();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Version.release");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string os = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_os();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Version.os");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string os_version = 4;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_os_version();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Version.os_version");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional uint64 version_v2 = 5;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this_._internal_version_v2(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.Version)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Version::ByteSizeLong(const MessageLite& base) {
  const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Version::ByteSizeLong() const {
  const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.Version)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional string release = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_release());
    }
    // optional string os = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_os());
    }
    // optional string os_version = 4;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_os_version());
    }
    // optional uint64 version_v2 = 5;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_version_v2());
    }
    // optional uint32 version_v1 = 1;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_version_v1());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Version::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.Version)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_release(from._internal_release());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_os(from._internal_os());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.version_v2_ = from._impl_.version_v2_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.version_v1_ = from._impl_.version_v1_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Version::InternalSwap(Version* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.release_, &other->_impl_.release_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.os_, &other->_impl_.os_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.os_version_, &other->_impl_.os_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v1_)
      + sizeof(Version::_impl_.version_v1_)
      - PROTOBUF_FIELD_OFFSET(Version, _impl_.version_v2_)>(
          reinterpret_cast<char*>(&_impl_.version_v2_),
          reinterpret_cast<char*>(&other->_impl_.version_v2_));
}

::google::protobuf::Metadata Version::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UDPTunnel::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UDPTunnel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UDPTunnel::UDPTunnel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UDPTunnel_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UDPTunnel)
}
PROTOBUF_NDEBUG_INLINE UDPTunnel::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UDPTunnel& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        packet_(arena, from.packet_) {}

UDPTunnel::UDPTunnel(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UDPTunnel& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UDPTunnel_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UDPTunnel* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:NoxProto.UDPTunnel)
}
PROTOBUF_NDEBUG_INLINE UDPTunnel::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        packet_(arena) {}

inline void UDPTunnel::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
UDPTunnel::~UDPTunnel() {
  // @@protoc_insertion_point(destructor:NoxProto.UDPTunnel)
  SharedDtor(*this);
}
inline void UDPTunnel::SharedDtor(MessageLite& self) {
  UDPTunnel& this_ = static_cast<UDPTunnel&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.packet_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UDPTunnel::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UDPTunnel(arena);
}
constexpr auto UDPTunnel::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UDPTunnel),
                                            alignof(UDPTunnel));
}
constexpr auto UDPTunnel::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UDPTunnel_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UDPTunnel::IsInitializedImpl,
          &UDPTunnel::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UDPTunnel>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UDPTunnel::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UDPTunnel>(), &UDPTunnel::ByteSizeLong,
              &UDPTunnel::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._cached_size_),
          false,
      },
      &UDPTunnel::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UDPTunnel_class_data_ =
        UDPTunnel::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UDPTunnel::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UDPTunnel_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UDPTunnel_class_data_.tc_table);
  return UDPTunnel_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
UDPTunnel::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UDPTunnel_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UDPTunnel>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // required bytes packet = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_.packet_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required bytes packet = 1;
    {PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_.packet_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UDPTunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UDPTunnel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.packet_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UDPTunnel::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UDPTunnel& this_ = static_cast<const UDPTunnel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UDPTunnel::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UDPTunnel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UDPTunnel)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required bytes packet = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_packet();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UDPTunnel)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UDPTunnel::ByteSizeLong(const MessageLite& base) {
  const UDPTunnel& this_ = static_cast<const UDPTunnel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UDPTunnel::ByteSizeLong() const {
  const UDPTunnel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UDPTunnel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // required bytes packet = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_packet());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UDPTunnel::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UDPTunnel*>(&to_msg);
  auto& from = static_cast<const UDPTunnel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UDPTunnel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_internal_set_packet(from._internal_packet());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UDPTunnel::CopyFrom(const UDPTunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UDPTunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UDPTunnel::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UDPTunnel&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UDPTunnel::InternalSwap(UDPTunnel* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_, &other->_impl_.packet_, arena);
}

::google::protobuf::Metadata UDPTunnel::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Authenticate::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Authenticate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._has_bits_);
};

Authenticate::Authenticate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Authenticate_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.Authenticate)
}
PROTOBUF_NDEBUG_INLINE Authenticate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::Authenticate& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        tokens_{visibility, arena, from.tokens_},
        celt_versions_{visibility, arena, from.celt_versions_},
        username_(arena, from.username_),
        password_(arena, from.password_) {}

Authenticate::Authenticate(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Authenticate& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Authenticate_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Authenticate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, opus_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, opus_),
           offsetof(Impl_, client_type_) -
               offsetof(Impl_, opus_) +
               sizeof(Impl_::client_type_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.Authenticate)
}
PROTOBUF_NDEBUG_INLINE Authenticate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        tokens_{visibility, arena},
        celt_versions_{visibility, arena},
        username_(arena),
        password_(arena) {}

inline void Authenticate::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, opus_),
           0,
           offsetof(Impl_, client_type_) -
               offsetof(Impl_, opus_) +
               sizeof(Impl_::client_type_));
}
Authenticate::~Authenticate() {
  // @@protoc_insertion_point(destructor:NoxProto.Authenticate)
  SharedDtor(*this);
}
inline void Authenticate::SharedDtor(MessageLite& self) {
  Authenticate& this_ = static_cast<Authenticate&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.username_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Authenticate::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Authenticate(arena);
}
constexpr auto Authenticate::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_) +
          decltype(Authenticate::_impl_.tokens_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_) +
          decltype(Authenticate::_impl_.celt_versions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Authenticate), alignof(Authenticate), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Authenticate::PlacementNew_,
                                 sizeof(Authenticate),
                                 alignof(Authenticate));
  }
}
constexpr auto Authenticate::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Authenticate_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Authenticate::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Authenticate>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Authenticate::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Authenticate>(), &Authenticate::ByteSizeLong,
              &Authenticate::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._cached_size_),
          false,
      },
      &Authenticate::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Authenticate_class_data_ =
        Authenticate::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Authenticate::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Authenticate_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Authenticate_class_data_.tc_table);
  return Authenticate_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 52, 2>
Authenticate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Authenticate_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::Authenticate>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string username = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.username_)}},
    // optional string password = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.password_)}},
    // repeated string tokens = 3;
    {::_pbi::TcParser::FastSR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_)}},
    // repeated int32 celt_versions = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_)}},
    // optional bool opus = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Authenticate, _impl_.opus_), 2>(),
     {40, 2, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.opus_)}},
    // optional int32 client_type = 6 [default = 0];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Authenticate, _impl_.client_type_), 3>(),
     {48, 3, 0, PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.client_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string username = 1;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.username_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string password = 2;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.password_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string tokens = 3;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated int32 celt_versions = 4;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // optional bool opus = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.opus_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 client_type = 6 [default = 0];
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.client_type_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\25\10\10\6\0\0\0\0"
    "NoxProto.Authenticate"
    "username"
    "password"
    "tokens"
  }},
};
PROTOBUF_NOINLINE void Authenticate::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.Authenticate)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  _impl_.celt_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.username_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.opus_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.client_type_) -
        reinterpret_cast<char*>(&_impl_.opus_)) + sizeof(_impl_.client_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Authenticate::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Authenticate& this_ = static_cast<const Authenticate&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Authenticate::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Authenticate& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.Authenticate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string username = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_username();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Authenticate.username");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string password = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_password();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Authenticate.password");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string tokens = 3;
  for (int i = 0, n = this_._internal_tokens_size(); i < n; ++i) {
    const auto& s = this_._internal_tokens().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Authenticate.tokens");
    target = stream->WriteString(3, s, target);
  }

  // repeated int32 celt_versions = 4;
  for (int i = 0, n = this_._internal_celt_versions_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this_._internal_celt_versions().Get(i), target);
  }

  // optional bool opus = 5 [default = false];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_opus(), target);
  }

  // optional int32 client_type = 6 [default = 0];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<6>(
            stream, this_._internal_client_type(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.Authenticate)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Authenticate::ByteSizeLong(const MessageLite& base) {
  const Authenticate& this_ = static_cast<const Authenticate&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Authenticate::ByteSizeLong() const {
  const Authenticate& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.Authenticate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string tokens = 3;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_tokens().size());
      for (int i = 0, n = this_._internal_tokens().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_tokens().Get(i));
      }
    }
    // repeated int32 celt_versions = 4;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_celt_versions());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_celt_versions_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000004u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000000bu) != 0) {
    // optional string username = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_username());
    }
    // optional string password = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
    // optional int32 client_type = 6 [default = 0];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_client_type());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Authenticate::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Authenticate*>(&to_msg);
  auto& from = static_cast<const Authenticate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.Authenticate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_tokens()->MergeFrom(from._internal_tokens());
  _this->_internal_mutable_celt_versions()->MergeFrom(from._internal_celt_versions());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_username(from._internal_username());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_password(from._internal_password());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.client_type_ = from._impl_.client_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Authenticate::CopyFrom(const Authenticate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.Authenticate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Authenticate::InternalSwap(Authenticate* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  _impl_.celt_versions_.InternalSwap(&other->_impl_.celt_versions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.username_, &other->_impl_.username_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.client_type_)
      + sizeof(Authenticate::_impl_.client_type_)
      - PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.opus_)>(
          reinterpret_cast<char*>(&_impl_.opus_),
          reinterpret_cast<char*>(&other->_impl_.opus_));
}

::google::protobuf::Metadata Authenticate::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Ping::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Ping>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Ping, _impl_._has_bits_);
};

Ping::Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Ping_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.Ping)
}
Ping::Ping(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Ping& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Ping_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Ping::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Ping::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_),
           0,
           offsetof(Impl_, tcp_ping_var_) -
               offsetof(Impl_, timestamp_) +
               sizeof(Impl_::tcp_ping_var_));
}
Ping::~Ping() {
  // @@protoc_insertion_point(destructor:NoxProto.Ping)
  SharedDtor(*this);
}
inline void Ping::SharedDtor(MessageLite& self) {
  Ping& this_ = static_cast<Ping&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Ping::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Ping(arena);
}
constexpr auto Ping::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Ping),
                                            alignof(Ping));
}
constexpr auto Ping::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Ping_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Ping::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Ping>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Ping::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Ping>(), &Ping::ByteSizeLong,
              &Ping::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Ping, _impl_._cached_size_),
          false,
      },
      &Ping::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Ping_class_data_ =
        Ping::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Ping::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Ping_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Ping_class_data_.tc_table);
  return Ping_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 0, 0, 2>
Ping::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Ping, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Ping_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::Ping>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 timestamp = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Ping, _impl_.timestamp_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_)}},
    // optional uint32 good = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.good_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.good_)}},
    // optional uint32 late = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.late_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.late_)}},
    // optional uint32 lost = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.lost_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.lost_)}},
    // optional uint32 resync = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.resync_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.resync_)}},
    // optional uint32 udp_packets = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.udp_packets_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_packets_)}},
    // optional uint32 tcp_packets = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.tcp_packets_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_packets_)}},
    // optional float udp_ping_avg = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_avg_)}},
    // optional float udp_ping_var = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_var_)}},
    // optional float tcp_ping_avg = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_avg_)}},
    // optional float tcp_ping_var = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 10, 0, PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 timestamp = 1;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint32 good = 2;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.good_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 late = 3;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.late_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lost = 4;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.lost_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 resync = 5;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.resync_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 udp_packets = 6;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_packets_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 tcp_packets = 7;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_packets_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float udp_ping_avg = 8;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_avg_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float udp_ping_var = 9;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_var_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_avg = 10;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_avg_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_var = 11;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Ping::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.Ping)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.udp_ping_avg_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.udp_ping_avg_));
  }
  if ((cached_has_bits & 0x00000700u) != 0) {
    ::memset(&_impl_.udp_ping_var_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tcp_ping_var_) -
        reinterpret_cast<char*>(&_impl_.udp_ping_var_)) + sizeof(_impl_.tcp_ping_var_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Ping::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Ping& this_ = static_cast<const Ping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Ping::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Ping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.Ping)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 timestamp = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this_._internal_timestamp(), target);
  }

  // optional uint32 good = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_good(), target);
  }

  // optional uint32 late = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_late(), target);
  }

  // optional uint32 lost = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_lost(), target);
  }

  // optional uint32 resync = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_resync(), target);
  }

  // optional uint32 udp_packets = 6;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_udp_packets(), target);
  }

  // optional uint32 tcp_packets = 7;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_tcp_packets(), target);
  }

  // optional float udp_ping_avg = 8;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this_._internal_udp_ping_avg(), target);
  }

  // optional float udp_ping_var = 9;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this_._internal_udp_ping_var(), target);
  }

  // optional float tcp_ping_avg = 10;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this_._internal_tcp_ping_avg(), target);
  }

  // optional float tcp_ping_var = 11;
  if ((cached_has_bits & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this_._internal_tcp_ping_var(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.Ping)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Ping::ByteSizeLong(const MessageLite& base) {
  const Ping& this_ = static_cast<const Ping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Ping::ByteSizeLong() const {
  const Ping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.Ping)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000780u & cached_has_bits) * 5;
  if ((cached_has_bits & 0x0000007fu) != 0) {
    // optional uint64 timestamp = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_timestamp());
    }
    // optional uint32 good = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_good());
    }
    // optional uint32 late = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_late());
    }
    // optional uint32 lost = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lost());
    }
    // optional uint32 resync = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_resync());
    }
    // optional uint32 udp_packets = 6;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_udp_packets());
    }
    // optional uint32 tcp_packets = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_tcp_packets());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Ping::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Ping*>(&to_msg);
  auto& from = static_cast<const Ping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.Ping)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.good_ = from._impl_.good_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.late_ = from._impl_.late_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.lost_ = from._impl_.lost_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.resync_ = from._impl_.resync_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.udp_packets_ = from._impl_.udp_packets_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.tcp_packets_ = from._impl_.tcp_packets_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.udp_ping_avg_ = from._impl_.udp_ping_avg_;
    }
  }
  if ((cached_has_bits & 0x00000700u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.udp_ping_var_ = from._impl_.udp_ping_var_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.tcp_ping_avg_ = from._impl_.tcp_ping_avg_;
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _this->_impl_.tcp_ping_var_ = from._impl_.tcp_ping_var_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Ping::CopyFrom(const Ping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.Ping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Ping::InternalSwap(Ping* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_)
      + sizeof(Ping::_impl_.tcp_ping_var_)
      - PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::google::protobuf::Metadata Ping::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Reject::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Reject>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Reject, _impl_._has_bits_);
};

Reject::Reject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Reject_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.Reject)
}
PROTOBUF_NDEBUG_INLINE Reject::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::Reject& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_) {}

Reject::Reject(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Reject& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Reject_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Reject* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.Reject)
}
PROTOBUF_NDEBUG_INLINE Reject::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena) {}

inline void Reject::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
Reject::~Reject() {
  // @@protoc_insertion_point(destructor:NoxProto.Reject)
  SharedDtor(*this);
}
inline void Reject::SharedDtor(MessageLite& self) {
  Reject& this_ = static_cast<Reject&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Reject::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Reject(arena);
}
constexpr auto Reject::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Reject),
                                            alignof(Reject));
}
constexpr auto Reject::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Reject_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Reject::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Reject>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Reject::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Reject>(), &Reject::ByteSizeLong,
              &Reject::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Reject, _impl_._cached_size_),
          false,
      },
      &Reject::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Reject_class_data_ =
        Reject::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Reject::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Reject_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Reject_class_data_.tc_table);
  return Reject_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 30, 2>
Reject::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Reject, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Reject_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::Reject>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string reason = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Reject, _impl_.reason_)}},
    // optional .NoxProto.Reject.RejectType type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 9, PROTOBUF_FIELD_OFFSET(Reject, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .NoxProto.Reject.RejectType type = 1;
    {PROTOBUF_FIELD_OFFSET(Reject, _impl_.type_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string reason = 2;
    {PROTOBUF_FIELD_OFFSET(Reject, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  {{
      {0, 9},
  }},
  {{
    "\17\0\6\0\0\0\0\0"
    "NoxProto.Reject"
    "reason"
  }},
};
PROTOBUF_NOINLINE void Reject::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.Reject)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.reason_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Reject::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Reject& this_ = static_cast<const Reject&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Reject::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Reject& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.Reject)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .NoxProto.Reject.RejectType type = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_type(), target);
  }

  // optional string reason = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_reason();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.Reject.reason");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.Reject)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Reject::ByteSizeLong(const MessageLite& base) {
  const Reject& this_ = static_cast<const Reject&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Reject::ByteSizeLong() const {
  const Reject& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.Reject)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // optional string reason = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional .NoxProto.Reject.RejectType type = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Reject::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Reject*>(&to_msg);
  auto& from = static_cast<const Reject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.Reject)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.type_ = from._impl_.type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Reject::CopyFrom(const Reject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.Reject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Reject::InternalSwap(Reject* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  swap(_impl_.type_, other->_impl_.type_);
}

::google::protobuf::Metadata Reject::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ServerSync::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ServerSync>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._has_bits_);
};

ServerSync::ServerSync(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerSync_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ServerSync)
}
PROTOBUF_NDEBUG_INLINE ServerSync::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ServerSync& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        welcome_text_(arena, from.welcome_text_) {}

ServerSync::ServerSync(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ServerSync& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerSync_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ServerSync* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, permissions_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::permissions_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ServerSync)
}
PROTOBUF_NDEBUG_INLINE ServerSync::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        welcome_text_(arena) {}

inline void ServerSync::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, permissions_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::permissions_));
}
ServerSync::~ServerSync() {
  // @@protoc_insertion_point(destructor:NoxProto.ServerSync)
  SharedDtor(*this);
}
inline void ServerSync::SharedDtor(MessageLite& self) {
  ServerSync& this_ = static_cast<ServerSync&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.welcome_text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ServerSync::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ServerSync(arena);
}
constexpr auto ServerSync::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ServerSync),
                                            alignof(ServerSync));
}
constexpr auto ServerSync::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ServerSync_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ServerSync::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ServerSync>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ServerSync::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ServerSync>(), &ServerSync::ByteSizeLong,
              &ServerSync::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._cached_size_),
          false,
      },
      &ServerSync::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ServerSync_class_data_ =
        ServerSync::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ServerSync::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ServerSync_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ServerSync_class_data_.tc_table);
  return ServerSync_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 40, 2>
ServerSync::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ServerSync_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ServerSync>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 permissions = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(ServerSync, _impl_.permissions_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_)}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerSync, _impl_.session_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_)}},
    // optional uint32 max_bandwidth = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerSync, _impl_.max_bandwidth_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.max_bandwidth_)}},
    // optional string welcome_text = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.welcome_text_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 max_bandwidth = 2;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.max_bandwidth_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string welcome_text = 3;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.welcome_text_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint64 permissions = 4;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
    "\23\0\0\14\0\0\0\0"
    "NoxProto.ServerSync"
    "welcome_text"
  }},
};
PROTOBUF_NOINLINE void ServerSync::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ServerSync)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.welcome_text_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000000eu) != 0) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.permissions_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.permissions_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ServerSync::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ServerSync& this_ = static_cast<const ServerSync&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ServerSync::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ServerSync& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ServerSync)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 max_bandwidth = 2;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_max_bandwidth(), target);
  }

  // optional string welcome_text = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_welcome_text();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ServerSync.welcome_text");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 permissions = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_permissions(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ServerSync)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ServerSync::ByteSizeLong(const MessageLite& base) {
  const ServerSync& this_ = static_cast<const ServerSync&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ServerSync::ByteSizeLong() const {
  const ServerSync& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ServerSync)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // optional string welcome_text = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_welcome_text());
    }
    // optional uint32 session = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 max_bandwidth = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_bandwidth());
    }
    // optional uint64 permissions = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_permissions());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ServerSync::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ServerSync*>(&to_msg);
  auto& from = static_cast<const ServerSync&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ServerSync)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_welcome_text(from._internal_welcome_text());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.max_bandwidth_ = from._impl_.max_bandwidth_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.permissions_ = from._impl_.permissions_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ServerSync::CopyFrom(const ServerSync& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ServerSync)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ServerSync::InternalSwap(ServerSync* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.welcome_text_, &other->_impl_.welcome_text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_)
      + sizeof(ServerSync::_impl_.permissions_)
      - PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata ServerSync::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChannelRemove::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChannelRemove>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ChannelRemove::ChannelRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ChannelRemove)
}
ChannelRemove::ChannelRemove(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelRemove& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE ChannelRemove::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void ChannelRemove::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.channel_id_ = {};
}
ChannelRemove::~ChannelRemove() {
  // @@protoc_insertion_point(destructor:NoxProto.ChannelRemove)
  SharedDtor(*this);
}
inline void ChannelRemove::SharedDtor(MessageLite& self) {
  ChannelRemove& this_ = static_cast<ChannelRemove&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ChannelRemove::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChannelRemove(arena);
}
constexpr auto ChannelRemove::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ChannelRemove),
                                            alignof(ChannelRemove));
}
constexpr auto ChannelRemove::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChannelRemove_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ChannelRemove::IsInitializedImpl,
          &ChannelRemove::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChannelRemove>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChannelRemove::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChannelRemove>(), &ChannelRemove::ByteSizeLong,
              &ChannelRemove::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._cached_size_),
          false,
      },
      &ChannelRemove::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChannelRemove_class_data_ =
        ChannelRemove::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChannelRemove::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChannelRemove_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChannelRemove_class_data_.tc_table);
  return ChannelRemove_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
ChannelRemove::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ChannelRemove_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ChannelRemove>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // required uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelRemove, _impl_.channel_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_.channel_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_.channel_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ChannelRemove::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ChannelRemove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChannelRemove::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChannelRemove& this_ = static_cast<const ChannelRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChannelRemove::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChannelRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ChannelRemove)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 channel_id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ChannelRemove)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChannelRemove::ByteSizeLong(const MessageLite& base) {
  const ChannelRemove& this_ = static_cast<const ChannelRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChannelRemove::ByteSizeLong() const {
  const ChannelRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ChannelRemove)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // required uint32 channel_id = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChannelRemove::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChannelRemove*>(&to_msg);
  auto& from = static_cast<const ChannelRemove&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ChannelRemove)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_impl_.channel_id_ = from._impl_.channel_id_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChannelRemove::CopyFrom(const ChannelRemove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ChannelRemove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ChannelRemove::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ChannelRemove&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ChannelRemove::InternalSwap(ChannelRemove* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.channel_id_, other->_impl_.channel_id_);
}

::google::protobuf::Metadata ChannelRemove::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChannelState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChannelState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._has_bits_);
};

ChannelState::ChannelState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ChannelState)
}
PROTOBUF_NDEBUG_INLINE ChannelState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ChannelState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        links_{visibility, arena, from.links_},
        links_add_{visibility, arena, from.links_add_},
        links_remove_{visibility, arena, from.links_remove_},
        name_(arena, from.name_),
        description_(arena, from.description_),
        description_hash_(arena, from.description_hash_) {}

ChannelState::ChannelState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChannelState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChannelState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, can_enter_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::can_enter_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ChannelState)
}
PROTOBUF_NDEBUG_INLINE ChannelState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        links_{visibility, arena},
        links_add_{visibility, arena},
        links_remove_{visibility, arena},
        name_(arena),
        description_(arena),
        description_hash_(arena) {}

inline void ChannelState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, can_enter_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::can_enter_));
}
ChannelState::~ChannelState() {
  // @@protoc_insertion_point(destructor:NoxProto.ChannelState)
  SharedDtor(*this);
}
inline void ChannelState::SharedDtor(MessageLite& self) {
  ChannelState& this_ = static_cast<ChannelState&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.description_.Destroy();
  this_._impl_.description_hash_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ChannelState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChannelState(arena);
}
constexpr auto ChannelState::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_) +
          decltype(ChannelState::_impl_.links_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_) +
          decltype(ChannelState::_impl_.links_add_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_) +
          decltype(ChannelState::_impl_.links_remove_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ChannelState), alignof(ChannelState), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ChannelState::PlacementNew_,
                                 sizeof(ChannelState),
                                 alignof(ChannelState));
  }
}
constexpr auto ChannelState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChannelState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChannelState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChannelState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChannelState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChannelState>(), &ChannelState::ByteSizeLong,
              &ChannelState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._cached_size_),
          false,
      },
      &ChannelState::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChannelState_class_data_ =
        ChannelState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChannelState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChannelState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChannelState_class_data_.tc_table);
  return ChannelState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 0, 53, 2>
ChannelState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ChannelState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ChannelState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.channel_id_), 3>(),
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_)}},
    // optional uint32 parent = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.parent_), 4>(),
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.parent_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.name_)}},
    // repeated uint32 links = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_)}},
    // optional string description = 5;
    {::_pbi::TcParser::FastSS1,
     {42, 1, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_)}},
    // repeated uint32 links_add = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_)}},
    // repeated uint32 links_remove = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_)}},
    // optional bool temporary = 8 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChannelState, _impl_.temporary_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.temporary_)}},
    // optional int32 position = 9 [default = 0];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.position_), 5>(),
     {72, 5, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.position_)}},
    // optional bytes description_hash = 10;
    {::_pbi::TcParser::FastBS1,
     {82, 2, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_hash_)}},
    // optional uint32 max_users = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.max_users_), 6>(),
     {88, 6, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.max_users_)}},
    // optional bool is_enter_restricted = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChannelState, _impl_.is_enter_restricted_), 8>(),
     {96, 8, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.is_enter_restricted_)}},
    // optional bool can_enter = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChannelState, _impl_.can_enter_), 9>(),
     {104, 9, 0, PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.can_enter_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 parent = 2;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.parent_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated uint32 links = 4;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional string description = 5;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated uint32 links_add = 6;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 links_remove = 7;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional bool temporary = 8 [default = false];
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.temporary_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 position = 9 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.position_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes description_hash = 10;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_hash_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 max_users = 11;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.max_users_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool is_enter_restricted = 12;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.is_enter_restricted_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool can_enter = 13;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.can_enter_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\25\0\0\4\0\13\0\0\0\0\0\0\0\0\0\0"
    "NoxProto.ChannelState"
    "name"
    "description"
  }},
};
PROTOBUF_NOINLINE void ChannelState::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ChannelState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.links_.Clear();
  _impl_.links_add_.Clear();
  _impl_.links_remove_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.description_hash_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000f8u) != 0) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.temporary_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.temporary_));
  }
  if ((cached_has_bits & 0x00000300u) != 0) {
    ::memset(&_impl_.is_enter_restricted_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.can_enter_) -
        reinterpret_cast<char*>(&_impl_.is_enter_restricted_)) + sizeof(_impl_.can_enter_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChannelState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChannelState& this_ = static_cast<const ChannelState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChannelState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChannelState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ChannelState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 channel_id = 1;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional uint32 parent = 2;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_parent(), target);
  }

  // optional string name = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ChannelState.name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // repeated uint32 links = 4;
  for (int i = 0, n = this_._internal_links_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_links().Get(i), target);
  }

  // optional string description = 5;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_description();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ChannelState.description");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated uint32 links_add = 6;
  for (int i = 0, n = this_._internal_links_add_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_links_add().Get(i), target);
  }

  // repeated uint32 links_remove = 7;
  for (int i = 0, n = this_._internal_links_remove_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_links_remove().Get(i), target);
  }

  // optional bool temporary = 8 [default = false];
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_temporary(), target);
  }

  // optional int32 position = 9 [default = 0];
  if ((cached_has_bits & 0x00000020u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<9>(
            stream, this_._internal_position(), target);
  }

  // optional bytes description_hash = 10;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_description_hash();
    target = stream->WriteBytesMaybeAliased(10, _s, target);
  }

  // optional uint32 max_users = 11;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this_._internal_max_users(), target);
  }

  // optional bool is_enter_restricted = 12;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this_._internal_is_enter_restricted(), target);
  }

  // optional bool can_enter = 13;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this_._internal_can_enter(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ChannelState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChannelState::ByteSizeLong(const MessageLite& base) {
  const ChannelState& this_ = static_cast<const ChannelState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChannelState::ByteSizeLong() const {
  const ChannelState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ChannelState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 links = 4;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 links_add = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links_add());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_add_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 links_remove = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links_remove());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_remove_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000380u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000007fu) != 0) {
    // optional string name = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string description = 5;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_description());
    }
    // optional bytes description_hash = 10;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_description_hash());
    }
    // optional uint32 channel_id = 1;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 parent = 2;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_parent());
    }
    // optional int32 position = 9 [default = 0];
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_position());
    }
    // optional uint32 max_users = 11;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_users());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChannelState::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChannelState*>(&to_msg);
  auto& from = static_cast<const ChannelState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ChannelState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_links()->MergeFrom(from._internal_links());
  _this->_internal_mutable_links_add()->MergeFrom(from._internal_links_add());
  _this->_internal_mutable_links_remove()->MergeFrom(from._internal_links_remove());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_description(from._internal_description());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_description_hash(from._internal_description_hash());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.parent_ = from._impl_.parent_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.max_users_ = from._impl_.max_users_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.temporary_ = from._impl_.temporary_;
    }
  }
  if ((cached_has_bits & 0x00000300u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.is_enter_restricted_ = from._impl_.is_enter_restricted_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.can_enter_ = from._impl_.can_enter_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChannelState::CopyFrom(const ChannelState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ChannelState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChannelState::InternalSwap(ChannelState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.links_.InternalSwap(&other->_impl_.links_);
  _impl_.links_add_.InternalSwap(&other->_impl_.links_add_);
  _impl_.links_remove_.InternalSwap(&other->_impl_.links_remove_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_hash_, &other->_impl_.description_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.can_enter_)
      + sizeof(ChannelState::_impl_.can_enter_)
      - PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata ChannelState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserRemove::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserRemove>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

UserRemove::UserRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserRemove)
}
PROTOBUF_NDEBUG_INLINE UserRemove::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserRemove& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_) {}

UserRemove::UserRemove(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserRemove& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserRemove* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, ban_ip_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::ban_ip_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserRemove)
}
PROTOBUF_NDEBUG_INLINE UserRemove::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena) {}

inline void UserRemove::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, ban_ip_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::ban_ip_));
}
UserRemove::~UserRemove() {
  // @@protoc_insertion_point(destructor:NoxProto.UserRemove)
  SharedDtor(*this);
}
inline void UserRemove::SharedDtor(MessageLite& self) {
  UserRemove& this_ = static_cast<UserRemove&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserRemove::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserRemove(arena);
}
constexpr auto UserRemove::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UserRemove),
                                            alignof(UserRemove));
}
constexpr auto UserRemove::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserRemove_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserRemove::IsInitializedImpl,
          &UserRemove::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserRemove>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserRemove::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserRemove>(), &UserRemove::ByteSizeLong,
              &UserRemove::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._cached_size_),
          false,
      },
      &UserRemove::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserRemove_class_data_ =
        UserRemove::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserRemove::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserRemove_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserRemove_class_data_.tc_table);
  return UserRemove_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 34, 2>
UserRemove::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserRemove_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserRemove>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserRemove, _impl_.session_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_)}},
    // optional uint32 actor = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserRemove, _impl_.actor_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.actor_)}},
    // optional string reason = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.reason_)}},
    // optional bool ban = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserRemove, _impl_.ban_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_)}},
    // optional bool ban_certificate = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserRemove, _impl_.ban_certificate_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_certificate_)}},
    // optional bool ban_ip = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserRemove, _impl_.ban_ip_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_ip_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 actor = 2;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.actor_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string reason = 3;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bool ban = 4;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ban_certificate = 5;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_certificate_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ban_ip = 6;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_ip_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\23\0\0\6\0\0\0\0"
    "NoxProto.UserRemove"
    "reason"
  }},
};
PROTOBUF_NOINLINE void UserRemove::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserRemove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.reason_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000003eu) != 0) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ban_ip_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.ban_ip_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserRemove::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserRemove& this_ = static_cast<const UserRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserRemove::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserRemove)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 session = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 actor = 2;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_actor(), target);
  }

  // optional string reason = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_reason();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserRemove.reason");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bool ban = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_ban(), target);
  }

  // optional bool ban_certificate = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_ban_certificate(), target);
  }

  // optional bool ban_ip = 6;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_ban_ip(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserRemove)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserRemove::ByteSizeLong(const MessageLite& base) {
  const UserRemove& this_ = static_cast<const UserRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserRemove::ByteSizeLong() const {
  const UserRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserRemove)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000038u & cached_has_bits) * 2;
   {
    // optional string reason = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
  }
   {
    // required uint32 session = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
  }
   {
    // optional uint32 actor = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserRemove::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserRemove*>(&to_msg);
  auto& from = static_cast<const UserRemove&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserRemove)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.ban_ = from._impl_.ban_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.ban_certificate_ = from._impl_.ban_certificate_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ban_ip_ = from._impl_.ban_ip_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserRemove::CopyFrom(const UserRemove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserRemove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserRemove::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserRemove&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UserRemove::InternalSwap(UserRemove* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_ip_)
      + sizeof(UserRemove::_impl_.ban_ip_)
      - PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata UserRemove::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserState_VolumeAdjustment::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserState_VolumeAdjustment>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_._has_bits_);
};

UserState_VolumeAdjustment::UserState_VolumeAdjustment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_VolumeAdjustment_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserState.VolumeAdjustment)
}
UserState_VolumeAdjustment::UserState_VolumeAdjustment(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserState_VolumeAdjustment& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_VolumeAdjustment_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE UserState_VolumeAdjustment::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void UserState_VolumeAdjustment::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, listening_channel_),
           0,
           offsetof(Impl_, volume_adjustment_) -
               offsetof(Impl_, listening_channel_) +
               sizeof(Impl_::volume_adjustment_));
}
UserState_VolumeAdjustment::~UserState_VolumeAdjustment() {
  // @@protoc_insertion_point(destructor:NoxProto.UserState.VolumeAdjustment)
  SharedDtor(*this);
}
inline void UserState_VolumeAdjustment::SharedDtor(MessageLite& self) {
  UserState_VolumeAdjustment& this_ = static_cast<UserState_VolumeAdjustment&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserState_VolumeAdjustment::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserState_VolumeAdjustment(arena);
}
constexpr auto UserState_VolumeAdjustment::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UserState_VolumeAdjustment),
                                            alignof(UserState_VolumeAdjustment));
}
constexpr auto UserState_VolumeAdjustment::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserState_VolumeAdjustment_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserState_VolumeAdjustment::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserState_VolumeAdjustment>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserState_VolumeAdjustment::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserState_VolumeAdjustment>(), &UserState_VolumeAdjustment::ByteSizeLong,
              &UserState_VolumeAdjustment::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_._cached_size_),
          false,
      },
      &UserState_VolumeAdjustment::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserState_VolumeAdjustment_class_data_ =
        UserState_VolumeAdjustment::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserState_VolumeAdjustment::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserState_VolumeAdjustment_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserState_VolumeAdjustment_class_data_.tc_table);
  return UserState_VolumeAdjustment_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
UserState_VolumeAdjustment::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserState_VolumeAdjustment_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserState_VolumeAdjustment>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional float volume_adjustment = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.volume_adjustment_)}},
    // optional uint32 listening_channel = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState_VolumeAdjustment, _impl_.listening_channel_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.listening_channel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 listening_channel = 1;
    {PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.listening_channel_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float volume_adjustment = 2;
    {PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.volume_adjustment_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserState_VolumeAdjustment::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserState.VolumeAdjustment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    ::memset(&_impl_.listening_channel_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.volume_adjustment_) -
        reinterpret_cast<char*>(&_impl_.listening_channel_)) + sizeof(_impl_.volume_adjustment_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserState_VolumeAdjustment::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserState_VolumeAdjustment& this_ = static_cast<const UserState_VolumeAdjustment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserState_VolumeAdjustment::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserState_VolumeAdjustment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserState.VolumeAdjustment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 listening_channel = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_listening_channel(), target);
  }

  // optional float volume_adjustment = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this_._internal_volume_adjustment(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserState.VolumeAdjustment)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserState_VolumeAdjustment::ByteSizeLong(const MessageLite& base) {
  const UserState_VolumeAdjustment& this_ = static_cast<const UserState_VolumeAdjustment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserState_VolumeAdjustment::ByteSizeLong() const {
  const UserState_VolumeAdjustment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserState.VolumeAdjustment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000002u & cached_has_bits) * 5;
   {
    // optional uint32 listening_channel = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_listening_channel());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserState_VolumeAdjustment::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserState_VolumeAdjustment*>(&to_msg);
  auto& from = static_cast<const UserState_VolumeAdjustment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserState.VolumeAdjustment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.listening_channel_ = from._impl_.listening_channel_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.volume_adjustment_ = from._impl_.volume_adjustment_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserState_VolumeAdjustment::CopyFrom(const UserState_VolumeAdjustment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserState.VolumeAdjustment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserState_VolumeAdjustment::InternalSwap(UserState_VolumeAdjustment* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.volume_adjustment_)
      + sizeof(UserState_VolumeAdjustment::_impl_.volume_adjustment_)
      - PROTOBUF_FIELD_OFFSET(UserState_VolumeAdjustment, _impl_.listening_channel_)>(
          reinterpret_cast<char*>(&_impl_.listening_channel_),
          reinterpret_cast<char*>(&other->_impl_.listening_channel_));
}

::google::protobuf::Metadata UserState_VolumeAdjustment::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserState, _impl_._has_bits_);
};

UserState::UserState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserState)
}
PROTOBUF_NDEBUG_INLINE UserState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        temporary_access_tokens_{visibility, arena, from.temporary_access_tokens_},
        listening_channel_add_{visibility, arena, from.listening_channel_add_},
        listening_channel_remove_{visibility, arena, from.listening_channel_remove_},
        listening_volume_adjustment_{visibility, arena, from.listening_volume_adjustment_},
        name_(arena, from.name_),
        texture_(arena, from.texture_),
        plugin_context_(arena, from.plugin_context_),
        plugin_identity_(arena, from.plugin_identity_),
        comment_(arena, from.comment_),
        hash_(arena, from.hash_),
        comment_hash_(arena, from.comment_hash_),
        texture_hash_(arena, from.texture_hash_) {}

UserState::UserState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, recording_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::recording_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserState)
}
PROTOBUF_NDEBUG_INLINE UserState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        temporary_access_tokens_{visibility, arena},
        listening_channel_add_{visibility, arena},
        listening_channel_remove_{visibility, arena},
        listening_volume_adjustment_{visibility, arena},
        name_(arena),
        texture_(arena),
        plugin_context_(arena),
        plugin_identity_(arena),
        comment_(arena),
        hash_(arena),
        comment_hash_(arena),
        texture_hash_(arena) {}

inline void UserState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, recording_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::recording_));
}
UserState::~UserState() {
  // @@protoc_insertion_point(destructor:NoxProto.UserState)
  SharedDtor(*this);
}
inline void UserState::SharedDtor(MessageLite& self) {
  UserState& this_ = static_cast<UserState&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.texture_.Destroy();
  this_._impl_.plugin_context_.Destroy();
  this_._impl_.plugin_identity_.Destroy();
  this_._impl_.comment_.Destroy();
  this_._impl_.hash_.Destroy();
  this_._impl_.comment_hash_.Destroy();
  this_._impl_.texture_hash_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserState(arena);
}
constexpr auto UserState::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.temporary_access_tokens_) +
          decltype(UserState::_impl_.temporary_access_tokens_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_add_) +
          decltype(UserState::_impl_.listening_channel_add_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_remove_) +
          decltype(UserState::_impl_.listening_channel_remove_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_volume_adjustment_) +
          decltype(UserState::_impl_.listening_volume_adjustment_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(UserState), alignof(UserState), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UserState::PlacementNew_,
                                 sizeof(UserState),
                                 alignof(UserState));
  }
}
constexpr auto UserState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserState>(), &UserState::ByteSizeLong,
              &UserState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserState, _impl_._cached_size_),
          false,
      },
      &UserState::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserState_class_data_ =
        UserState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserState_class_data_.tc_table);
  return UserState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 23, 1, 96, 2>
UserState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserState, _impl_._has_bits_),
    0, // no _extensions_
    23, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4286578688,  // skipmap
    offsetof(decltype(_table_), field_entries),
    23,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.session_), 8>(),
     {8, 8, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_)}},
    // optional uint32 actor = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.actor_), 9>(),
     {16, 9, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.actor_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.name_)}},
    // optional uint32 user_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.user_id_), 10>(),
     {32, 10, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.user_id_)}},
    // optional uint32 channel_id = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.channel_id_), 11>(),
     {40, 11, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.channel_id_)}},
    // optional bool mute = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.mute_), 12>(),
     {48, 12, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.mute_)}},
    // optional bool deaf = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.deaf_), 13>(),
     {56, 13, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.deaf_)}},
    // optional bool suppress = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.suppress_), 14>(),
     {64, 14, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.suppress_)}},
    // optional bool self_mute = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.self_mute_), 15>(),
     {72, 15, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_mute_)}},
    // optional bool self_deaf = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.self_deaf_), 16>(),
     {80, 16, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_deaf_)}},
    // optional bytes texture = 11;
    {::_pbi::TcParser::FastBS1,
     {90, 1, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_)}},
    // optional bytes plugin_context = 12;
    {::_pbi::TcParser::FastBS1,
     {98, 2, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_context_)}},
    // optional string plugin_identity = 13;
    {::_pbi::TcParser::FastSS1,
     {106, 3, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_identity_)}},
    // optional string comment = 14;
    {::_pbi::TcParser::FastSS1,
     {114, 4, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_)}},
    // optional string hash = 15;
    {::_pbi::TcParser::FastSS1,
     {122, 5, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.hash_)}},
    // optional bytes comment_hash = 16;
    {::_pbi::TcParser::FastBS2,
     {386, 6, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_hash_)}},
    // optional bytes texture_hash = 17;
    {::_pbi::TcParser::FastBS2,
     {394, 7, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_hash_)}},
    // optional bool priority_speaker = 18;
    {::_pbi::TcParser::FastV8S2,
     {400, 17, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.priority_speaker_)}},
    // optional bool recording = 19;
    {::_pbi::TcParser::FastV8S2,
     {408, 18, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_)}},
    // repeated string temporary_access_tokens = 20;
    {::_pbi::TcParser::FastSR2,
     {418, 63, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.temporary_access_tokens_)}},
    // repeated uint32 listening_channel_add = 21;
    {::_pbi::TcParser::FastV32R2,
     {424, 63, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_add_)}},
    // repeated uint32 listening_channel_remove = 22;
    {::_pbi::TcParser::FastV32R2,
     {432, 63, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_remove_)}},
    // repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
    {::_pbi::TcParser::FastMtR2,
     {442, 63, 0, PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_volume_adjustment_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 actor = 2;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.actor_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 user_id = 4;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.user_id_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 5;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.channel_id_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool mute = 6;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.mute_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool deaf = 7;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.deaf_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool suppress = 8;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.suppress_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool self_mute = 9;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_mute_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool self_deaf = 10;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_deaf_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bytes texture = 11;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes plugin_context = 12;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_context_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string plugin_identity = 13;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_identity_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string comment = 14;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string hash = 15;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.hash_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bytes comment_hash = 16;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_hash_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes texture_hash = 17;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_hash_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool priority_speaker = 18;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.priority_speaker_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool recording = 19;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated string temporary_access_tokens = 20;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.temporary_access_tokens_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated uint32 listening_channel_add = 21;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_add_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 listening_channel_remove = 22;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_channel_remove_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.listening_volume_adjustment_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::UserState_VolumeAdjustment>()},
  }},
  {{
    "\22\0\0\4\0\0\0\0\0\0\0\0\0\17\7\4\0\0\0\0\27\0\0\0"
    "NoxProto.UserState"
    "name"
    "plugin_identity"
    "comment"
    "hash"
    "temporary_access_tokens"
  }},
};
PROTOBUF_NOINLINE void UserState::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.temporary_access_tokens_.Clear();
  _impl_.listening_channel_add_.Clear();
  _impl_.listening_channel_remove_.Clear();
  _impl_.listening_volume_adjustment_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.texture_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.plugin_context_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.plugin_identity_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.comment_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _impl_.comment_hash_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _impl_.texture_hash_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.self_mute_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.self_mute_));
  }
  if ((cached_has_bits & 0x00070000u) != 0) {
    ::memset(&_impl_.self_deaf_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.recording_) -
        reinterpret_cast<char*>(&_impl_.self_deaf_)) + sizeof(_impl_.recording_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserState& this_ = static_cast<const UserState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 actor = 2;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_actor(), target);
  }

  // optional string name = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserState.name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint32 user_id = 4;
  if ((cached_has_bits & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_user_id(), target);
  }

  // optional uint32 channel_id = 5;
  if ((cached_has_bits & 0x00000800u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_channel_id(), target);
  }

  // optional bool mute = 6;
  if ((cached_has_bits & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_mute(), target);
  }

  // optional bool deaf = 7;
  if ((cached_has_bits & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_deaf(), target);
  }

  // optional bool suppress = 8;
  if ((cached_has_bits & 0x00004000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_suppress(), target);
  }

  // optional bool self_mute = 9;
  if ((cached_has_bits & 0x00008000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this_._internal_self_mute(), target);
  }

  // optional bool self_deaf = 10;
  if ((cached_has_bits & 0x00010000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this_._internal_self_deaf(), target);
  }

  // optional bytes texture = 11;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_texture();
    target = stream->WriteBytesMaybeAliased(11, _s, target);
  }

  // optional bytes plugin_context = 12;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_plugin_context();
    target = stream->WriteBytesMaybeAliased(12, _s, target);
  }

  // optional string plugin_identity = 13;
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_plugin_identity();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserState.plugin_identity");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional string comment = 14;
  if ((cached_has_bits & 0x00000010u) != 0) {
    const ::std::string& _s = this_._internal_comment();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserState.comment");
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional string hash = 15;
  if ((cached_has_bits & 0x00000020u) != 0) {
    const ::std::string& _s = this_._internal_hash();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserState.hash");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // optional bytes comment_hash = 16;
  if ((cached_has_bits & 0x00000040u) != 0) {
    const ::std::string& _s = this_._internal_comment_hash();
    target = stream->WriteBytesMaybeAliased(16, _s, target);
  }

  // optional bytes texture_hash = 17;
  if ((cached_has_bits & 0x00000080u) != 0) {
    const ::std::string& _s = this_._internal_texture_hash();
    target = stream->WriteBytesMaybeAliased(17, _s, target);
  }

  // optional bool priority_speaker = 18;
  if ((cached_has_bits & 0x00020000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this_._internal_priority_speaker(), target);
  }

  // optional bool recording = 19;
  if ((cached_has_bits & 0x00040000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this_._internal_recording(), target);
  }

  // repeated string temporary_access_tokens = 20;
  for (int i = 0, n = this_._internal_temporary_access_tokens_size(); i < n; ++i) {
    const auto& s = this_._internal_temporary_access_tokens().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserState.temporary_access_tokens");
    target = stream->WriteString(20, s, target);
  }

  // repeated uint32 listening_channel_add = 21;
  for (int i = 0, n = this_._internal_listening_channel_add_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        21, this_._internal_listening_channel_add().Get(i), target);
  }

  // repeated uint32 listening_channel_remove = 22;
  for (int i = 0, n = this_._internal_listening_channel_remove_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        22, this_._internal_listening_channel_remove().Get(i), target);
  }

  // repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_listening_volume_adjustment_size());
       i < n; i++) {
    const auto& repfield = this_._internal_listening_volume_adjustment().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            23, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserState::ByteSizeLong(const MessageLite& base) {
  const UserState& this_ = static_cast<const UserState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserState::ByteSizeLong() const {
  const UserState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string temporary_access_tokens = 20;
    {
      total_size +=
          2 * ::google::protobuf::internal::FromIntSize(this_._internal_temporary_access_tokens().size());
      for (int i = 0, n = this_._internal_temporary_access_tokens().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_temporary_access_tokens().Get(i));
      }
    }
    // repeated uint32 listening_channel_add = 21;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_listening_channel_add());
      ::size_t tag_size = ::size_t{2} *
          ::_pbi::FromIntSize(this_._internal_listening_channel_add_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 listening_channel_remove = 22;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_listening_channel_remove());
      ::size_t tag_size = ::size_t{2} *
          ::_pbi::FromIntSize(this_._internal_listening_channel_remove_size());
      total_size += tag_size + data_size;
    }
    // repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
    {
      total_size += 2UL * this_._internal_listening_volume_adjustment_size();
      for (const auto& msg : this_._internal_listening_volume_adjustment()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00060000u & cached_has_bits) * 3;
  total_size += ::absl::popcount(0x0001f000u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional string name = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional bytes texture = 11;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_texture());
    }
    // optional bytes plugin_context = 12;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_plugin_context());
    }
    // optional string plugin_identity = 13;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_plugin_identity());
    }
    // optional string comment = 14;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_comment());
    }
    // optional string hash = 15;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hash());
    }
    // optional bytes comment_hash = 16;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_comment_hash());
    }
    // optional bytes texture_hash = 17;
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_texture_hash());
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    // optional uint32 session = 1;
    if ((cached_has_bits & 0x00000100u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 actor = 2;
    if ((cached_has_bits & 0x00000200u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
    // optional uint32 user_id = 4;
    if ((cached_has_bits & 0x00000400u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
    // optional uint32 channel_id = 5;
    if ((cached_has_bits & 0x00000800u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserState::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserState*>(&to_msg);
  auto& from = static_cast<const UserState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_temporary_access_tokens()->MergeFrom(from._internal_temporary_access_tokens());
  _this->_internal_mutable_listening_channel_add()->MergeFrom(from._internal_listening_channel_add());
  _this->_internal_mutable_listening_channel_remove()->MergeFrom(from._internal_listening_channel_remove());
  _this->_internal_mutable_listening_volume_adjustment()->MergeFrom(
      from._internal_listening_volume_adjustment());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_texture(from._internal_texture());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_plugin_context(from._internal_plugin_context());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_plugin_identity(from._internal_plugin_identity());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_internal_set_comment_hash(from._internal_comment_hash());
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_internal_set_texture_hash(from._internal_texture_hash());
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _this->_impl_.mute_ = from._impl_.mute_;
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      _this->_impl_.deaf_ = from._impl_.deaf_;
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      _this->_impl_.suppress_ = from._impl_.suppress_;
    }
    if ((cached_has_bits & 0x00008000u) != 0) {
      _this->_impl_.self_mute_ = from._impl_.self_mute_;
    }
  }
  if ((cached_has_bits & 0x00070000u) != 0) {
    if ((cached_has_bits & 0x00010000u) != 0) {
      _this->_impl_.self_deaf_ = from._impl_.self_deaf_;
    }
    if ((cached_has_bits & 0x00020000u) != 0) {
      _this->_impl_.priority_speaker_ = from._impl_.priority_speaker_;
    }
    if ((cached_has_bits & 0x00040000u) != 0) {
      _this->_impl_.recording_ = from._impl_.recording_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserState::CopyFrom(const UserState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserState::InternalSwap(UserState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.temporary_access_tokens_.InternalSwap(&other->_impl_.temporary_access_tokens_);
  _impl_.listening_channel_add_.InternalSwap(&other->_impl_.listening_channel_add_);
  _impl_.listening_channel_remove_.InternalSwap(&other->_impl_.listening_channel_remove_);
  _impl_.listening_volume_adjustment_.InternalSwap(&other->_impl_.listening_volume_adjustment_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.texture_, &other->_impl_.texture_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.plugin_context_, &other->_impl_.plugin_context_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.plugin_identity_, &other->_impl_.plugin_identity_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comment_, &other->_impl_.comment_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_, &other->_impl_.hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comment_hash_, &other->_impl_.comment_hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.texture_hash_, &other->_impl_.texture_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_)
      + sizeof(UserState::_impl_.recording_)
      - PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata UserState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BanList_BanEntry::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BanList_BanEntry>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000021) ^ 0x00000021) != 0;
  }
};

BanList_BanEntry::BanList_BanEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_BanEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.BanList.BanEntry)
}
PROTOBUF_NDEBUG_INLINE BanList_BanEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::BanList_BanEntry& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        address_(arena, from.address_),
        name_(arena, from.name_),
        hash_(arena, from.hash_),
        reason_(arena, from.reason_),
        start_(arena, from.start_) {}

BanList_BanEntry::BanList_BanEntry(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BanList_BanEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_BanEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BanList_BanEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mask_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, mask_),
           offsetof(Impl_, duration_) -
               offsetof(Impl_, mask_) +
               sizeof(Impl_::duration_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.BanList.BanEntry)
}
PROTOBUF_NDEBUG_INLINE BanList_BanEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        address_(arena),
        name_(arena),
        hash_(arena),
        reason_(arena),
        start_(arena) {}

inline void BanList_BanEntry::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mask_),
           0,
           offsetof(Impl_, duration_) -
               offsetof(Impl_, mask_) +
               sizeof(Impl_::duration_));
}
BanList_BanEntry::~BanList_BanEntry() {
  // @@protoc_insertion_point(destructor:NoxProto.BanList.BanEntry)
  SharedDtor(*this);
}
inline void BanList_BanEntry::SharedDtor(MessageLite& self) {
  BanList_BanEntry& this_ = static_cast<BanList_BanEntry&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.address_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.hash_.Destroy();
  this_._impl_.reason_.Destroy();
  this_._impl_.start_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BanList_BanEntry::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BanList_BanEntry(arena);
}
constexpr auto BanList_BanEntry::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BanList_BanEntry),
                                            alignof(BanList_BanEntry));
}
constexpr auto BanList_BanEntry::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BanList_BanEntry_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          BanList_BanEntry::IsInitializedImpl,
          &BanList_BanEntry::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BanList_BanEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BanList_BanEntry::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BanList_BanEntry>(), &BanList_BanEntry::ByteSizeLong,
              &BanList_BanEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._cached_size_),
          false,
      },
      &BanList_BanEntry::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BanList_BanEntry_class_data_ =
        BanList_BanEntry::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BanList_BanEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BanList_BanEntry_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BanList_BanEntry_class_data_.tc_table);
  return BanList_BanEntry_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 53, 2>
BanList_BanEntry::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BanList_BanEntry_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::BanList_BanEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required bytes address = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.address_)}},
    // required uint32 mask = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BanList_BanEntry, _impl_.mask_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.name_)}},
    // optional string hash = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 2, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.hash_)}},
    // optional string reason = 5;
    {::_pbi::TcParser::FastSS1,
     {42, 3, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.reason_)}},
    // optional string start = 6;
    {::_pbi::TcParser::FastSS1,
     {50, 4, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.start_)}},
    // optional uint32 duration = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BanList_BanEntry, _impl_.duration_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required bytes address = 1;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.address_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint32 mask = 2;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string hash = 4;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.hash_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string reason = 5;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.reason_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string start = 6;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.start_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 duration = 7;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\31\0\0\4\4\6\5\0"
    "NoxProto.BanList.BanEntry"
    "name"
    "hash"
    "reason"
    "start"
  }},
};
PROTOBUF_NOINLINE void BanList_BanEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.BanList.BanEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.start_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x00000060u) != 0) {
    ::memset(&_impl_.mask_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.duration_) -
        reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.duration_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BanList_BanEntry::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BanList_BanEntry& this_ = static_cast<const BanList_BanEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BanList_BanEntry::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BanList_BanEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.BanList.BanEntry)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required bytes address = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_address();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // required uint32 mask = 2;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_mask(), target);
  }

  // optional string name = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.BanList.BanEntry.name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string hash = 4;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_hash();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.BanList.BanEntry.hash");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string reason = 5;
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_reason();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.BanList.BanEntry.reason");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string start = 6;
  if ((cached_has_bits & 0x00000010u) != 0) {
    const ::std::string& _s = this_._internal_start();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.BanList.BanEntry.start");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional uint32 duration = 7;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_duration(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.BanList.BanEntry)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BanList_BanEntry::ByteSizeLong(const MessageLite& base) {
  const BanList_BanEntry& this_ = static_cast<const BanList_BanEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BanList_BanEntry::ByteSizeLong() const {
  const BanList_BanEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.BanList.BanEntry)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required bytes address = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_address());
    }
  }
  if ((cached_has_bits & 0x0000001eu) != 0) {
    // optional string name = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string hash = 4;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hash());
    }
    // optional string reason = 5;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional string start = 6;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_start());
    }
  }
   {
    // required uint32 mask = 2;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_mask());
    }
  }
   {
    // optional uint32 duration = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_duration());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BanList_BanEntry::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BanList_BanEntry*>(&to_msg);
  auto& from = static_cast<const BanList_BanEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.BanList.BanEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_address(from._internal_address());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_internal_set_start(from._internal_start());
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BanList_BanEntry::CopyFrom(const BanList_BanEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.BanList.BanEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BanList_BanEntry::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BanList_BanEntry&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void BanList_BanEntry::InternalSwap(BanList_BanEntry* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, &other->_impl_.address_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_, &other->_impl_.hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_, &other->_impl_.start_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_)
      + sizeof(BanList_BanEntry::_impl_.duration_)
      - PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_)>(
          reinterpret_cast<char*>(&_impl_.mask_),
          reinterpret_cast<char*>(&other->_impl_.mask_));
}

::google::protobuf::Metadata BanList_BanEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BanList::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BanList>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BanList, _impl_._has_bits_);
};

BanList::BanList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.BanList)
}
PROTOBUF_NDEBUG_INLINE BanList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::BanList& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        bans_{visibility, arena, from.bans_} {}

BanList::BanList(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BanList& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BanList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.query_ = from._impl_.query_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.BanList)
}
PROTOBUF_NDEBUG_INLINE BanList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        bans_{visibility, arena} {}

inline void BanList::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.query_ = {};
}
BanList::~BanList() {
  // @@protoc_insertion_point(destructor:NoxProto.BanList)
  SharedDtor(*this);
}
inline void BanList::SharedDtor(MessageLite& self) {
  BanList& this_ = static_cast<BanList&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BanList::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BanList(arena);
}
constexpr auto BanList::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_) +
          decltype(BanList::_impl_.bans_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BanList), alignof(BanList), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BanList::PlacementNew_,
                                 sizeof(BanList),
                                 alignof(BanList));
  }
}
constexpr auto BanList::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BanList_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          BanList::IsInitializedImpl,
          &BanList::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BanList>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BanList::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BanList>(), &BanList::ByteSizeLong,
              &BanList::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BanList, _impl_._cached_size_),
          false,
      },
      &BanList::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BanList_class_data_ =
        BanList::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BanList::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BanList_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BanList_class_data_.tc_table);
  return BanList_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
BanList::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BanList, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BanList_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::BanList>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool query = 2 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BanList, _impl_.query_), 0>(),
     {16, 0, 0, PROTOBUF_FIELD_OFFSET(BanList, _impl_.query_)}},
    // repeated .NoxProto.BanList.BanEntry bans = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .NoxProto.BanList.BanEntry bans = 1;
    {PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool query = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(BanList, _impl_.query_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::BanList_BanEntry>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BanList::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.BanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bans_.Clear();
  _impl_.query_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BanList::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BanList& this_ = static_cast<const BanList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BanList::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BanList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.BanList)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .NoxProto.BanList.BanEntry bans = 1;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_bans_size());
       i < n; i++) {
    const auto& repfield = this_._internal_bans().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool query = 2 [default = false];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_query(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.BanList)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BanList::ByteSizeLong(const MessageLite& base) {
  const BanList& this_ = static_cast<const BanList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BanList::ByteSizeLong() const {
  const BanList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.BanList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .NoxProto.BanList.BanEntry bans = 1;
    {
      total_size += 1UL * this_._internal_bans_size();
      for (const auto& msg : this_._internal_bans()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000001u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BanList::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BanList*>(&to_msg);
  auto& from = static_cast<const BanList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.BanList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_bans()->MergeFrom(
      from._internal_bans());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_impl_.query_ = from._impl_.query_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BanList::CopyFrom(const BanList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.BanList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BanList::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BanList&>(msg);
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_bans()))
    return false;
  return true;
}

void BanList::InternalSwap(BanList* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bans_.InternalSwap(&other->_impl_.bans_);
  swap(_impl_.query_, other->_impl_.query_);
}

::google::protobuf::Metadata BanList::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TextMessage::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TextMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TextMessage::TextMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TextMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.TextMessage)
}
PROTOBUF_NDEBUG_INLINE TextMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::TextMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        session_{visibility, arena, from.session_},
        channel_id_{visibility, arena, from.channel_id_},
        tree_id_{visibility, arena, from.tree_id_},
        message_(arena, from.message_) {}

TextMessage::TextMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TextMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TextMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TextMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.actor_ = from._impl_.actor_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.TextMessage)
}
PROTOBUF_NDEBUG_INLINE TextMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        session_{visibility, arena},
        channel_id_{visibility, arena},
        tree_id_{visibility, arena},
        message_(arena) {}

inline void TextMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.actor_ = {};
}
TextMessage::~TextMessage() {
  // @@protoc_insertion_point(destructor:NoxProto.TextMessage)
  SharedDtor(*this);
}
inline void TextMessage::SharedDtor(MessageLite& self) {
  TextMessage& this_ = static_cast<TextMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TextMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TextMessage(arena);
}
constexpr auto TextMessage::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_) +
          decltype(TextMessage::_impl_.session_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_) +
          decltype(TextMessage::_impl_.channel_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_) +
          decltype(TextMessage::_impl_.tree_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(TextMessage), alignof(TextMessage), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TextMessage::PlacementNew_,
                                 sizeof(TextMessage),
                                 alignof(TextMessage));
  }
}
constexpr auto TextMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TextMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          TextMessage::IsInitializedImpl,
          &TextMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TextMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TextMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TextMessage>(), &TextMessage::ByteSizeLong,
              &TextMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._cached_size_),
          false,
      },
      &TextMessage::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TextMessage_class_data_ =
        TextMessage::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TextMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TextMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TextMessage_class_data_.tc_table);
  return TextMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 36, 2>
TextMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TextMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::TextMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 actor = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TextMessage, _impl_.actor_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.actor_)}},
    // repeated uint32 session = 2;
    {::_pbi::TcParser::FastV32R1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_)}},
    // repeated uint32 channel_id = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_)}},
    // repeated uint32 tree_id = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_)}},
    // required string message = 5;
    {::_pbi::TcParser::FastSS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 actor = 1;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.actor_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated uint32 session = 2;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 channel_id = 3;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 tree_id = 4;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // required string message = 5;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\24\0\0\0\0\7\0\0"
    "NoxProto.TextMessage"
    "message"
  }},
};
PROTOBUF_NOINLINE void TextMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.TextMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.session_.Clear();
  _impl_.channel_id_.Clear();
  _impl_.tree_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_.actor_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TextMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TextMessage& this_ = static_cast<const TextMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TextMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TextMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.TextMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 actor = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_actor(), target);
  }

  // repeated uint32 session = 2;
  for (int i = 0, n = this_._internal_session_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_session().Get(i), target);
  }

  // repeated uint32 channel_id = 3;
  for (int i = 0, n = this_._internal_channel_id_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_channel_id().Get(i), target);
  }

  // repeated uint32 tree_id = 4;
  for (int i = 0, n = this_._internal_tree_id_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_tree_id().Get(i), target);
  }

  // required string message = 5;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_message();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.TextMessage.message");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.TextMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TextMessage::ByteSizeLong(const MessageLite& base) {
  const TextMessage& this_ = static_cast<const TextMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TextMessage::ByteSizeLong() const {
  const TextMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.TextMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 session = 2;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 channel_id = 3;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_channel_id());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_channel_id_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 tree_id = 4;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_tree_id());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_tree_id_size());
      total_size += tag_size + data_size;
    }
  }
   {
    // required string message = 5;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_message());
    }
  }
   {
    // optional uint32 actor = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TextMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TextMessage*>(&to_msg);
  auto& from = static_cast<const TextMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.TextMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_session()->MergeFrom(from._internal_session());
  _this->_internal_mutable_channel_id()->MergeFrom(from._internal_channel_id());
  _this->_internal_mutable_tree_id()->MergeFrom(from._internal_tree_id());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_message(from._internal_message());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TextMessage::CopyFrom(const TextMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.TextMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TextMessage::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const TextMessage&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void TextMessage::InternalSwap(TextMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_.InternalSwap(&other->_impl_.session_);
  _impl_.channel_id_.InternalSwap(&other->_impl_.channel_id_);
  _impl_.tree_id_.InternalSwap(&other->_impl_.tree_id_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  swap(_impl_.actor_, other->_impl_.actor_);
}

::google::protobuf::Metadata TextMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PermissionDenied::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PermissionDenied>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._has_bits_);
};

PermissionDenied::PermissionDenied(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionDenied_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.PermissionDenied)
}
PROTOBUF_NDEBUG_INLINE PermissionDenied::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::PermissionDenied& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_),
        name_(arena, from.name_) {}

PermissionDenied::PermissionDenied(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PermissionDenied& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionDenied_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PermissionDenied* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, permission_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, permission_),
           offsetof(Impl_, type_) -
               offsetof(Impl_, permission_) +
               sizeof(Impl_::type_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.PermissionDenied)
}
PROTOBUF_NDEBUG_INLINE PermissionDenied::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena),
        name_(arena) {}

inline void PermissionDenied::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, permission_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, permission_) +
               sizeof(Impl_::type_));
}
PermissionDenied::~PermissionDenied() {
  // @@protoc_insertion_point(destructor:NoxProto.PermissionDenied)
  SharedDtor(*this);
}
inline void PermissionDenied::SharedDtor(MessageLite& self) {
  PermissionDenied& this_ = static_cast<PermissionDenied&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PermissionDenied::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PermissionDenied(arena);
}
constexpr auto PermissionDenied::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PermissionDenied),
                                            alignof(PermissionDenied));
}
constexpr auto PermissionDenied::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PermissionDenied_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PermissionDenied::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PermissionDenied>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PermissionDenied::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PermissionDenied>(), &PermissionDenied::ByteSizeLong,
              &PermissionDenied::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._cached_size_),
          false,
      },
      &PermissionDenied::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PermissionDenied_class_data_ =
        PermissionDenied::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PermissionDenied::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PermissionDenied_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PermissionDenied_class_data_.tc_table);
  return PermissionDenied_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 44, 2>
PermissionDenied::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PermissionDenied_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::PermissionDenied>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 permission = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.permission_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.channel_id_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.channel_id_)}},
    // optional uint32 session = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.session_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.session_)}},
    // optional string reason = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.reason_)}},
    // optional .NoxProto.PermissionDenied.DenyType type = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 5, 13, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_)}},
    // optional string name = 6;
    {::_pbi::TcParser::FastSS1,
     {50, 1, 0, PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.name_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 permission = 1;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.channel_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 session = 3;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.session_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string reason = 4;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional .NoxProto.PermissionDenied.DenyType type = 5;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string name = 6;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  {{
      {0, 13},
  }},
  {{
    "\31\0\0\0\6\0\4\0"
    "NoxProto.PermissionDenied"
    "reason"
    "name"
  }},
};
PROTOBUF_NOINLINE void PermissionDenied::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.PermissionDenied)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000003cu) != 0) {
    ::memset(&_impl_.permission_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.permission_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PermissionDenied::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PermissionDenied& this_ = static_cast<const PermissionDenied&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PermissionDenied::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PermissionDenied& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.PermissionDenied)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 permission = 1;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_permission(), target);
  }

  // optional uint32 channel_id = 2;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // optional uint32 session = 3;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_session(), target);
  }

  // optional string reason = 4;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_reason();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.PermissionDenied.reason");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional .NoxProto.PermissionDenied.DenyType type = 5;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this_._internal_type(), target);
  }

  // optional string name = 6;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.PermissionDenied.name");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.PermissionDenied)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PermissionDenied::ByteSizeLong(const MessageLite& base) {
  const PermissionDenied& this_ = static_cast<const PermissionDenied&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PermissionDenied::ByteSizeLong() const {
  const PermissionDenied& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.PermissionDenied)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    // optional string reason = 4;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional string name = 6;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional uint32 permission = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_permission());
    }
    // optional uint32 channel_id = 2;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 session = 3;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional .NoxProto.PermissionDenied.DenyType type = 5;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PermissionDenied::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PermissionDenied*>(&to_msg);
  auto& from = static_cast<const PermissionDenied&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.PermissionDenied)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.permission_ = from._impl_.permission_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.type_ = from._impl_.type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PermissionDenied::CopyFrom(const PermissionDenied& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.PermissionDenied)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PermissionDenied::InternalSwap(PermissionDenied* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_)
      + sizeof(PermissionDenied::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_)>(
          reinterpret_cast<char*>(&_impl_.permission_),
          reinterpret_cast<char*>(&other->_impl_.permission_));
}

::google::protobuf::Metadata PermissionDenied::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL_ChanGroup::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL_ChanGroup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ACL_ChanGroup::ACL_ChanGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanGroup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ACL.ChanGroup)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanGroup::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ACL_ChanGroup& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        add_{visibility, arena, from.add_},
        remove_{visibility, arena, from.remove_},
        inherited_members_{visibility, arena, from.inherited_members_},
        name_(arena, from.name_) {}

ACL_ChanGroup::ACL_ChanGroup(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL_ChanGroup& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanGroup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL_ChanGroup* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, inherited_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, inherited_),
           offsetof(Impl_, inheritable_) -
               offsetof(Impl_, inherited_) +
               sizeof(Impl_::inheritable_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ACL.ChanGroup)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanGroup::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        add_{visibility, arena},
        remove_{visibility, arena},
        inherited_members_{visibility, arena},
        name_(arena),
        inherited_{true},
        inherit_{true},
        inheritable_{true} {}

inline void ACL_ChanGroup::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ACL_ChanGroup::~ACL_ChanGroup() {
  // @@protoc_insertion_point(destructor:NoxProto.ACL.ChanGroup)
  SharedDtor(*this);
}
inline void ACL_ChanGroup::SharedDtor(MessageLite& self) {
  ACL_ChanGroup& this_ = static_cast<ACL_ChanGroup&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL_ChanGroup::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL_ChanGroup(arena);
}
constexpr auto ACL_ChanGroup::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_) +
          decltype(ACL_ChanGroup::_impl_.add_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_) +
          decltype(ACL_ChanGroup::_impl_.remove_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_) +
          decltype(ACL_ChanGroup::_impl_.inherited_members_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ACL_ChanGroup), alignof(ACL_ChanGroup), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ACL_ChanGroup::PlacementNew_,
                                 sizeof(ACL_ChanGroup),
                                 alignof(ACL_ChanGroup));
  }
}
constexpr auto ACL_ChanGroup::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_ChanGroup_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ACL_ChanGroup::IsInitializedImpl,
          &ACL_ChanGroup::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL_ChanGroup>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL_ChanGroup::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL_ChanGroup>(), &ACL_ChanGroup::ByteSizeLong,
              &ACL_ChanGroup::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._cached_size_),
          false,
      },
      &ACL_ChanGroup::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_ChanGroup_class_data_ =
        ACL_ChanGroup::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL_ChanGroup::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_ChanGroup_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_ChanGroup_class_data_.tc_table);
  return ACL_ChanGroup_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 35, 2>
ACL_ChanGroup::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ACL_ChanGroup_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ACL_ChanGroup>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string name = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.name_)}},
    // optional bool inherited = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inherited_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_)}},
    // optional bool inherit = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inherit_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherit_)}},
    // optional bool inheritable = 4 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inheritable_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_)}},
    // repeated uint32 add = 5;
    {::_pbi::TcParser::FastV32R1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_)}},
    // repeated uint32 remove = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_)}},
    // repeated uint32 inherited_members = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string name = 1;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bool inherited = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inherit = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherit_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inheritable = 4 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated uint32 add = 5;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 remove = 6;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 inherited_members = 7;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\26\4\0\0\0\0\0\0"
    "NoxProto.ACL.ChanGroup"
    "name"
  }},
};
PROTOBUF_NOINLINE void ACL_ChanGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ACL.ChanGroup)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.add_.Clear();
  _impl_.remove_.Clear();
  _impl_.inherited_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_.inherited_ = true;
    _impl_.inherit_ = true;
    _impl_.inheritable_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL_ChanGroup::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL_ChanGroup& this_ = static_cast<const ACL_ChanGroup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL_ChanGroup::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL_ChanGroup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ACL.ChanGroup)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required string name = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ACL.ChanGroup.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bool inherited = 2 [default = true];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_inherited(), target);
  }

  // optional bool inherit = 3 [default = true];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_inherit(), target);
  }

  // optional bool inheritable = 4 [default = true];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_inheritable(), target);
  }

  // repeated uint32 add = 5;
  for (int i = 0, n = this_._internal_add_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_add().Get(i), target);
  }

  // repeated uint32 remove = 6;
  for (int i = 0, n = this_._internal_remove_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_remove().Get(i), target);
  }

  // repeated uint32 inherited_members = 7;
  for (int i = 0, n = this_._internal_inherited_members_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_inherited_members().Get(i), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ACL.ChanGroup)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL_ChanGroup::ByteSizeLong(const MessageLite& base) {
  const ACL_ChanGroup& this_ = static_cast<const ACL_ChanGroup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL_ChanGroup::ByteSizeLong() const {
  const ACL_ChanGroup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ACL.ChanGroup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 add = 5;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_add());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_add_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 remove = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_remove());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_remove_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 inherited_members = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_inherited_members());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_inherited_members_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000000eu & cached_has_bits) * 2;
   {
    // required string name = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL_ChanGroup::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ACL_ChanGroup*>(&to_msg);
  auto& from = static_cast<const ACL_ChanGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ACL.ChanGroup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_add()->MergeFrom(from._internal_add());
  _this->_internal_mutable_remove()->MergeFrom(from._internal_remove());
  _this->_internal_mutable_inherited_members()->MergeFrom(from._internal_inherited_members());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.inherited_ = from._impl_.inherited_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.inherit_ = from._impl_.inherit_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.inheritable_ = from._impl_.inheritable_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ACL_ChanGroup::CopyFrom(const ACL_ChanGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ACL.ChanGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ACL_ChanGroup::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ACL_ChanGroup&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ACL_ChanGroup::InternalSwap(ACL_ChanGroup* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.add_.InternalSwap(&other->_impl_.add_);
  _impl_.remove_.InternalSwap(&other->_impl_.remove_);
  _impl_.inherited_members_.InternalSwap(&other->_impl_.inherited_members_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_)
      + sizeof(ACL_ChanGroup::_impl_.inheritable_)
      - PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_)>(
          reinterpret_cast<char*>(&_impl_.inherited_),
          reinterpret_cast<char*>(&other->_impl_.inherited_));
}

::google::protobuf::Metadata ACL_ChanGroup::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL_ChanACL::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL_ChanACL>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._has_bits_);
};

ACL_ChanACL::ACL_ChanACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ACL.ChanACL)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanACL::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ACL_ChanACL& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        group_(arena, from.group_) {}

ACL_ChanACL::ACL_ChanACL(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL_ChanACL& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL_ChanACL* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, user_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, user_id_),
           offsetof(Impl_, inherited_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::inherited_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ACL.ChanACL)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanACL::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        group_(arena),
        apply_here_{true},
        apply_subs_{true},
        inherited_{true} {}

inline void ACL_ChanACL::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, user_id_),
           0,
           offsetof(Impl_, deny_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::deny_));
}
ACL_ChanACL::~ACL_ChanACL() {
  // @@protoc_insertion_point(destructor:NoxProto.ACL.ChanACL)
  SharedDtor(*this);
}
inline void ACL_ChanACL::SharedDtor(MessageLite& self) {
  ACL_ChanACL& this_ = static_cast<ACL_ChanACL&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.group_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL_ChanACL::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL_ChanACL(arena);
}
constexpr auto ACL_ChanACL::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ACL_ChanACL),
                                            alignof(ACL_ChanACL));
}
constexpr auto ACL_ChanACL::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_ChanACL_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ACL_ChanACL::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL_ChanACL>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL_ChanACL::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL_ChanACL>(), &ACL_ChanACL::ByteSizeLong,
              &ACL_ChanACL::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._cached_size_),
          false,
      },
      &ACL_ChanACL::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_ChanACL_class_data_ =
        ACL_ChanACL::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL_ChanACL::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_ChanACL_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_ChanACL_class_data_.tc_table);
  return ACL_ChanACL_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 34, 2>
ACL_ChanACL::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ACL_ChanACL_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ACL_ChanACL>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool apply_here = 1 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.apply_here_), 4>(),
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_here_)}},
    // optional bool apply_subs = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.apply_subs_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_subs_)}},
    // optional bool inherited = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.inherited_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_)}},
    // optional uint32 user_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.user_id_), 1>(),
     {32, 1, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_)}},
    // optional string group = 5;
    {::_pbi::TcParser::FastSS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.group_)}},
    // optional uint32 grant = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.grant_), 2>(),
     {48, 2, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.grant_)}},
    // optional uint32 deny = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.deny_), 3>(),
     {56, 3, 0, PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.deny_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool apply_here = 1 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_here_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool apply_subs = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_subs_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inherited = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 user_id = 4;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string group = 5;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.group_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 grant = 6;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.grant_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 deny = 7;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.deny_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\24\0\0\0\0\5\0\0"
    "NoxProto.ACL.ChanACL"
    "group"
  }},
};
PROTOBUF_NOINLINE void ACL_ChanACL::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ACL.ChanACL)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.group_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000007eu) != 0) {
    ::memset(&_impl_.user_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.deny_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.deny_));
    _impl_.apply_here_ = true;
    _impl_.apply_subs_ = true;
    _impl_.inherited_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL_ChanACL::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL_ChanACL& this_ = static_cast<const ACL_ChanACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL_ChanACL::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL_ChanACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ACL.ChanACL)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool apply_here = 1 [default = true];
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_apply_here(), target);
  }

  // optional bool apply_subs = 2 [default = true];
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_apply_subs(), target);
  }

  // optional bool inherited = 3 [default = true];
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_inherited(), target);
  }

  // optional uint32 user_id = 4;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_user_id(), target);
  }

  // optional string group = 5;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_group();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ACL.ChanACL.group");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint32 grant = 6;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_grant(), target);
  }

  // optional uint32 deny = 7;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_deny(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ACL.ChanACL)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL_ChanACL::ByteSizeLong(const MessageLite& base) {
  const ACL_ChanACL& this_ = static_cast<const ACL_ChanACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL_ChanACL::ByteSizeLong() const {
  const ACL_ChanACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ACL.ChanACL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000070u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // optional string group = 5;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_group());
    }
    // optional uint32 user_id = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
    // optional uint32 grant = 6;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_grant());
    }
    // optional uint32 deny = 7;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_deny());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL_ChanACL::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ACL_ChanACL*>(&to_msg);
  auto& from = static_cast<const ACL_ChanACL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ACL.ChanACL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_group(from._internal_group());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.grant_ = from._impl_.grant_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.deny_ = from._impl_.deny_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.apply_here_ = from._impl_.apply_here_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.apply_subs_ = from._impl_.apply_subs_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.inherited_ = from._impl_.inherited_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ACL_ChanACL::CopyFrom(const ACL_ChanACL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ACL.ChanACL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ACL_ChanACL::InternalSwap(ACL_ChanACL* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.group_, &other->_impl_.group_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_)
      + sizeof(ACL_ChanACL::_impl_.inherited_)
      - PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

::google::protobuf::Metadata ACL_ChanACL::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ACL::ACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ACL)
}
PROTOBUF_NDEBUG_INLINE ACL::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ACL& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        groups_{visibility, arena, from.groups_},
        acls_{visibility, arena, from.acls_} {}

ACL::ACL(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, inherit_acls_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::inherit_acls_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ACL)
}
PROTOBUF_NDEBUG_INLINE ACL::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        groups_{visibility, arena},
        acls_{visibility, arena},
        inherit_acls_{true} {}

inline void ACL::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, query_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::query_));
}
ACL::~ACL() {
  // @@protoc_insertion_point(destructor:NoxProto.ACL)
  SharedDtor(*this);
}
inline void ACL::SharedDtor(MessageLite& self) {
  ACL& this_ = static_cast<ACL&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL(arena);
}
constexpr auto ACL::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_) +
          decltype(ACL::_impl_.groups_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_) +
          decltype(ACL::_impl_.acls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ACL), alignof(ACL), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ACL::PlacementNew_,
                                 sizeof(ACL),
                                 alignof(ACL));
  }
}
constexpr auto ACL::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ACL::IsInitializedImpl,
          &ACL::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL>(), &ACL::ByteSizeLong,
              &ACL::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL, _impl_._cached_size_),
          false,
      },
      &ACL::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_class_data_ =
        ACL::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_class_data_.tc_table);
  return ACL_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2>
ACL::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ACL_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ACL>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL, _impl_.channel_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_)}},
    // optional bool inherit_acls = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL, _impl_.inherit_acls_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_)}},
    // repeated .NoxProto.ACL.ChanGroup groups = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_)}},
    // repeated .NoxProto.ACL.ChanACL acls = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_)}},
    // optional bool query = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL, _impl_.query_), 1>(),
     {40, 1, 0, PROTOBUF_FIELD_OFFSET(ACL, _impl_.query_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool inherit_acls = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .NoxProto.ACL.ChanGroup groups = 3;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NoxProto.ACL.ChanACL acls = 4;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool query = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.query_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::ACL_ChanGroup>()},
      {::_pbi::TcParser::GetTable<::NoxProto::ACL_ChanACL>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ACL::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ACL)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.groups_.Clear();
  _impl_.acls_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.query_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.query_));
    _impl_.inherit_acls_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL& this_ = static_cast<const ACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ACL)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 channel_id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional bool inherit_acls = 2 [default = true];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_inherit_acls(), target);
  }

  // repeated .NoxProto.ACL.ChanGroup groups = 3;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_groups_size());
       i < n; i++) {
    const auto& repfield = this_._internal_groups().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            3, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .NoxProto.ACL.ChanACL acls = 4;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_acls_size());
       i < n; i++) {
    const auto& repfield = this_._internal_acls().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            4, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // optional bool query = 5 [default = false];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_query(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ACL)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL::ByteSizeLong(const MessageLite& base) {
  const ACL& this_ = static_cast<const ACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL::ByteSizeLong() const {
  const ACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ACL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .NoxProto.ACL.ChanGroup groups = 3;
    {
      total_size += 1UL * this_._internal_groups_size();
      for (const auto& msg : this_._internal_groups()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .NoxProto.ACL.ChanACL acls = 4;
    {
      total_size += 1UL * this_._internal_acls_size();
      for (const auto& msg : this_._internal_acls()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000006u & cached_has_bits) * 2;
   {
    // required uint32 channel_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ACL*>(&to_msg);
  auto& from = static_cast<const ACL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ACL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_groups()->MergeFrom(
      from._internal_groups());
  _this->_internal_mutable_acls()->MergeFrom(
      from._internal_acls());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.query_ = from._impl_.query_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.inherit_acls_ = from._impl_.inherit_acls_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ACL::CopyFrom(const ACL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ACL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ACL::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ACL&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_groups()))
    return false;
  return true;
}

void ACL::InternalSwap(ACL* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.groups_.InternalSwap(&other->_impl_.groups_);
  _impl_.acls_.InternalSwap(&other->_impl_.acls_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_)
      + sizeof(ACL::_impl_.inherit_acls_)
      - PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata ACL::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class QueryUsers::_Internal {
 public:
};

QueryUsers::QueryUsers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueryUsers_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.QueryUsers)
}
PROTOBUF_NDEBUG_INLINE QueryUsers::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::QueryUsers& from_msg)
      : ids_{visibility, arena, from.ids_},
        names_{visibility, arena, from.names_},
        _cached_size_{0} {}

QueryUsers::QueryUsers(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const QueryUsers& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueryUsers_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  QueryUsers* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:NoxProto.QueryUsers)
}
PROTOBUF_NDEBUG_INLINE QueryUsers::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : ids_{visibility, arena},
        names_{visibility, arena},
        _cached_size_{0} {}

inline void QueryUsers::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
QueryUsers::~QueryUsers() {
  // @@protoc_insertion_point(destructor:NoxProto.QueryUsers)
  SharedDtor(*this);
}
inline void QueryUsers::SharedDtor(MessageLite& self) {
  QueryUsers& this_ = static_cast<QueryUsers&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL QueryUsers::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) QueryUsers(arena);
}
constexpr auto QueryUsers::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_) +
          decltype(QueryUsers::_impl_.ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_) +
          decltype(QueryUsers::_impl_.names_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(QueryUsers), alignof(QueryUsers), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&QueryUsers::PlacementNew_,
                                 sizeof(QueryUsers),
                                 alignof(QueryUsers));
  }
}
constexpr auto QueryUsers::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_QueryUsers_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &QueryUsers::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<QueryUsers>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &QueryUsers::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<QueryUsers>(), &QueryUsers::ByteSizeLong,
              &QueryUsers::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_._cached_size_),
          false,
      },
      &QueryUsers::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull QueryUsers_class_data_ =
        QueryUsers::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
QueryUsers::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&QueryUsers_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(QueryUsers_class_data_.tc_table);
  return QueryUsers_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 33, 2>
QueryUsers::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    QueryUsers_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::QueryUsers>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string names = 2;
    {::_pbi::TcParser::FastSR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_)}},
    // repeated uint32 ids = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 ids = 1;
    {PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated string names = 2;
    {PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\23\0\5\0\0\0\0\0"
    "NoxProto.QueryUsers"
    "names"
  }},
};
PROTOBUF_NOINLINE void QueryUsers::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.QueryUsers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _impl_.names_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL QueryUsers::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const QueryUsers& this_ = static_cast<const QueryUsers&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL QueryUsers::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const QueryUsers& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.QueryUsers)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 ids = 1;
  for (int i = 0, n = this_._internal_ids_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_ids().Get(i), target);
  }

  // repeated string names = 2;
  for (int i = 0, n = this_._internal_names_size(); i < n; ++i) {
    const auto& s = this_._internal_names().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.QueryUsers.names");
    target = stream->WriteString(2, s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.QueryUsers)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t QueryUsers::ByteSizeLong(const MessageLite& base) {
  const QueryUsers& this_ = static_cast<const QueryUsers&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t QueryUsers::ByteSizeLong() const {
  const QueryUsers& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.QueryUsers)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 ids = 1;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_ids());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_ids_size());
      total_size += tag_size + data_size;
    }
    // repeated string names = 2;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_names().size());
      for (int i = 0, n = this_._internal_names().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_names().Get(i));
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void QueryUsers::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<QueryUsers*>(&to_msg);
  auto& from = static_cast<const QueryUsers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.QueryUsers)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_ids()->MergeFrom(from._internal_ids());
  _this->_internal_mutable_names()->MergeFrom(from._internal_names());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QueryUsers::CopyFrom(const QueryUsers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.QueryUsers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void QueryUsers::InternalSwap(QueryUsers* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
  _impl_.names_.InternalSwap(&other->_impl_.names_);
}

::google::protobuf::Metadata QueryUsers::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CryptSetup::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CryptSetup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._has_bits_);
};

CryptSetup::CryptSetup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CryptSetup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.CryptSetup)
}
PROTOBUF_NDEBUG_INLINE CryptSetup::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::CryptSetup& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_),
        client_nonce_(arena, from.client_nonce_),
        server_nonce_(arena, from.server_nonce_) {}

CryptSetup::CryptSetup(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CryptSetup& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CryptSetup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CryptSetup* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:NoxProto.CryptSetup)
}
PROTOBUF_NDEBUG_INLINE CryptSetup::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        key_(arena),
        client_nonce_(arena),
        server_nonce_(arena) {}

inline void CryptSetup::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CryptSetup::~CryptSetup() {
  // @@protoc_insertion_point(destructor:NoxProto.CryptSetup)
  SharedDtor(*this);
}
inline void CryptSetup::SharedDtor(MessageLite& self) {
  CryptSetup& this_ = static_cast<CryptSetup&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  this_._impl_.client_nonce_.Destroy();
  this_._impl_.server_nonce_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CryptSetup::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CryptSetup(arena);
}
constexpr auto CryptSetup::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CryptSetup),
                                            alignof(CryptSetup));
}
constexpr auto CryptSetup::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CryptSetup_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CryptSetup::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CryptSetup>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CryptSetup::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CryptSetup>(), &CryptSetup::ByteSizeLong,
              &CryptSetup::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._cached_size_),
          false,
      },
      &CryptSetup::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CryptSetup_class_data_ =
        CryptSetup::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CryptSetup::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CryptSetup_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CryptSetup_class_data_.tc_table);
  return CryptSetup_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
CryptSetup::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CryptSetup_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::CryptSetup>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes key = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.key_)}},
    // optional bytes client_nonce = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.client_nonce_)}},
    // optional bytes server_nonce = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.server_nonce_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes key = 1;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes client_nonce = 2;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.client_nonce_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes server_nonce = 3;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.server_nonce_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CryptSetup::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.CryptSetup)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.client_nonce_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.server_nonce_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CryptSetup::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CryptSetup& this_ = static_cast<const CryptSetup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CryptSetup::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CryptSetup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.CryptSetup)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes key = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional bytes client_nonce = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_client_nonce();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional bytes server_nonce = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_server_nonce();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.CryptSetup)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CryptSetup::ByteSizeLong(const MessageLite& base) {
  const CryptSetup& this_ = static_cast<const CryptSetup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CryptSetup::ByteSizeLong() const {
  const CryptSetup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.CryptSetup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // optional bytes key = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_key());
    }
    // optional bytes client_nonce = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_client_nonce());
    }
    // optional bytes server_nonce = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_server_nonce());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CryptSetup::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CryptSetup*>(&to_msg);
  auto& from = static_cast<const CryptSetup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.CryptSetup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_key(from._internal_key());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_client_nonce(from._internal_client_nonce());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_server_nonce(from._internal_server_nonce());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CryptSetup::CopyFrom(const CryptSetup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.CryptSetup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CryptSetup::InternalSwap(CryptSetup* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_nonce_, &other->_impl_.client_nonce_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.server_nonce_, &other->_impl_.server_nonce_, arena);
}

::google::protobuf::Metadata CryptSetup::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ContextActionModify::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ContextActionModify>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ContextActionModify::ContextActionModify(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextActionModify_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ContextActionModify)
}
PROTOBUF_NDEBUG_INLINE ContextActionModify::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ContextActionModify& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        action_(arena, from.action_),
        text_(arena, from.text_) {}

ContextActionModify::ContextActionModify(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ContextActionModify& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextActionModify_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ContextActionModify* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, context_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, context_),
           offsetof(Impl_, operation_) -
               offsetof(Impl_, context_) +
               sizeof(Impl_::operation_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ContextActionModify)
}
PROTOBUF_NDEBUG_INLINE ContextActionModify::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        action_(arena),
        text_(arena) {}

inline void ContextActionModify::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, context_),
           0,
           offsetof(Impl_, operation_) -
               offsetof(Impl_, context_) +
               sizeof(Impl_::operation_));
}
ContextActionModify::~ContextActionModify() {
  // @@protoc_insertion_point(destructor:NoxProto.ContextActionModify)
  SharedDtor(*this);
}
inline void ContextActionModify::SharedDtor(MessageLite& self) {
  ContextActionModify& this_ = static_cast<ContextActionModify&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.action_.Destroy();
  this_._impl_.text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ContextActionModify::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ContextActionModify(arena);
}
constexpr auto ContextActionModify::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ContextActionModify),
                                            alignof(ContextActionModify));
}
constexpr auto ContextActionModify::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ContextActionModify_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ContextActionModify::IsInitializedImpl,
          &ContextActionModify::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ContextActionModify>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ContextActionModify::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ContextActionModify>(), &ContextActionModify::ByteSizeLong,
              &ContextActionModify::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._cached_size_),
          false,
      },
      &ContextActionModify::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ContextActionModify_class_data_ =
        ContextActionModify::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ContextActionModify::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ContextActionModify_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ContextActionModify_class_data_.tc_table);
  return ContextActionModify_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 47, 2>
ContextActionModify::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ContextActionModify_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ContextActionModify>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .NoxProto.ContextActionModify.Operation operation = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 3, 1, PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_)}},
    // required string action = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.action_)}},
    // optional string text = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.text_)}},
    // optional uint32 context = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextActionModify, _impl_.context_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string action = 1;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.action_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string text = 2;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.text_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 context = 3;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .NoxProto.ContextActionModify.Operation operation = 4;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }},
  {{
      {0, 1},
  }},
  {{
    "\34\6\4\0\0\0\0\0"
    "NoxProto.ContextActionModify"
    "action"
    "text"
  }},
};
PROTOBUF_NOINLINE void ContextActionModify::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ContextActionModify)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.action_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.context_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.operation_) -
        reinterpret_cast<char*>(&_impl_.context_)) + sizeof(_impl_.operation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ContextActionModify::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ContextActionModify& this_ = static_cast<const ContextActionModify&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ContextActionModify::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ContextActionModify& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ContextActionModify)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required string action = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_action();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ContextActionModify.action");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string text = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_text();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ContextActionModify.text");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional uint32 context = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_context(), target);
  }

  // optional .NoxProto.ContextActionModify.Operation operation = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this_._internal_operation(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ContextActionModify)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ContextActionModify::ByteSizeLong(const MessageLite& base) {
  const ContextActionModify& this_ = static_cast<const ContextActionModify&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ContextActionModify::ByteSizeLong() const {
  const ContextActionModify& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ContextActionModify)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required string action = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_action());
    }
  }
  if ((cached_has_bits & 0x0000000eu) != 0) {
    // optional string text = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_text());
    }
    // optional uint32 context = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_context());
    }
    // optional .NoxProto.ContextActionModify.Operation operation = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_operation());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ContextActionModify::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ContextActionModify*>(&to_msg);
  auto& from = static_cast<const ContextActionModify&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ContextActionModify)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_action(from._internal_action());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_text(from._internal_text());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.context_ = from._impl_.context_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.operation_ = from._impl_.operation_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ContextActionModify::CopyFrom(const ContextActionModify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ContextActionModify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ContextActionModify::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ContextActionModify&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ContextActionModify::InternalSwap(ContextActionModify* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_, &other->_impl_.action_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_, &other->_impl_.text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_)
      + sizeof(ContextActionModify::_impl_.operation_)
      - PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_)>(
          reinterpret_cast<char*>(&_impl_.context_),
          reinterpret_cast<char*>(&other->_impl_.context_));
}

::google::protobuf::Metadata ContextActionModify::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ContextAction::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ContextAction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ContextAction::ContextAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ContextAction)
}
PROTOBUF_NDEBUG_INLINE ContextAction::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ContextAction& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        action_(arena, from.action_) {}

ContextAction::ContextAction(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ContextAction& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ContextAction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, channel_id_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::channel_id_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ContextAction)
}
PROTOBUF_NDEBUG_INLINE ContextAction::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        action_(arena) {}

inline void ContextAction::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, channel_id_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::channel_id_));
}
ContextAction::~ContextAction() {
  // @@protoc_insertion_point(destructor:NoxProto.ContextAction)
  SharedDtor(*this);
}
inline void ContextAction::SharedDtor(MessageLite& self) {
  ContextAction& this_ = static_cast<ContextAction&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.action_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ContextAction::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ContextAction(arena);
}
constexpr auto ContextAction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ContextAction),
                                            alignof(ContextAction));
}
constexpr auto ContextAction::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ContextAction_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ContextAction::IsInitializedImpl,
          &ContextAction::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ContextAction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ContextAction::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ContextAction>(), &ContextAction::ByteSizeLong,
              &ContextAction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._cached_size_),
          false,
      },
      &ContextAction::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ContextAction_class_data_ =
        ContextAction::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ContextAction::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ContextAction_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ContextAction_class_data_.tc_table);
  return ContextAction_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 37, 2>
ContextAction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ContextAction_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ContextAction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextAction, _impl_.session_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextAction, _impl_.channel_id_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_)}},
    // required string action = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.action_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // required string action = 3;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.action_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\26\0\0\6\0\0\0\0"
    "NoxProto.ContextAction"
    "action"
  }},
};
PROTOBUF_NOINLINE void ContextAction::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ContextAction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.action_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x00000006u) != 0) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.channel_id_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.channel_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ContextAction::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ContextAction& this_ = static_cast<const ContextAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ContextAction::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ContextAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ContextAction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 channel_id = 2;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // required string action = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_action();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ContextAction.action");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ContextAction)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ContextAction::ByteSizeLong(const MessageLite& base) {
  const ContextAction& this_ = static_cast<const ContextAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ContextAction::ByteSizeLong() const {
  const ContextAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ContextAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required string action = 3;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_action());
    }
  }
  if ((cached_has_bits & 0x00000006u) != 0) {
    // optional uint32 session = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 channel_id = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ContextAction::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ContextAction*>(&to_msg);
  auto& from = static_cast<const ContextAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ContextAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_action(from._internal_action());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ContextAction::CopyFrom(const ContextAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ContextAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ContextAction::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ContextAction&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ContextAction::InternalSwap(ContextAction* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_, &other->_impl_.action_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_)
      + sizeof(ContextAction::_impl_.channel_id_)
      - PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata ContextAction::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserList_User::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserList_User>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

UserList_User::UserList_User(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserList.User)
}
PROTOBUF_NDEBUG_INLINE UserList_User::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserList_User& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_),
        last_seen_(arena, from.last_seen_) {}

UserList_User::UserList_User(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserList_User& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserList_User* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, user_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, user_id_),
           offsetof(Impl_, last_channel_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::last_channel_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserList.User)
}
PROTOBUF_NDEBUG_INLINE UserList_User::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        name_(arena),
        last_seen_(arena) {}

inline void UserList_User::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, user_id_),
           0,
           offsetof(Impl_, last_channel_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::last_channel_));
}
UserList_User::~UserList_User() {
  // @@protoc_insertion_point(destructor:NoxProto.UserList.User)
  SharedDtor(*this);
}
inline void UserList_User::SharedDtor(MessageLite& self) {
  UserList_User& this_ = static_cast<UserList_User&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.last_seen_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserList_User::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserList_User(arena);
}
constexpr auto UserList_User::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UserList_User),
                                            alignof(UserList_User));
}
constexpr auto UserList_User::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserList_User_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserList_User::IsInitializedImpl,
          &UserList_User::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserList_User>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserList_User::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserList_User>(), &UserList_User::ByteSizeLong,
              &UserList_User::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._cached_size_),
          false,
      },
      &UserList_User::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserList_User_class_data_ =
        UserList_User::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserList_User::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserList_User_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserList_User_class_data_.tc_table);
  return UserList_User_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 44, 2>
UserList_User::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserList_User_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserList_User>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 last_channel = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserList_User, _impl_.last_channel_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_)}},
    // required uint32 user_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserList_User, _impl_.user_id_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_)}},
    // optional string name = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.name_)}},
    // optional string last_seen = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_seen_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 user_id = 1;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 2;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string last_seen = 3;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_seen_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 last_channel = 4;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\26\0\4\11\0\0\0\0"
    "NoxProto.UserList.User"
    "name"
    "last_seen"
  }},
};
PROTOBUF_NOINLINE void UserList_User::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserList.User)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.last_seen_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.user_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.last_channel_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.last_channel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserList_User::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserList_User& this_ = static_cast<const UserList_User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserList_User::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserList_User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserList.User)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_user_id(), target);
  }

  // optional string name = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserList.User.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string last_seen = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_last_seen();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.UserList.User.last_seen");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint32 last_channel = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_last_channel(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserList.User)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserList_User::ByteSizeLong(const MessageLite& base) {
  const UserList_User& this_ = static_cast<const UserList_User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserList_User::ByteSizeLong() const {
  const UserList_User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserList.User)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // optional string name = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string last_seen = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_last_seen());
    }
  }
   {
    // required uint32 user_id = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
  }
   {
    // optional uint32 last_channel = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_last_channel());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserList_User::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserList_User*>(&to_msg);
  auto& from = static_cast<const UserList_User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserList.User)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_name(from._internal_name());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_last_seen(from._internal_last_seen());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.last_channel_ = from._impl_.last_channel_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserList_User::CopyFrom(const UserList_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserList.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserList_User::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserList_User&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UserList_User::InternalSwap(UserList_User* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_seen_, &other->_impl_.last_seen_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_)
      + sizeof(UserList_User::_impl_.last_channel_)
      - PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

::google::protobuf::Metadata UserList_User::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserList::_Internal {
 public:
};

UserList::UserList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserList)
}
PROTOBUF_NDEBUG_INLINE UserList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserList& from_msg)
      : users_{visibility, arena, from.users_},
        _cached_size_{0} {}

UserList::UserList(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserList& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserList)
}
PROTOBUF_NDEBUG_INLINE UserList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : users_{visibility, arena},
        _cached_size_{0} {}

inline void UserList::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
UserList::~UserList() {
  // @@protoc_insertion_point(destructor:NoxProto.UserList)
  SharedDtor(*this);
}
inline void UserList::SharedDtor(MessageLite& self) {
  UserList& this_ = static_cast<UserList&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserList::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserList(arena);
}
constexpr auto UserList::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_) +
          decltype(UserList::_impl_.users_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(UserList), alignof(UserList), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UserList::PlacementNew_,
                                 sizeof(UserList),
                                 alignof(UserList));
  }
}
constexpr auto UserList::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserList_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserList::IsInitializedImpl,
          &UserList::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserList>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserList::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserList>(), &UserList::ByteSizeLong,
              &UserList::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserList, _impl_._cached_size_),
          false,
      },
      &UserList::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserList_class_data_ =
        UserList::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserList::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserList_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserList_class_data_.tc_table);
  return UserList_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
UserList::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserList_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserList>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .NoxProto.UserList.User users = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .NoxProto.UserList.User users = 1;
    {PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::UserList_User>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void UserList::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.users_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserList::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserList& this_ = static_cast<const UserList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserList::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserList)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .NoxProto.UserList.User users = 1;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_users_size());
       i < n; i++) {
    const auto& repfield = this_._internal_users().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserList)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserList::ByteSizeLong(const MessageLite& base) {
  const UserList& this_ = static_cast<const UserList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserList::ByteSizeLong() const {
  const UserList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .NoxProto.UserList.User users = 1;
    {
      total_size += 1UL * this_._internal_users_size();
      for (const auto& msg : this_._internal_users()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserList::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserList*>(&to_msg);
  auto& from = static_cast<const UserList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_users()->MergeFrom(
      from._internal_users());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserList::CopyFrom(const UserList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserList::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserList&>(msg);
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_users()))
    return false;
  return true;
}

void UserList::InternalSwap(UserList* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.users_.InternalSwap(&other->_impl_.users_);
}

::google::protobuf::Metadata UserList::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class VoiceTarget_Target::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<VoiceTarget_Target>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._has_bits_);
};

VoiceTarget_Target::VoiceTarget_Target(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_Target_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.VoiceTarget.Target)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget_Target::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::VoiceTarget_Target& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        session_{visibility, arena, from.session_},
        group_(arena, from.group_) {}

VoiceTarget_Target::VoiceTarget_Target(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const VoiceTarget_Target& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_Target_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  VoiceTarget_Target* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, children_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::children_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.VoiceTarget.Target)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget_Target::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        session_{visibility, arena},
        group_(arena) {}

inline void VoiceTarget_Target::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, children_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::children_));
}
VoiceTarget_Target::~VoiceTarget_Target() {
  // @@protoc_insertion_point(destructor:NoxProto.VoiceTarget.Target)
  SharedDtor(*this);
}
inline void VoiceTarget_Target::SharedDtor(MessageLite& self) {
  VoiceTarget_Target& this_ = static_cast<VoiceTarget_Target&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.group_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL VoiceTarget_Target::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) VoiceTarget_Target(arena);
}
constexpr auto VoiceTarget_Target::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_) +
          decltype(VoiceTarget_Target::_impl_.session_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(VoiceTarget_Target), alignof(VoiceTarget_Target), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&VoiceTarget_Target::PlacementNew_,
                                 sizeof(VoiceTarget_Target),
                                 alignof(VoiceTarget_Target));
  }
}
constexpr auto VoiceTarget_Target::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_VoiceTarget_Target_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &VoiceTarget_Target::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<VoiceTarget_Target>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &VoiceTarget_Target::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<VoiceTarget_Target>(), &VoiceTarget_Target::ByteSizeLong,
              &VoiceTarget_Target::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._cached_size_),
          false,
      },
      &VoiceTarget_Target::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull VoiceTarget_Target_class_data_ =
        VoiceTarget_Target::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
VoiceTarget_Target::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&VoiceTarget_Target_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(VoiceTarget_Target_class_data_.tc_table);
  return VoiceTarget_Target_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 41, 2>
VoiceTarget_Target::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    VoiceTarget_Target_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::VoiceTarget_Target>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 session = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VoiceTarget_Target, _impl_.channel_id_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_)}},
    // optional string group = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.group_)}},
    // optional bool links = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(VoiceTarget_Target, _impl_.links_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.links_)}},
    // optional bool children = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(VoiceTarget_Target, _impl_.children_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string group = 3;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.group_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bool links = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.links_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool children = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\33\0\0\5\0\0\0\0"
    "NoxProto.VoiceTarget.Target"
    "group"
  }},
};
PROTOBUF_NOINLINE void VoiceTarget_Target::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.VoiceTarget.Target)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.session_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.group_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000000eu) != 0) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.children_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.children_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL VoiceTarget_Target::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const VoiceTarget_Target& this_ = static_cast<const VoiceTarget_Target&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL VoiceTarget_Target::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const VoiceTarget_Target& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.VoiceTarget.Target)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 session = 1;
  for (int i = 0, n = this_._internal_session_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session().Get(i), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 channel_id = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // optional string group = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_group();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.VoiceTarget.Target.group");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bool links = 4 [default = false];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_links(), target);
  }

  // optional bool children = 5 [default = false];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_children(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.VoiceTarget.Target)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t VoiceTarget_Target::ByteSizeLong(const MessageLite& base) {
  const VoiceTarget_Target& this_ = static_cast<const VoiceTarget_Target&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t VoiceTarget_Target::ByteSizeLong() const {
  const VoiceTarget_Target& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.VoiceTarget.Target)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 session = 1;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000000cu & cached_has_bits) * 2;
  if ((cached_has_bits & 0x00000003u) != 0) {
    // optional string group = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_group());
    }
    // optional uint32 channel_id = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void VoiceTarget_Target::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<VoiceTarget_Target*>(&to_msg);
  auto& from = static_cast<const VoiceTarget_Target&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.VoiceTarget.Target)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_session()->MergeFrom(from._internal_session());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_group(from._internal_group());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.links_ = from._impl_.links_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.children_ = from._impl_.children_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VoiceTarget_Target::CopyFrom(const VoiceTarget_Target& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.VoiceTarget.Target)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void VoiceTarget_Target::InternalSwap(VoiceTarget_Target* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_.InternalSwap(&other->_impl_.session_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.group_, &other->_impl_.group_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_)
      + sizeof(VoiceTarget_Target::_impl_.children_)
      - PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata VoiceTarget_Target::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class VoiceTarget::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<VoiceTarget>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._has_bits_);
};

VoiceTarget::VoiceTarget(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.VoiceTarget)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::VoiceTarget& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        targets_{visibility, arena, from.targets_} {}

VoiceTarget::VoiceTarget(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const VoiceTarget& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  VoiceTarget* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.id_ = from._impl_.id_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.VoiceTarget)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        targets_{visibility, arena} {}

inline void VoiceTarget::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
VoiceTarget::~VoiceTarget() {
  // @@protoc_insertion_point(destructor:NoxProto.VoiceTarget)
  SharedDtor(*this);
}
inline void VoiceTarget::SharedDtor(MessageLite& self) {
  VoiceTarget& this_ = static_cast<VoiceTarget&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL VoiceTarget::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) VoiceTarget(arena);
}
constexpr auto VoiceTarget::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_) +
          decltype(VoiceTarget::_impl_.targets_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(VoiceTarget), alignof(VoiceTarget), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&VoiceTarget::PlacementNew_,
                                 sizeof(VoiceTarget),
                                 alignof(VoiceTarget));
  }
}
constexpr auto VoiceTarget::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_VoiceTarget_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &VoiceTarget::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<VoiceTarget>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &VoiceTarget::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<VoiceTarget>(), &VoiceTarget::ByteSizeLong,
              &VoiceTarget::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._cached_size_),
          false,
      },
      &VoiceTarget::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull VoiceTarget_class_data_ =
        VoiceTarget::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
VoiceTarget::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&VoiceTarget_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(VoiceTarget_class_data_.tc_table);
  return VoiceTarget_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
VoiceTarget::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    VoiceTarget_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::VoiceTarget>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .NoxProto.VoiceTarget.Target targets = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_)}},
    // optional uint32 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VoiceTarget, _impl_.id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 id = 1;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated .NoxProto.VoiceTarget.Target targets = 2;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::VoiceTarget_Target>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void VoiceTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.VoiceTarget)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.targets_.Clear();
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL VoiceTarget::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const VoiceTarget& this_ = static_cast<const VoiceTarget&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL VoiceTarget::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const VoiceTarget& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.VoiceTarget)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_id(), target);
  }

  // repeated .NoxProto.VoiceTarget.Target targets = 2;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_targets_size());
       i < n; i++) {
    const auto& repfield = this_._internal_targets().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            2, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.VoiceTarget)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t VoiceTarget::ByteSizeLong(const MessageLite& base) {
  const VoiceTarget& this_ = static_cast<const VoiceTarget&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t VoiceTarget::ByteSizeLong() const {
  const VoiceTarget& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.VoiceTarget)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .NoxProto.VoiceTarget.Target targets = 2;
    {
      total_size += 1UL * this_._internal_targets_size();
      for (const auto& msg : this_._internal_targets()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
   {
    // optional uint32 id = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void VoiceTarget::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<VoiceTarget*>(&to_msg);
  auto& from = static_cast<const VoiceTarget&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.VoiceTarget)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_targets()->MergeFrom(
      from._internal_targets());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_impl_.id_ = from._impl_.id_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VoiceTarget::CopyFrom(const VoiceTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.VoiceTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void VoiceTarget::InternalSwap(VoiceTarget* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.targets_.InternalSwap(&other->_impl_.targets_);
  swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata VoiceTarget::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PermissionQuery::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PermissionQuery>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._has_bits_);
};

PermissionQuery::PermissionQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionQuery_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.PermissionQuery)
}
PermissionQuery::PermissionQuery(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PermissionQuery& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionQuery_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE PermissionQuery::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PermissionQuery::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, flush_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::flush_));
}
PermissionQuery::~PermissionQuery() {
  // @@protoc_insertion_point(destructor:NoxProto.PermissionQuery)
  SharedDtor(*this);
}
inline void PermissionQuery::SharedDtor(MessageLite& self) {
  PermissionQuery& this_ = static_cast<PermissionQuery&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PermissionQuery::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PermissionQuery(arena);
}
constexpr auto PermissionQuery::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PermissionQuery),
                                            alignof(PermissionQuery));
}
constexpr auto PermissionQuery::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PermissionQuery_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PermissionQuery::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PermissionQuery>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PermissionQuery::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PermissionQuery>(), &PermissionQuery::ByteSizeLong,
              &PermissionQuery::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._cached_size_),
          false,
      },
      &PermissionQuery::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PermissionQuery_class_data_ =
        PermissionQuery::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PermissionQuery::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PermissionQuery_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PermissionQuery_class_data_.tc_table);
  return PermissionQuery_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
PermissionQuery::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PermissionQuery_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::PermissionQuery>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionQuery, _impl_.channel_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_)}},
    // optional uint32 permissions = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionQuery, _impl_.permissions_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.permissions_)}},
    // optional bool flush = 3 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PermissionQuery, _impl_.flush_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 permissions = 2;
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.permissions_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool flush = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PermissionQuery::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.PermissionQuery)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flush_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.flush_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PermissionQuery::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PermissionQuery& this_ = static_cast<const PermissionQuery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PermissionQuery::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PermissionQuery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.PermissionQuery)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 channel_id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional uint32 permissions = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_permissions(), target);
  }

  // optional bool flush = 3 [default = false];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_flush(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.PermissionQuery)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PermissionQuery::ByteSizeLong(const MessageLite& base) {
  const PermissionQuery& this_ = static_cast<const PermissionQuery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PermissionQuery::ByteSizeLong() const {
  const PermissionQuery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.PermissionQuery)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000004u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x00000003u) != 0) {
    // optional uint32 channel_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 permissions = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_permissions());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PermissionQuery::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PermissionQuery*>(&to_msg);
  auto& from = static_cast<const PermissionQuery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.PermissionQuery)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.permissions_ = from._impl_.permissions_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.flush_ = from._impl_.flush_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PermissionQuery::CopyFrom(const PermissionQuery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.PermissionQuery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PermissionQuery::InternalSwap(PermissionQuery* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_)
      + sizeof(PermissionQuery::_impl_.flush_)
      - PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata PermissionQuery::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CodecVersion::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CodecVersion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

CodecVersion::CodecVersion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CodecVersion_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.CodecVersion)
}
CodecVersion::CodecVersion(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CodecVersion& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CodecVersion_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE CodecVersion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        prefer_alpha_{true} {}

inline void CodecVersion::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, alpha_),
           0,
           offsetof(Impl_, opus_) -
               offsetof(Impl_, alpha_) +
               sizeof(Impl_::opus_));
}
CodecVersion::~CodecVersion() {
  // @@protoc_insertion_point(destructor:NoxProto.CodecVersion)
  SharedDtor(*this);
}
inline void CodecVersion::SharedDtor(MessageLite& self) {
  CodecVersion& this_ = static_cast<CodecVersion&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CodecVersion::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CodecVersion(arena);
}
constexpr auto CodecVersion::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CodecVersion),
                                            alignof(CodecVersion));
}
constexpr auto CodecVersion::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CodecVersion_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          CodecVersion::IsInitializedImpl,
          &CodecVersion::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CodecVersion>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CodecVersion::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CodecVersion>(), &CodecVersion::ByteSizeLong,
              &CodecVersion::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._cached_size_),
          false,
      },
      &CodecVersion::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CodecVersion_class_data_ =
        CodecVersion::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CodecVersion::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CodecVersion_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CodecVersion_class_data_.tc_table);
  return CodecVersion_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
CodecVersion::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CodecVersion_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::CodecVersion>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool opus = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CodecVersion, _impl_.opus_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.opus_)}},
    // required int32 alpha = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CodecVersion, _impl_.alpha_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_)}},
    // required int32 beta = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CodecVersion, _impl_.beta_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.beta_)}},
    // required bool prefer_alpha = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CodecVersion, _impl_.prefer_alpha_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required int32 alpha = 1;
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // required int32 beta = 2;
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.beta_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // required bool prefer_alpha = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool opus = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.opus_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CodecVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.CodecVersion)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    ::memset(&_impl_.alpha_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.opus_) -
        reinterpret_cast<char*>(&_impl_.alpha_)) + sizeof(_impl_.opus_));
    _impl_.prefer_alpha_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CodecVersion::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CodecVersion& this_ = static_cast<const CodecVersion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CodecVersion::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CodecVersion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.CodecVersion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required int32 alpha = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_alpha(), target);
  }

  // required int32 beta = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_beta(), target);
  }

  // required bool prefer_alpha = 3 [default = true];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_prefer_alpha(), target);
  }

  // optional bool opus = 4 [default = false];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_opus(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.CodecVersion)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CodecVersion::ByteSizeLong(const MessageLite& base) {
  const CodecVersion& this_ = static_cast<const CodecVersion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CodecVersion::ByteSizeLong() const {
  const CodecVersion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.CodecVersion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000000cu & cached_has_bits) * 2;
  if ((cached_has_bits & 0x00000003u) != 0) {
    // required int32 alpha = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_alpha());
    }
    // required int32 beta = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_beta());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CodecVersion::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CodecVersion*>(&to_msg);
  auto& from = static_cast<const CodecVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.CodecVersion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.alpha_ = from._impl_.alpha_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.beta_ = from._impl_.beta_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.prefer_alpha_ = from._impl_.prefer_alpha_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CodecVersion::CopyFrom(const CodecVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.CodecVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CodecVersion::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const CodecVersion&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void CodecVersion::InternalSwap(CodecVersion* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_)
      + sizeof(CodecVersion::_impl_.prefer_alpha_)
      - PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_)>(
          reinterpret_cast<char*>(&_impl_.alpha_),
          reinterpret_cast<char*>(&other->_impl_.alpha_));
}

::google::protobuf::Metadata CodecVersion::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserStats_Stats::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserStats_Stats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._has_bits_);
};

UserStats_Stats::UserStats_Stats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_Stats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserStats.Stats)
}
UserStats_Stats::UserStats_Stats(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserStats_Stats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_Stats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE UserStats_Stats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void UserStats_Stats::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, good_),
           0,
           offsetof(Impl_, resync_) -
               offsetof(Impl_, good_) +
               sizeof(Impl_::resync_));
}
UserStats_Stats::~UserStats_Stats() {
  // @@protoc_insertion_point(destructor:NoxProto.UserStats.Stats)
  SharedDtor(*this);
}
inline void UserStats_Stats::SharedDtor(MessageLite& self) {
  UserStats_Stats& this_ = static_cast<UserStats_Stats&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserStats_Stats::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserStats_Stats(arena);
}
constexpr auto UserStats_Stats::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UserStats_Stats),
                                            alignof(UserStats_Stats));
}
constexpr auto UserStats_Stats::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserStats_Stats_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserStats_Stats::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserStats_Stats>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserStats_Stats::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserStats_Stats>(), &UserStats_Stats::ByteSizeLong,
              &UserStats_Stats::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._cached_size_),
          false,
      },
      &UserStats_Stats::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserStats_Stats_class_data_ =
        UserStats_Stats::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserStats_Stats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserStats_Stats_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserStats_Stats_class_data_.tc_table);
  return UserStats_Stats_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
UserStats_Stats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserStats_Stats_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserStats_Stats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 resync = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.resync_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_)}},
    // optional uint32 good = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.good_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_)}},
    // optional uint32 late = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.late_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.late_)}},
    // optional uint32 lost = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.lost_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.lost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 good = 1;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 late = 2;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.late_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lost = 3;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.lost_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 resync = 4;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserStats_Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserStats.Stats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    ::memset(&_impl_.good_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.resync_) -
        reinterpret_cast<char*>(&_impl_.good_)) + sizeof(_impl_.resync_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserStats_Stats::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserStats_Stats& this_ = static_cast<const UserStats_Stats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserStats_Stats::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserStats_Stats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserStats.Stats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 good = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_good(), target);
  }

  // optional uint32 late = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_late(), target);
  }

  // optional uint32 lost = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_lost(), target);
  }

  // optional uint32 resync = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_resync(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserStats.Stats)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserStats_Stats::ByteSizeLong(const MessageLite& base) {
  const UserStats_Stats& this_ = static_cast<const UserStats_Stats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserStats_Stats::ByteSizeLong() const {
  const UserStats_Stats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserStats.Stats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // optional uint32 good = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_good());
    }
    // optional uint32 late = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_late());
    }
    // optional uint32 lost = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lost());
    }
    // optional uint32 resync = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_resync());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserStats_Stats::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserStats_Stats*>(&to_msg);
  auto& from = static_cast<const UserStats_Stats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserStats.Stats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.good_ = from._impl_.good_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.late_ = from._impl_.late_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lost_ = from._impl_.lost_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.resync_ = from._impl_.resync_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserStats_Stats::CopyFrom(const UserStats_Stats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserStats.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserStats_Stats::InternalSwap(UserStats_Stats* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_)
      + sizeof(UserStats_Stats::_impl_.resync_)
      - PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_)>(
          reinterpret_cast<char*>(&_impl_.good_),
          reinterpret_cast<char*>(&other->_impl_.good_));
}

::google::protobuf::Metadata UserStats_Stats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserStats_RollingStats::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserStats_RollingStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_._has_bits_);
};

UserStats_RollingStats::UserStats_RollingStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_RollingStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserStats.RollingStats)
}
PROTOBUF_NDEBUG_INLINE UserStats_RollingStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserStats_RollingStats& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

UserStats_RollingStats::UserStats_RollingStats(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserStats_RollingStats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_RollingStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserStats_RollingStats* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.from_client_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_)
                : nullptr;
  _impl_.from_server_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_)
                : nullptr;
  _impl_.time_window_ = from._impl_.time_window_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserStats.RollingStats)
}
PROTOBUF_NDEBUG_INLINE UserStats_RollingStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void UserStats_RollingStats::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, from_client_),
           0,
           offsetof(Impl_, time_window_) -
               offsetof(Impl_, from_client_) +
               sizeof(Impl_::time_window_));
}
UserStats_RollingStats::~UserStats_RollingStats() {
  // @@protoc_insertion_point(destructor:NoxProto.UserStats.RollingStats)
  SharedDtor(*this);
}
inline void UserStats_RollingStats::SharedDtor(MessageLite& self) {
  UserStats_RollingStats& this_ = static_cast<UserStats_RollingStats&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.from_client_;
  delete this_._impl_.from_server_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserStats_RollingStats::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserStats_RollingStats(arena);
}
constexpr auto UserStats_RollingStats::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UserStats_RollingStats),
                                            alignof(UserStats_RollingStats));
}
constexpr auto UserStats_RollingStats::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserStats_RollingStats_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserStats_RollingStats::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserStats_RollingStats>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserStats_RollingStats::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserStats_RollingStats>(), &UserStats_RollingStats::ByteSizeLong,
              &UserStats_RollingStats::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_._cached_size_),
          false,
      },
      &UserStats_RollingStats::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserStats_RollingStats_class_data_ =
        UserStats_RollingStats::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserStats_RollingStats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserStats_RollingStats_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserStats_RollingStats_class_data_.tc_table);
  return UserStats_RollingStats_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2>
UserStats_RollingStats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserStats_RollingStats_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserStats_RollingStats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 time_window = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_RollingStats, _impl_.time_window_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.time_window_)}},
    // optional .NoxProto.UserStats.Stats from_client = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.from_client_)}},
    // optional .NoxProto.UserStats.Stats from_server = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.from_server_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 time_window = 1;
    {PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.time_window_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .NoxProto.UserStats.Stats from_client = 2;
    {PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.from_client_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .NoxProto.UserStats.Stats from_server = 3;
    {PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.from_server_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::UserStats_Stats>()},
      {::_pbi::TcParser::GetTable<::NoxProto::UserStats_Stats>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void UserStats_RollingStats::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserStats.RollingStats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.from_client_ != nullptr);
      _impl_.from_client_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.from_server_ != nullptr);
      _impl_.from_server_->Clear();
    }
  }
  _impl_.time_window_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserStats_RollingStats::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserStats_RollingStats& this_ = static_cast<const UserStats_RollingStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserStats_RollingStats::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserStats_RollingStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserStats.RollingStats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 time_window = 1;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_time_window(), target);
  }

  // optional .NoxProto.UserStats.Stats from_client = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.from_client_, this_._impl_.from_client_->GetCachedSize(), target,
        stream);
  }

  // optional .NoxProto.UserStats.Stats from_server = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.from_server_, this_._impl_.from_server_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserStats.RollingStats)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserStats_RollingStats::ByteSizeLong(const MessageLite& base) {
  const UserStats_RollingStats& this_ = static_cast<const UserStats_RollingStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserStats_RollingStats::ByteSizeLong() const {
  const UserStats_RollingStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserStats.RollingStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // optional .NoxProto.UserStats.Stats from_client = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_client_);
    }
    // optional .NoxProto.UserStats.Stats from_server = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_server_);
    }
    // optional uint32 time_window = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_time_window());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserStats_RollingStats::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserStats_RollingStats*>(&to_msg);
  auto& from = static_cast<const UserStats_RollingStats&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserStats.RollingStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.from_client_ != nullptr);
      if (_this->_impl_.from_client_ == nullptr) {
        _this->_impl_.from_client_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_);
      } else {
        _this->_impl_.from_client_->MergeFrom(*from._impl_.from_client_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.from_server_ != nullptr);
      if (_this->_impl_.from_server_ == nullptr) {
        _this->_impl_.from_server_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_);
      } else {
        _this->_impl_.from_server_->MergeFrom(*from._impl_.from_server_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.time_window_ = from._impl_.time_window_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserStats_RollingStats::CopyFrom(const UserStats_RollingStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserStats.RollingStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserStats_RollingStats::InternalSwap(UserStats_RollingStats* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.time_window_)
      + sizeof(UserStats_RollingStats::_impl_.time_window_)
      - PROTOBUF_FIELD_OFFSET(UserStats_RollingStats, _impl_.from_client_)>(
          reinterpret_cast<char*>(&_impl_.from_client_),
          reinterpret_cast<char*>(&other->_impl_.from_client_));
}

::google::protobuf::Metadata UserStats_RollingStats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserStats::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserStats, _impl_._has_bits_);
};

UserStats::UserStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.UserStats)
}
PROTOBUF_NDEBUG_INLINE UserStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::UserStats& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        certificates_{visibility, arena, from.certificates_},
        celt_versions_{visibility, arena, from.celt_versions_},
        address_(arena, from.address_) {}

UserStats::UserStats(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserStats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserStats* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.from_client_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_)
                : nullptr;
  _impl_.from_server_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_)
                : nullptr;
  _impl_.version_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.version_)
                : nullptr;
  _impl_.rolling_stats_ = ((cached_has_bits & 0x00000010u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.rolling_stats_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, idlesecs_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::idlesecs_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.UserStats)
}
PROTOBUF_NDEBUG_INLINE UserStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        certificates_{visibility, arena},
        celt_versions_{visibility, arena},
        address_(arena) {}

inline void UserStats::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, from_client_),
           0,
           offsetof(Impl_, idlesecs_) -
               offsetof(Impl_, from_client_) +
               sizeof(Impl_::idlesecs_));
}
UserStats::~UserStats() {
  // @@protoc_insertion_point(destructor:NoxProto.UserStats)
  SharedDtor(*this);
}
inline void UserStats::SharedDtor(MessageLite& self) {
  UserStats& this_ = static_cast<UserStats&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.address_.Destroy();
  delete this_._impl_.from_client_;
  delete this_._impl_.from_server_;
  delete this_._impl_.version_;
  delete this_._impl_.rolling_stats_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserStats::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserStats(arena);
}
constexpr auto UserStats::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_) +
          decltype(UserStats::_impl_.certificates_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_) +
          decltype(UserStats::_impl_.celt_versions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(UserStats), alignof(UserStats), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UserStats::PlacementNew_,
                                 sizeof(UserStats),
                                 alignof(UserStats));
  }
}
constexpr auto UserStats::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserStats_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserStats::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserStats>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserStats::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserStats>(), &UserStats::ByteSizeLong,
              &UserStats::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserStats, _impl_._cached_size_),
          false,
      },
      &UserStats::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserStats_class_data_ =
        UserStats::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserStats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserStats_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserStats_class_data_.tc_table);
  return UserStats_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 20, 4, 0, 2>
UserStats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserStats, _impl_._has_bits_),
    0, // no _extensions_
    20, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293918720,  // skipmap
    offsetof(decltype(_table_), field_entries),
    20,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserStats_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::UserStats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.session_), 5>(),
     {8, 5, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.session_)}},
    // optional bool stats_only = 2 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserStats, _impl_.stats_only_), 12>(),
     {16, 12, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.stats_only_)}},
    // repeated bytes certificates = 3;
    {::_pbi::TcParser::FastBR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_)}},
    // optional .NoxProto.UserStats.Stats from_client = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_)}},
    // optional .NoxProto.UserStats.Stats from_server = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 1, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_server_)}},
    // optional uint32 udp_packets = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.udp_packets_), 6>(),
     {48, 6, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_packets_)}},
    // optional uint32 tcp_packets = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.tcp_packets_), 7>(),
     {56, 7, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_packets_)}},
    // optional float udp_ping_avg = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 8, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_avg_)}},
    // optional float udp_ping_var = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 9, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_var_)}},
    // optional float tcp_ping_avg = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 10, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_avg_)}},
    // optional float tcp_ping_var = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 11, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_var_)}},
    // optional .NoxProto.Version version = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 3, 2, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.version_)}},
    // repeated int32 celt_versions = 13;
    {::_pbi::TcParser::FastV32R1,
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_)}},
    // optional bytes address = 14;
    {::_pbi::TcParser::FastBS1,
     {114, 0, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.address_)}},
    // optional uint32 bandwidth = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.bandwidth_), 15>(),
     {120, 15, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.bandwidth_)}},
    // optional uint32 onlinesecs = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 16, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.onlinesecs_)}},
    // optional uint32 idlesecs = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 17, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_)}},
    // optional bool strong_certificate = 18 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {400, 13, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.strong_certificate_)}},
    // optional bool opus = 19 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {408, 14, 0, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.opus_)}},
    // optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
    {::_pbi::TcParser::FastMtS2,
     {418, 4, 3, PROTOBUF_FIELD_OFFSET(UserStats, _impl_.rolling_stats_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.session_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool stats_only = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.stats_only_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated bytes certificates = 3;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // optional .NoxProto.UserStats.Stats from_client = 4;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .NoxProto.UserStats.Stats from_server = 5;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_server_), _Internal::kHasBitsOffset + 2, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 udp_packets = 6;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_packets_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 tcp_packets = 7;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_packets_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float udp_ping_avg = 8;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_avg_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float udp_ping_var = 9;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_var_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_avg = 10;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_avg_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_var = 11;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_var_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional .NoxProto.Version version = 12;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.version_), _Internal::kHasBitsOffset + 3, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 celt_versions = 13;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // optional bytes address = 14;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.address_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 bandwidth = 15;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.bandwidth_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 onlinesecs = 16;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.onlinesecs_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 idlesecs = 17;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool strong_certificate = 18 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.strong_certificate_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool opus = 19 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.opus_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.rolling_stats_), _Internal::kHasBitsOffset + 4, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::NoxProto::UserStats_Stats>()},
      {::_pbi::TcParser::GetTable<::NoxProto::UserStats_Stats>()},
      {::_pbi::TcParser::GetTable<::NoxProto::Version>()},
      {::_pbi::TcParser::GetTable<::NoxProto::UserStats_RollingStats>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void UserStats::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.UserStats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.certificates_.Clear();
  _impl_.celt_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.from_client_ != nullptr);
      _impl_.from_client_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.from_server_ != nullptr);
      _impl_.from_server_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.version_ != nullptr);
      _impl_.version_->Clear();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(_impl_.rolling_stats_ != nullptr);
      _impl_.rolling_stats_->Clear();
    }
  }
  if ((cached_has_bits & 0x000000e0u) != 0) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tcp_packets_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.tcp_packets_));
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    ::memset(&_impl_.udp_ping_avg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.bandwidth_) -
        reinterpret_cast<char*>(&_impl_.udp_ping_avg_)) + sizeof(_impl_.bandwidth_));
  }
  if ((cached_has_bits & 0x00030000u) != 0) {
    ::memset(&_impl_.onlinesecs_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.idlesecs_) -
        reinterpret_cast<char*>(&_impl_.onlinesecs_)) + sizeof(_impl_.idlesecs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserStats::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserStats& this_ = static_cast<const UserStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserStats::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.UserStats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional bool stats_only = 2 [default = false];
  if ((cached_has_bits & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_stats_only(), target);
  }

  // repeated bytes certificates = 3;
  for (int i = 0, n = this_._internal_certificates_size(); i < n; ++i) {
    const auto& s = this_._internal_certificates().Get(i);
    target = stream->WriteBytes(3, s, target);
  }

  // optional .NoxProto.UserStats.Stats from_client = 4;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.from_client_, this_._impl_.from_client_->GetCachedSize(), target,
        stream);
  }

  // optional .NoxProto.UserStats.Stats from_server = 5;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.from_server_, this_._impl_.from_server_->GetCachedSize(), target,
        stream);
  }

  // optional uint32 udp_packets = 6;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_udp_packets(), target);
  }

  // optional uint32 tcp_packets = 7;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_tcp_packets(), target);
  }

  // optional float udp_ping_avg = 8;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this_._internal_udp_ping_avg(), target);
  }

  // optional float udp_ping_var = 9;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this_._internal_udp_ping_var(), target);
  }

  // optional float tcp_ping_avg = 10;
  if ((cached_has_bits & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this_._internal_tcp_ping_avg(), target);
  }

  // optional float tcp_ping_var = 11;
  if ((cached_has_bits & 0x00000800u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this_._internal_tcp_ping_var(), target);
  }

  // optional .NoxProto.Version version = 12;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, *this_._impl_.version_, this_._impl_.version_->GetCachedSize(), target,
        stream);
  }

  // repeated int32 celt_versions = 13;
  for (int i = 0, n = this_._internal_celt_versions_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this_._internal_celt_versions().Get(i), target);
  }

  // optional bytes address = 14;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_address();
    target = stream->WriteBytesMaybeAliased(14, _s, target);
  }

  // optional uint32 bandwidth = 15;
  if ((cached_has_bits & 0x00008000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this_._internal_bandwidth(), target);
  }

  // optional uint32 onlinesecs = 16;
  if ((cached_has_bits & 0x00010000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this_._internal_onlinesecs(), target);
  }

  // optional uint32 idlesecs = 17;
  if ((cached_has_bits & 0x00020000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        17, this_._internal_idlesecs(), target);
  }

  // optional bool strong_certificate = 18 [default = false];
  if ((cached_has_bits & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this_._internal_strong_certificate(), target);
  }

  // optional bool opus = 19 [default = false];
  if ((cached_has_bits & 0x00004000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this_._internal_opus(), target);
  }

  // optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        20, *this_._impl_.rolling_stats_, this_._impl_.rolling_stats_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.UserStats)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserStats::ByteSizeLong(const MessageLite& base) {
  const UserStats& this_ = static_cast<const UserStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserStats::ByteSizeLong() const {
  const UserStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.UserStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated bytes certificates = 3;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_certificates().size());
      for (int i = 0, n = this_._internal_certificates().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
            this_._internal_certificates().Get(i));
      }
    }
    // repeated int32 celt_versions = 13;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_celt_versions());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_celt_versions_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000f00u & cached_has_bits) * 5;
  total_size += ::absl::popcount(0x00006000u & cached_has_bits) * 3;
  total_size += static_cast<bool>(0x00001000u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional bytes address = 14;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_address());
    }
    // optional .NoxProto.UserStats.Stats from_client = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_client_);
    }
    // optional .NoxProto.UserStats.Stats from_server = 5;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_server_);
    }
    // optional .NoxProto.Version version = 12;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.version_);
    }
    // optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.rolling_stats_);
    }
    // optional uint32 session = 1;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 udp_packets = 6;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_udp_packets());
    }
    // optional uint32 tcp_packets = 7;
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_tcp_packets());
    }
  }
   {
    // optional uint32 bandwidth = 15;
    if ((cached_has_bits & 0x00008000u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_bandwidth());
    }
  }
  if ((cached_has_bits & 0x00030000u) != 0) {
    // optional uint32 onlinesecs = 16;
    if ((cached_has_bits & 0x00010000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this_._internal_onlinesecs());
    }
    // optional uint32 idlesecs = 17;
    if ((cached_has_bits & 0x00020000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this_._internal_idlesecs());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserStats::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UserStats*>(&to_msg);
  auto& from = static_cast<const UserStats&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.UserStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_certificates()->MergeFrom(from._internal_certificates());
  _this->_internal_mutable_celt_versions()->MergeFrom(from._internal_celt_versions());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_address(from._internal_address());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.from_client_ != nullptr);
      if (_this->_impl_.from_client_ == nullptr) {
        _this->_impl_.from_client_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_);
      } else {
        _this->_impl_.from_client_->MergeFrom(*from._impl_.from_client_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.from_server_ != nullptr);
      if (_this->_impl_.from_server_ == nullptr) {
        _this->_impl_.from_server_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_);
      } else {
        _this->_impl_.from_server_->MergeFrom(*from._impl_.from_server_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.version_ != nullptr);
      if (_this->_impl_.version_ == nullptr) {
        _this->_impl_.version_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.version_);
      } else {
        _this->_impl_.version_->MergeFrom(*from._impl_.version_);
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(from._impl_.rolling_stats_ != nullptr);
      if (_this->_impl_.rolling_stats_ == nullptr) {
        _this->_impl_.rolling_stats_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.rolling_stats_);
      } else {
        _this->_impl_.rolling_stats_->MergeFrom(*from._impl_.rolling_stats_);
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.udp_packets_ = from._impl_.udp_packets_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.tcp_packets_ = from._impl_.tcp_packets_;
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.udp_ping_avg_ = from._impl_.udp_ping_avg_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.udp_ping_var_ = from._impl_.udp_ping_var_;
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _this->_impl_.tcp_ping_avg_ = from._impl_.tcp_ping_avg_;
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      _this->_impl_.tcp_ping_var_ = from._impl_.tcp_ping_var_;
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _this->_impl_.stats_only_ = from._impl_.stats_only_;
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      _this->_impl_.strong_certificate_ = from._impl_.strong_certificate_;
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
    if ((cached_has_bits & 0x00008000u) != 0) {
      _this->_impl_.bandwidth_ = from._impl_.bandwidth_;
    }
  }
  if ((cached_has_bits & 0x00030000u) != 0) {
    if ((cached_has_bits & 0x00010000u) != 0) {
      _this->_impl_.onlinesecs_ = from._impl_.onlinesecs_;
    }
    if ((cached_has_bits & 0x00020000u) != 0) {
      _this->_impl_.idlesecs_ = from._impl_.idlesecs_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserStats::CopyFrom(const UserStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.UserStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserStats::InternalSwap(UserStats* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.certificates_.InternalSwap(&other->_impl_.certificates_);
  _impl_.celt_versions_.InternalSwap(&other->_impl_.celt_versions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, &other->_impl_.address_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_)
      + sizeof(UserStats::_impl_.idlesecs_)
      - PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_)>(
          reinterpret_cast<char*>(&_impl_.from_client_),
          reinterpret_cast<char*>(&other->_impl_.from_client_));
}

::google::protobuf::Metadata UserStats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RequestBlob::_Internal {
 public:
};

RequestBlob::RequestBlob(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RequestBlob_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.RequestBlob)
}
PROTOBUF_NDEBUG_INLINE RequestBlob::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::RequestBlob& from_msg)
      : session_texture_{visibility, arena, from.session_texture_},
        session_comment_{visibility, arena, from.session_comment_},
        channel_description_{visibility, arena, from.channel_description_},
        _cached_size_{0} {}

RequestBlob::RequestBlob(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RequestBlob& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RequestBlob_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RequestBlob* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:NoxProto.RequestBlob)
}
PROTOBUF_NDEBUG_INLINE RequestBlob::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : session_texture_{visibility, arena},
        session_comment_{visibility, arena},
        channel_description_{visibility, arena},
        _cached_size_{0} {}

inline void RequestBlob::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RequestBlob::~RequestBlob() {
  // @@protoc_insertion_point(destructor:NoxProto.RequestBlob)
  SharedDtor(*this);
}
inline void RequestBlob::SharedDtor(MessageLite& self) {
  RequestBlob& this_ = static_cast<RequestBlob&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RequestBlob::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RequestBlob(arena);
}
constexpr auto RequestBlob::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_) +
          decltype(RequestBlob::_impl_.session_texture_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_) +
          decltype(RequestBlob::_impl_.session_comment_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_) +
          decltype(RequestBlob::_impl_.channel_description_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RequestBlob), alignof(RequestBlob), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RequestBlob::PlacementNew_,
                                 sizeof(RequestBlob),
                                 alignof(RequestBlob));
  }
}
constexpr auto RequestBlob::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RequestBlob_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RequestBlob::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RequestBlob>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RequestBlob::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RequestBlob>(), &RequestBlob::ByteSizeLong,
              &RequestBlob::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_._cached_size_),
          false,
      },
      &RequestBlob::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RequestBlob_class_data_ =
        RequestBlob::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RequestBlob::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RequestBlob_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RequestBlob_class_data_.tc_table);
  return RequestBlob_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
RequestBlob::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    RequestBlob_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::RequestBlob>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 session_texture = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_)}},
    // repeated uint32 session_comment = 2;
    {::_pbi::TcParser::FastV32R1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_)}},
    // repeated uint32 channel_description = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 session_texture = 1;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 session_comment = 2;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 channel_description = 3;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void RequestBlob::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.RequestBlob)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.session_texture_.Clear();
  _impl_.session_comment_.Clear();
  _impl_.channel_description_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RequestBlob::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RequestBlob& this_ = static_cast<const RequestBlob&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RequestBlob::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RequestBlob& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.RequestBlob)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 session_texture = 1;
  for (int i = 0, n = this_._internal_session_texture_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session_texture().Get(i), target);
  }

  // repeated uint32 session_comment = 2;
  for (int i = 0, n = this_._internal_session_comment_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_session_comment().Get(i), target);
  }

  // repeated uint32 channel_description = 3;
  for (int i = 0, n = this_._internal_channel_description_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_channel_description().Get(i), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.RequestBlob)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RequestBlob::ByteSizeLong(const MessageLite& base) {
  const RequestBlob& this_ = static_cast<const RequestBlob&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RequestBlob::ByteSizeLong() const {
  const RequestBlob& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.RequestBlob)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 session_texture = 1;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session_texture());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_texture_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 session_comment = 2;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session_comment());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_comment_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 channel_description = 3;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_channel_description());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_channel_description_size());
      total_size += tag_size + data_size;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RequestBlob::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RequestBlob*>(&to_msg);
  auto& from = static_cast<const RequestBlob&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.RequestBlob)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_session_texture()->MergeFrom(from._internal_session_texture());
  _this->_internal_mutable_session_comment()->MergeFrom(from._internal_session_comment());
  _this->_internal_mutable_channel_description()->MergeFrom(from._internal_channel_description());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBlob::CopyFrom(const RequestBlob& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.RequestBlob)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RequestBlob::InternalSwap(RequestBlob* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.session_texture_.InternalSwap(&other->_impl_.session_texture_);
  _impl_.session_comment_.InternalSwap(&other->_impl_.session_comment_);
  _impl_.channel_description_.InternalSwap(&other->_impl_.channel_description_);
}

::google::protobuf::Metadata RequestBlob::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ServerConfig::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ServerConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._has_bits_);
};

ServerConfig::ServerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.ServerConfig)
}
PROTOBUF_NDEBUG_INLINE ServerConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::ServerConfig& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        welcome_text_(arena, from.welcome_text_) {}

ServerConfig::ServerConfig(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ServerConfig& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ServerConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, max_bandwidth_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, max_bandwidth_),
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, max_bandwidth_) +
               sizeof(Impl_::max_users_));

  // @@protoc_insertion_point(copy_constructor:NoxProto.ServerConfig)
}
PROTOBUF_NDEBUG_INLINE ServerConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        welcome_text_(arena) {}

inline void ServerConfig::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, max_bandwidth_),
           0,
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, max_bandwidth_) +
               sizeof(Impl_::max_users_));
}
ServerConfig::~ServerConfig() {
  // @@protoc_insertion_point(destructor:NoxProto.ServerConfig)
  SharedDtor(*this);
}
inline void ServerConfig::SharedDtor(MessageLite& self) {
  ServerConfig& this_ = static_cast<ServerConfig&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.welcome_text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ServerConfig::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ServerConfig(arena);
}
constexpr auto ServerConfig::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ServerConfig),
                                            alignof(ServerConfig));
}
constexpr auto ServerConfig::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ServerConfig_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ServerConfig::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ServerConfig>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ServerConfig::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ServerConfig>(), &ServerConfig::ByteSizeLong,
              &ServerConfig::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._cached_size_),
          false,
      },
      &ServerConfig::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ServerConfig_class_data_ =
        ServerConfig::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ServerConfig::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ServerConfig_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ServerConfig_class_data_.tc_table);
  return ServerConfig_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 42, 2>
ServerConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ServerConfig_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::ServerConfig>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 max_bandwidth = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.max_bandwidth_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_)}},
    // optional string welcome_text = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.welcome_text_)}},
    // optional bool allow_html = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ServerConfig, _impl_.allow_html_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.allow_html_)}},
    // optional uint32 message_length = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.message_length_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.message_length_)}},
    // optional uint32 image_message_length = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.image_message_length_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.image_message_length_)}},
    // optional uint32 max_users = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.max_users_), 6>(),
     {48, 6, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_)}},
    // optional bool recording_allowed = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ServerConfig, _impl_.recording_allowed_), 5>(),
     {56, 5, 0, PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.recording_allowed_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 max_bandwidth = 1;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string welcome_text = 2;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.welcome_text_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bool allow_html = 3;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.allow_html_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 message_length = 4;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.message_length_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 image_message_length = 5;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.image_message_length_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 max_users = 6;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool recording_allowed = 7;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.recording_allowed_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\25\0\14\0\0\0\0\0"
    "NoxProto.ServerConfig"
    "welcome_text"
  }},
};
PROTOBUF_NOINLINE void ServerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.ServerConfig)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.welcome_text_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000007eu) != 0) {
    ::memset(&_impl_.max_bandwidth_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_users_) -
        reinterpret_cast<char*>(&_impl_.max_bandwidth_)) + sizeof(_impl_.max_users_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ServerConfig::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ServerConfig& this_ = static_cast<const ServerConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ServerConfig::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ServerConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.ServerConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 max_bandwidth = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_max_bandwidth(), target);
  }

  // optional string welcome_text = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_welcome_text();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.ServerConfig.welcome_text");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional bool allow_html = 3;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_allow_html(), target);
  }

  // optional uint32 message_length = 4;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_message_length(), target);
  }

  // optional uint32 image_message_length = 5;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_image_message_length(), target);
  }

  // optional uint32 max_users = 6;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_max_users(), target);
  }

  // optional bool recording_allowed = 7;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_recording_allowed(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.ServerConfig)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ServerConfig::ByteSizeLong(const MessageLite& base) {
  const ServerConfig& this_ = static_cast<const ServerConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ServerConfig::ByteSizeLong() const {
  const ServerConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.ServerConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000030u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000004fu) != 0) {
    // optional string welcome_text = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_welcome_text());
    }
    // optional uint32 max_bandwidth = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_bandwidth());
    }
    // optional uint32 message_length = 4;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_message_length());
    }
    // optional uint32 image_message_length = 5;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_image_message_length());
    }
    // optional uint32 max_users = 6;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_users());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ServerConfig::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ServerConfig*>(&to_msg);
  auto& from = static_cast<const ServerConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.ServerConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_welcome_text(from._internal_welcome_text());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.max_bandwidth_ = from._impl_.max_bandwidth_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.message_length_ = from._impl_.message_length_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.image_message_length_ = from._impl_.image_message_length_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.allow_html_ = from._impl_.allow_html_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.recording_allowed_ = from._impl_.recording_allowed_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.max_users_ = from._impl_.max_users_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ServerConfig::CopyFrom(const ServerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.ServerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ServerConfig::InternalSwap(ServerConfig* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.welcome_text_, &other->_impl_.welcome_text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_)
      + sizeof(ServerConfig::_impl_.max_users_)
      - PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_)>(
          reinterpret_cast<char*>(&_impl_.max_bandwidth_),
          reinterpret_cast<char*>(&other->_impl_.max_bandwidth_));
}

::google::protobuf::Metadata ServerConfig::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SuggestConfig::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SuggestConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._has_bits_);
};

SuggestConfig::SuggestConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SuggestConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.SuggestConfig)
}
SuggestConfig::SuggestConfig(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SuggestConfig& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SuggestConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE SuggestConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void SuggestConfig::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, version_v1_),
           0,
           offsetof(Impl_, version_v2_) -
               offsetof(Impl_, version_v1_) +
               sizeof(Impl_::version_v2_));
}
SuggestConfig::~SuggestConfig() {
  // @@protoc_insertion_point(destructor:NoxProto.SuggestConfig)
  SharedDtor(*this);
}
inline void SuggestConfig::SharedDtor(MessageLite& self) {
  SuggestConfig& this_ = static_cast<SuggestConfig&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SuggestConfig::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SuggestConfig(arena);
}
constexpr auto SuggestConfig::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(SuggestConfig),
                                            alignof(SuggestConfig));
}
constexpr auto SuggestConfig::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SuggestConfig_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SuggestConfig::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SuggestConfig>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SuggestConfig::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SuggestConfig>(), &SuggestConfig::ByteSizeLong,
              &SuggestConfig::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._cached_size_),
          false,
      },
      &SuggestConfig::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SuggestConfig_class_data_ =
        SuggestConfig::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SuggestConfig::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SuggestConfig_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SuggestConfig_class_data_.tc_table);
  return SuggestConfig_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
SuggestConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SuggestConfig_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::SuggestConfig>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 version_v2 = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SuggestConfig, _impl_.version_v2_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v2_)}},
    // optional uint32 version_v1 = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SuggestConfig, _impl_.version_v1_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v1_)}},
    // optional bool positional = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SuggestConfig, _impl_.positional_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.positional_)}},
    // optional bool push_to_talk = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SuggestConfig, _impl_.push_to_talk_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.push_to_talk_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 version_v1 = 1;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v1_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool positional = 2;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.positional_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool push_to_talk = 3;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.push_to_talk_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint64 version_v2 = 4;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v2_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SuggestConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.SuggestConfig)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    ::memset(&_impl_.version_v1_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.version_v2_) -
        reinterpret_cast<char*>(&_impl_.version_v1_)) + sizeof(_impl_.version_v2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SuggestConfig::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SuggestConfig& this_ = static_cast<const SuggestConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SuggestConfig::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SuggestConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.SuggestConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 version_v1 = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_version_v1(), target);
  }

  // optional bool positional = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_positional(), target);
  }

  // optional bool push_to_talk = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_push_to_talk(), target);
  }

  // optional uint64 version_v2 = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_version_v2(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.SuggestConfig)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SuggestConfig::ByteSizeLong(const MessageLite& base) {
  const SuggestConfig& this_ = static_cast<const SuggestConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SuggestConfig::ByteSizeLong() const {
  const SuggestConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.SuggestConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000006u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x00000009u) != 0) {
    // optional uint32 version_v1 = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_version_v1());
    }
    // optional uint64 version_v2 = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_version_v2());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SuggestConfig::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SuggestConfig*>(&to_msg);
  auto& from = static_cast<const SuggestConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.SuggestConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.version_v1_ = from._impl_.version_v1_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.positional_ = from._impl_.positional_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.push_to_talk_ = from._impl_.push_to_talk_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.version_v2_ = from._impl_.version_v2_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SuggestConfig::CopyFrom(const SuggestConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.SuggestConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SuggestConfig::InternalSwap(SuggestConfig* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v2_)
      + sizeof(SuggestConfig::_impl_.version_v2_)
      - PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_v1_)>(
          reinterpret_cast<char*>(&_impl_.version_v1_),
          reinterpret_cast<char*>(&other->_impl_.version_v1_));
}

::google::protobuf::Metadata SuggestConfig::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PluginDataTransmission::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PluginDataTransmission>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_._has_bits_);
};

PluginDataTransmission::PluginDataTransmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PluginDataTransmission_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NoxProto.PluginDataTransmission)
}
PROTOBUF_NDEBUG_INLINE PluginDataTransmission::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::NoxProto::PluginDataTransmission& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        receiversessions_{visibility, arena, from.receiversessions_},
        _receiversessions_cached_byte_size_{0},
        data_(arena, from.data_),
        dataid_(arena, from.dataid_) {}

PluginDataTransmission::PluginDataTransmission(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PluginDataTransmission& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PluginDataTransmission_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PluginDataTransmission* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.sendersession_ = from._impl_.sendersession_;

  // @@protoc_insertion_point(copy_constructor:NoxProto.PluginDataTransmission)
}
PROTOBUF_NDEBUG_INLINE PluginDataTransmission::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        receiversessions_{visibility, arena},
        _receiversessions_cached_byte_size_{0},
        data_(arena),
        dataid_(arena) {}

inline void PluginDataTransmission::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.sendersession_ = {};
}
PluginDataTransmission::~PluginDataTransmission() {
  // @@protoc_insertion_point(destructor:NoxProto.PluginDataTransmission)
  SharedDtor(*this);
}
inline void PluginDataTransmission::SharedDtor(MessageLite& self) {
  PluginDataTransmission& this_ = static_cast<PluginDataTransmission&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.data_.Destroy();
  this_._impl_.dataid_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PluginDataTransmission::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PluginDataTransmission(arena);
}
constexpr auto PluginDataTransmission::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.receiversessions_) +
          decltype(PluginDataTransmission::_impl_.receiversessions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(PluginDataTransmission), alignof(PluginDataTransmission), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PluginDataTransmission::PlacementNew_,
                                 sizeof(PluginDataTransmission),
                                 alignof(PluginDataTransmission));
  }
}
constexpr auto PluginDataTransmission::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PluginDataTransmission_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PluginDataTransmission::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PluginDataTransmission>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PluginDataTransmission::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PluginDataTransmission>(), &PluginDataTransmission::ByteSizeLong,
              &PluginDataTransmission::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_._cached_size_),
          false,
      },
      &PluginDataTransmission::kDescriptorMethods,
      &descriptor_table_Nox_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PluginDataTransmission_class_data_ =
        PluginDataTransmission::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PluginDataTransmission::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PluginDataTransmission_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PluginDataTransmission_class_data_.tc_table);
  return PluginDataTransmission_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 46, 2>
PluginDataTransmission::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PluginDataTransmission_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::NoxProto::PluginDataTransmission>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string dataID = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.dataid_)}},
    // optional uint32 senderSession = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PluginDataTransmission, _impl_.sendersession_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.sendersession_)}},
    // repeated uint32 receiverSessions = 2 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.receiversessions_)}},
    // optional bytes data = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 senderSession = 1;
    {PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.sendersession_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated uint32 receiverSessions = 2 [packed = true];
    {PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.receiversessions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // optional bytes data = 3;
    {PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.data_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string dataID = 4;
    {PROTOBUF_FIELD_OFFSET(PluginDataTransmission, _impl_.dataid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\37\0\0\0\6\0\0\0"
    "NoxProto.PluginDataTransmission"
    "dataID"
  }},
};
PROTOBUF_NOINLINE void PluginDataTransmission::Clear() {
// @@protoc_insertion_point(message_clear_start:NoxProto.PluginDataTransmission)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.receiversessions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.dataid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.sendersession_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PluginDataTransmission::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PluginDataTransmission& this_ = static_cast<const PluginDataTransmission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PluginDataTransmission::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PluginDataTransmission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:NoxProto.PluginDataTransmission)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 senderSession = 1;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_sendersession(), target);
  }

  // repeated uint32 receiverSessions = 2 [packed = true];
  {
    int byte_size = this_._impl_._receiversessions_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, this_._internal_receiversessions(), byte_size, target);
    }
  }

  // optional bytes data = 3;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_data();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional string dataID = 4;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_dataid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NoxProto.PluginDataTransmission.dataID");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NoxProto.PluginDataTransmission)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PluginDataTransmission::ByteSizeLong(const MessageLite& base) {
  const PluginDataTransmission& this_ = static_cast<const PluginDataTransmission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PluginDataTransmission::ByteSizeLong() const {
  const PluginDataTransmission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:NoxProto.PluginDataTransmission)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 receiverSessions = 2 [packed = true];
    {
      total_size +=
          ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
              this_._internal_receiversessions(), 1,
              this_._impl_._receiversessions_cached_byte_size_);
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // optional bytes data = 3;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_data());
    }
    // optional string dataID = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_dataid());
    }
    // optional uint32 senderSession = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_sendersession());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PluginDataTransmission::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PluginDataTransmission*>(&to_msg);
  auto& from = static_cast<const PluginDataTransmission&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NoxProto.PluginDataTransmission)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_receiversessions()->MergeFrom(from._internal_receiversessions());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_data(from._internal_data());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_dataid(from._internal_dataid());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.sendersession_ = from._impl_.sendersession_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PluginDataTransmission::CopyFrom(const PluginDataTransmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NoxProto.PluginDataTransmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PluginDataTransmission::InternalSwap(PluginDataTransmission* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.receiversessions_.InternalSwap(&other->_impl_.receiversessions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.data_, &other->_impl_.data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dataid_, &other->_impl_.dataid_, arena);
  swap(_impl_.sendersession_, other->_impl_.sendersession_);
}

::google::protobuf::Metadata PluginDataTransmission::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace NoxProto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_Nox_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
