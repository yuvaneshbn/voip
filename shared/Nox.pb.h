// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Nox.proto
// Protobuf C++ Version: 6.31.1

#ifndef Nox_2eproto_2epb_2eh
#define Nox_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Nox_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Nox_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_Nox_2eproto;
}  // extern "C"
namespace NoxProto {
enum ContextActionModify_Context : int;
extern const uint32_t ContextActionModify_Context_internal_data_[];
enum ContextActionModify_Operation : int;
extern const uint32_t ContextActionModify_Operation_internal_data_[];
enum PermissionDenied_DenyType : int;
extern const uint32_t PermissionDenied_DenyType_internal_data_[];
enum Reject_RejectType : int;
extern const uint32_t Reject_RejectType_internal_data_[];
class ACL;
struct ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ACL_class_data_;
class ACL_ChanACL;
struct ACL_ChanACLDefaultTypeInternal;
extern ACL_ChanACLDefaultTypeInternal _ACL_ChanACL_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ACL_ChanACL_class_data_;
class ACL_ChanGroup;
struct ACL_ChanGroupDefaultTypeInternal;
extern ACL_ChanGroupDefaultTypeInternal _ACL_ChanGroup_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ACL_ChanGroup_class_data_;
class Authenticate;
struct AuthenticateDefaultTypeInternal;
extern AuthenticateDefaultTypeInternal _Authenticate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Authenticate_class_data_;
class BanList;
struct BanListDefaultTypeInternal;
extern BanListDefaultTypeInternal _BanList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BanList_class_data_;
class BanList_BanEntry;
struct BanList_BanEntryDefaultTypeInternal;
extern BanList_BanEntryDefaultTypeInternal _BanList_BanEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BanList_BanEntry_class_data_;
class ChannelRemove;
struct ChannelRemoveDefaultTypeInternal;
extern ChannelRemoveDefaultTypeInternal _ChannelRemove_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChannelRemove_class_data_;
class ChannelState;
struct ChannelStateDefaultTypeInternal;
extern ChannelStateDefaultTypeInternal _ChannelState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChannelState_class_data_;
class CodecVersion;
struct CodecVersionDefaultTypeInternal;
extern CodecVersionDefaultTypeInternal _CodecVersion_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CodecVersion_class_data_;
class ContextAction;
struct ContextActionDefaultTypeInternal;
extern ContextActionDefaultTypeInternal _ContextAction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ContextAction_class_data_;
class ContextActionModify;
struct ContextActionModifyDefaultTypeInternal;
extern ContextActionModifyDefaultTypeInternal _ContextActionModify_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ContextActionModify_class_data_;
class CryptSetup;
struct CryptSetupDefaultTypeInternal;
extern CryptSetupDefaultTypeInternal _CryptSetup_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CryptSetup_class_data_;
class PermissionDenied;
struct PermissionDeniedDefaultTypeInternal;
extern PermissionDeniedDefaultTypeInternal _PermissionDenied_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PermissionDenied_class_data_;
class PermissionQuery;
struct PermissionQueryDefaultTypeInternal;
extern PermissionQueryDefaultTypeInternal _PermissionQuery_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PermissionQuery_class_data_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
class PluginDataTransmission;
struct PluginDataTransmissionDefaultTypeInternal;
extern PluginDataTransmissionDefaultTypeInternal _PluginDataTransmission_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PluginDataTransmission_class_data_;
class QueryUsers;
struct QueryUsersDefaultTypeInternal;
extern QueryUsersDefaultTypeInternal _QueryUsers_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QueryUsers_class_data_;
class Reject;
struct RejectDefaultTypeInternal;
extern RejectDefaultTypeInternal _Reject_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Reject_class_data_;
class RequestBlob;
struct RequestBlobDefaultTypeInternal;
extern RequestBlobDefaultTypeInternal _RequestBlob_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RequestBlob_class_data_;
class ServerConfig;
struct ServerConfigDefaultTypeInternal;
extern ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerConfig_class_data_;
class ServerSync;
struct ServerSyncDefaultTypeInternal;
extern ServerSyncDefaultTypeInternal _ServerSync_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerSync_class_data_;
class SuggestConfig;
struct SuggestConfigDefaultTypeInternal;
extern SuggestConfigDefaultTypeInternal _SuggestConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SuggestConfig_class_data_;
class TextMessage;
struct TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TextMessage_class_data_;
class UDPTunnel;
struct UDPTunnelDefaultTypeInternal;
extern UDPTunnelDefaultTypeInternal _UDPTunnel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UDPTunnel_class_data_;
class UserList;
struct UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserList_class_data_;
class UserList_User;
struct UserList_UserDefaultTypeInternal;
extern UserList_UserDefaultTypeInternal _UserList_User_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserList_User_class_data_;
class UserRemove;
struct UserRemoveDefaultTypeInternal;
extern UserRemoveDefaultTypeInternal _UserRemove_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserRemove_class_data_;
class UserState;
struct UserStateDefaultTypeInternal;
extern UserStateDefaultTypeInternal _UserState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserState_class_data_;
class UserState_VolumeAdjustment;
struct UserState_VolumeAdjustmentDefaultTypeInternal;
extern UserState_VolumeAdjustmentDefaultTypeInternal _UserState_VolumeAdjustment_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserState_VolumeAdjustment_class_data_;
class UserStats;
struct UserStatsDefaultTypeInternal;
extern UserStatsDefaultTypeInternal _UserStats_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserStats_class_data_;
class UserStats_RollingStats;
struct UserStats_RollingStatsDefaultTypeInternal;
extern UserStats_RollingStatsDefaultTypeInternal _UserStats_RollingStats_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserStats_RollingStats_class_data_;
class UserStats_Stats;
struct UserStats_StatsDefaultTypeInternal;
extern UserStats_StatsDefaultTypeInternal _UserStats_Stats_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserStats_Stats_class_data_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Version_class_data_;
class VoiceTarget;
struct VoiceTargetDefaultTypeInternal;
extern VoiceTargetDefaultTypeInternal _VoiceTarget_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VoiceTarget_class_data_;
class VoiceTarget_Target;
struct VoiceTarget_TargetDefaultTypeInternal;
extern VoiceTarget_TargetDefaultTypeInternal _VoiceTarget_Target_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VoiceTarget_Target_class_data_;
}  // namespace NoxProto
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::NoxProto::ContextActionModify_Context_internal_data_>
    internal::EnumTraitsImpl::value<::NoxProto::ContextActionModify_Context>;
template <>
internal::EnumTraitsT<::NoxProto::ContextActionModify_Operation_internal_data_>
    internal::EnumTraitsImpl::value<::NoxProto::ContextActionModify_Operation>;
template <>
internal::EnumTraitsT<::NoxProto::PermissionDenied_DenyType_internal_data_>
    internal::EnumTraitsImpl::value<::NoxProto::PermissionDenied_DenyType>;
template <>
internal::EnumTraitsT<::NoxProto::Reject_RejectType_internal_data_>
    internal::EnumTraitsImpl::value<::NoxProto::Reject_RejectType>;
}  // namespace protobuf
}  // namespace google

namespace NoxProto {
enum Reject_RejectType : int {
  Reject_RejectType_None = 0,
  Reject_RejectType_WrongVersion = 1,
  Reject_RejectType_InvalidUsername = 2,
  Reject_RejectType_WrongUserPW = 3,
  Reject_RejectType_WrongServerPW = 4,
  Reject_RejectType_UsernameInUse = 5,
  Reject_RejectType_ServerFull = 6,
  Reject_RejectType_NoCertificate = 7,
  Reject_RejectType_AuthenticatorFail = 8,
  Reject_RejectType_NoNewConnections = 9,
};

extern const uint32_t Reject_RejectType_internal_data_[];
inline constexpr Reject_RejectType Reject_RejectType_RejectType_MIN =
    static_cast<Reject_RejectType>(0);
inline constexpr Reject_RejectType Reject_RejectType_RejectType_MAX =
    static_cast<Reject_RejectType>(9);
inline bool Reject_RejectType_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Reject_RejectType_RejectType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Reject_RejectType_descriptor();
template <typename T>
const ::std::string& Reject_RejectType_Name(T value) {
  static_assert(::std::is_same<T, Reject_RejectType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RejectType_Name().");
  return Reject_RejectType_Name(static_cast<Reject_RejectType>(value));
}
template <>
inline const ::std::string& Reject_RejectType_Name(Reject_RejectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Reject_RejectType_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Reject_RejectType_Parse(
    ::absl::string_view name, Reject_RejectType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reject_RejectType>(Reject_RejectType_descriptor(), name,
                                           value);
}
enum PermissionDenied_DenyType : int {
  PermissionDenied_DenyType_Text = 0,
  PermissionDenied_DenyType_Permission = 1,
  PermissionDenied_DenyType_SuperUser = 2,
  PermissionDenied_DenyType_ChannelName = 3,
  PermissionDenied_DenyType_TextTooLong = 4,
  PermissionDenied_DenyType_H9K = 5,
  PermissionDenied_DenyType_TemporaryChannel = 6,
  PermissionDenied_DenyType_MissingCertificate = 7,
  PermissionDenied_DenyType_UserName = 8,
  PermissionDenied_DenyType_ChannelFull = 9,
  PermissionDenied_DenyType_NestingLimit = 10,
  PermissionDenied_DenyType_ChannelCountLimit = 11,
  PermissionDenied_DenyType_ChannelListenerLimit = 12,
  PermissionDenied_DenyType_UserListenerLimit = 13,
};

extern const uint32_t PermissionDenied_DenyType_internal_data_[];
inline constexpr PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN =
    static_cast<PermissionDenied_DenyType>(0);
inline constexpr PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX =
    static_cast<PermissionDenied_DenyType>(13);
inline bool PermissionDenied_DenyType_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int PermissionDenied_DenyType_DenyType_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PermissionDenied_DenyType_descriptor();
template <typename T>
const ::std::string& PermissionDenied_DenyType_Name(T value) {
  static_assert(::std::is_same<T, PermissionDenied_DenyType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DenyType_Name().");
  return PermissionDenied_DenyType_Name(static_cast<PermissionDenied_DenyType>(value));
}
template <>
inline const ::std::string& PermissionDenied_DenyType_Name(PermissionDenied_DenyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PermissionDenied_DenyType_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool PermissionDenied_DenyType_Parse(
    ::absl::string_view name, PermissionDenied_DenyType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PermissionDenied_DenyType>(PermissionDenied_DenyType_descriptor(), name,
                                           value);
}
enum ContextActionModify_Context : int {
  ContextActionModify_Context_Server = 1,
  ContextActionModify_Context_Channel = 2,
  ContextActionModify_Context_User = 4,
};

extern const uint32_t ContextActionModify_Context_internal_data_[];
inline constexpr ContextActionModify_Context ContextActionModify_Context_Context_MIN =
    static_cast<ContextActionModify_Context>(1);
inline constexpr ContextActionModify_Context ContextActionModify_Context_Context_MAX =
    static_cast<ContextActionModify_Context>(4);
inline bool ContextActionModify_Context_IsValid(int value) {
  return 0 <= value && value <= 4 && ((22u >> value) & 1) != 0;
}
inline constexpr int ContextActionModify_Context_Context_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Context_descriptor();
template <typename T>
const ::std::string& ContextActionModify_Context_Name(T value) {
  static_assert(::std::is_same<T, ContextActionModify_Context>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Context_Name().");
  return ContextActionModify_Context_Name(static_cast<ContextActionModify_Context>(value));
}
template <>
inline const ::std::string& ContextActionModify_Context_Name(ContextActionModify_Context value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContextActionModify_Context_descriptor, 1, 4>(
      static_cast<int>(value));
}
inline bool ContextActionModify_Context_Parse(
    ::absl::string_view name, ContextActionModify_Context* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Context>(ContextActionModify_Context_descriptor(), name,
                                           value);
}
enum ContextActionModify_Operation : int {
  ContextActionModify_Operation_Add = 0,
  ContextActionModify_Operation_Remove = 1,
};

extern const uint32_t ContextActionModify_Operation_internal_data_[];
inline constexpr ContextActionModify_Operation ContextActionModify_Operation_Operation_MIN =
    static_cast<ContextActionModify_Operation>(0);
inline constexpr ContextActionModify_Operation ContextActionModify_Operation_Operation_MAX =
    static_cast<ContextActionModify_Operation>(1);
inline bool ContextActionModify_Operation_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ContextActionModify_Operation_Operation_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Operation_descriptor();
template <typename T>
const ::std::string& ContextActionModify_Operation_Name(T value) {
  static_assert(::std::is_same<T, ContextActionModify_Operation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Operation_Name().");
  return ContextActionModify_Operation_Name(static_cast<ContextActionModify_Operation>(value));
}
template <>
inline const ::std::string& ContextActionModify_Operation_Name(ContextActionModify_Operation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContextActionModify_Operation_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ContextActionModify_Operation_Parse(
    ::absl::string_view name, ContextActionModify_Operation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Operation>(ContextActionModify_Operation_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoiceTarget_Target final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.VoiceTarget.Target) */ {
 public:
  inline VoiceTarget_Target() : VoiceTarget_Target(nullptr) {}
  ~VoiceTarget_Target() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VoiceTarget_Target* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VoiceTarget_Target));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoiceTarget_Target(::google::protobuf::internal::ConstantInitialized);

  inline VoiceTarget_Target(const VoiceTarget_Target& from) : VoiceTarget_Target(nullptr, from) {}
  inline VoiceTarget_Target(VoiceTarget_Target&& from) noexcept
      : VoiceTarget_Target(nullptr, ::std::move(from)) {}
  inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceTarget_Target& operator=(VoiceTarget_Target&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceTarget_Target& default_instance() {
    return *reinterpret_cast<const VoiceTarget_Target*>(
        &_VoiceTarget_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(VoiceTarget_Target& a, VoiceTarget_Target& b) { a.Swap(&b); }
  inline void Swap(VoiceTarget_Target* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceTarget_Target* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceTarget_Target* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VoiceTarget_Target>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoiceTarget_Target& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoiceTarget_Target& from) { VoiceTarget_Target::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VoiceTarget_Target* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.VoiceTarget.Target"; }

 protected:
  explicit VoiceTarget_Target(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VoiceTarget_Target(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VoiceTarget_Target& from);
  VoiceTarget_Target(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VoiceTarget_Target&& from) noexcept
      : VoiceTarget_Target(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionFieldNumber = 1,
    kGroupFieldNumber = 3,
    kChannelIdFieldNumber = 2,
    kLinksFieldNumber = 4,
    kChildrenFieldNumber = 5,
  };
  // repeated uint32 session = 1;
  int session_size() const;
  private:
  int _internal_session_size() const;

  public:
  void clear_session() ;
  ::uint32_t session(int index) const;
  void set_session(int index, ::uint32_t value);
  void add_session(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& session() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_session();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_session() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_session();

  public:
  // optional string group = 3;
  bool has_group() const;
  void clear_group() ;
  const ::std::string& group() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group();
  void set_allocated_group(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group();

  public:
  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional bool links = 4 [default = false];
  bool has_links() const;
  void clear_links() ;
  bool links() const;
  void set_links(bool value);

  private:
  bool _internal_links() const;
  void _internal_set_links(bool value);

  public:
  // optional bool children = 5 [default = false];
  bool has_children() const;
  void clear_children() ;
  bool children() const;
  void set_children(bool value);

  private:
  bool _internal_children() const;
  void _internal_set_children(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.VoiceTarget.Target)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VoiceTarget_Target& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> session_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::uint32_t channel_id_;
    bool links_;
    bool children_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VoiceTarget_Target_class_data_;
// -------------------------------------------------------------------

class Version final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Version* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Version));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Version(::google::protobuf::internal::ConstantInitialized);

  inline Version(const Version& from) : Version(nullptr, from) {}
  inline Version(Version&& from) noexcept
      : Version(nullptr, ::std::move(from)) {}
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *reinterpret_cast<const Version*>(
        &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Version& a, Version& b) { a.Swap(&b); }
  inline void Swap(Version* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Version>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Version& from) { Version::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Version* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.Version"; }

 protected:
  explicit Version(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Version(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Version& from);
  Version(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Version&& from) noexcept
      : Version(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReleaseFieldNumber = 2,
    kOsFieldNumber = 3,
    kOsVersionFieldNumber = 4,
    kVersionV2FieldNumber = 5,
    kVersionV1FieldNumber = 1,
  };
  // optional string release = 2;
  bool has_release() const;
  void clear_release() ;
  const ::std::string& release() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_release(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_release();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_release();
  void set_allocated_release(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_release() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_release(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_release();

  public:
  // optional string os = 3;
  bool has_os() const;
  void clear_os() ;
  const ::std::string& os() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_os(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_os();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_os();
  void set_allocated_os(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_os() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_os(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_os();

  public:
  // optional string os_version = 4;
  bool has_os_version() const;
  void clear_os_version() ;
  const ::std::string& os_version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_os_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_os_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_os_version();
  void set_allocated_os_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_os_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_os_version();

  public:
  // optional uint64 version_v2 = 5;
  bool has_version_v2() const;
  void clear_version_v2() ;
  ::uint64_t version_v2() const;
  void set_version_v2(::uint64_t value);

  private:
  ::uint64_t _internal_version_v2() const;
  void _internal_set_version_v2(::uint64_t value);

  public:
  // optional uint32 version_v1 = 1;
  bool has_version_v1() const;
  void clear_version_v1() ;
  ::uint32_t version_v1() const;
  void set_version_v1(::uint32_t value);

  private:
  ::uint32_t _internal_version_v1() const;
  void _internal_set_version_v1(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.Version)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Version& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr release_;
    ::google::protobuf::internal::ArenaStringPtr os_;
    ::google::protobuf::internal::ArenaStringPtr os_version_;
    ::uint64_t version_v2_;
    ::uint32_t version_v1_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Version_class_data_;
// -------------------------------------------------------------------

class UserStats_Stats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserStats.Stats) */ {
 public:
  inline UserStats_Stats() : UserStats_Stats(nullptr) {}
  ~UserStats_Stats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserStats_Stats* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserStats_Stats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserStats_Stats(::google::protobuf::internal::ConstantInitialized);

  inline UserStats_Stats(const UserStats_Stats& from) : UserStats_Stats(nullptr, from) {}
  inline UserStats_Stats(UserStats_Stats&& from) noexcept
      : UserStats_Stats(nullptr, ::std::move(from)) {}
  inline UserStats_Stats& operator=(const UserStats_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStats_Stats& operator=(UserStats_Stats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStats_Stats& default_instance() {
    return *reinterpret_cast<const UserStats_Stats*>(
        &_UserStats_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(UserStats_Stats& a, UserStats_Stats& b) { a.Swap(&b); }
  inline void Swap(UserStats_Stats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStats_Stats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStats_Stats* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserStats_Stats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserStats_Stats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserStats_Stats& from) { UserStats_Stats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserStats_Stats* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserStats.Stats"; }

 protected:
  explicit UserStats_Stats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserStats_Stats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserStats_Stats& from);
  UserStats_Stats(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserStats_Stats&& from) noexcept
      : UserStats_Stats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGoodFieldNumber = 1,
    kLateFieldNumber = 2,
    kLostFieldNumber = 3,
    kResyncFieldNumber = 4,
  };
  // optional uint32 good = 1;
  bool has_good() const;
  void clear_good() ;
  ::uint32_t good() const;
  void set_good(::uint32_t value);

  private:
  ::uint32_t _internal_good() const;
  void _internal_set_good(::uint32_t value);

  public:
  // optional uint32 late = 2;
  bool has_late() const;
  void clear_late() ;
  ::uint32_t late() const;
  void set_late(::uint32_t value);

  private:
  ::uint32_t _internal_late() const;
  void _internal_set_late(::uint32_t value);

  public:
  // optional uint32 lost = 3;
  bool has_lost() const;
  void clear_lost() ;
  ::uint32_t lost() const;
  void set_lost(::uint32_t value);

  private:
  ::uint32_t _internal_lost() const;
  void _internal_set_lost(::uint32_t value);

  public:
  // optional uint32 resync = 4;
  bool has_resync() const;
  void clear_resync() ;
  ::uint32_t resync() const;
  void set_resync(::uint32_t value);

  private:
  ::uint32_t _internal_resync() const;
  void _internal_set_resync(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserStats.Stats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserStats_Stats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t good_;
    ::uint32_t late_;
    ::uint32_t lost_;
    ::uint32_t resync_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserStats_Stats_class_data_;
// -------------------------------------------------------------------

class UserState_VolumeAdjustment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserState.VolumeAdjustment) */ {
 public:
  inline UserState_VolumeAdjustment() : UserState_VolumeAdjustment(nullptr) {}
  ~UserState_VolumeAdjustment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserState_VolumeAdjustment* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserState_VolumeAdjustment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserState_VolumeAdjustment(::google::protobuf::internal::ConstantInitialized);

  inline UserState_VolumeAdjustment(const UserState_VolumeAdjustment& from) : UserState_VolumeAdjustment(nullptr, from) {}
  inline UserState_VolumeAdjustment(UserState_VolumeAdjustment&& from) noexcept
      : UserState_VolumeAdjustment(nullptr, ::std::move(from)) {}
  inline UserState_VolumeAdjustment& operator=(const UserState_VolumeAdjustment& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserState_VolumeAdjustment& operator=(UserState_VolumeAdjustment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserState_VolumeAdjustment& default_instance() {
    return *reinterpret_cast<const UserState_VolumeAdjustment*>(
        &_UserState_VolumeAdjustment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UserState_VolumeAdjustment& a, UserState_VolumeAdjustment& b) { a.Swap(&b); }
  inline void Swap(UserState_VolumeAdjustment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserState_VolumeAdjustment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserState_VolumeAdjustment* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserState_VolumeAdjustment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserState_VolumeAdjustment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserState_VolumeAdjustment& from) { UserState_VolumeAdjustment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserState_VolumeAdjustment* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserState.VolumeAdjustment"; }

 protected:
  explicit UserState_VolumeAdjustment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserState_VolumeAdjustment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserState_VolumeAdjustment& from);
  UserState_VolumeAdjustment(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserState_VolumeAdjustment&& from) noexcept
      : UserState_VolumeAdjustment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kListeningChannelFieldNumber = 1,
    kVolumeAdjustmentFieldNumber = 2,
  };
  // optional uint32 listening_channel = 1;
  bool has_listening_channel() const;
  void clear_listening_channel() ;
  ::uint32_t listening_channel() const;
  void set_listening_channel(::uint32_t value);

  private:
  ::uint32_t _internal_listening_channel() const;
  void _internal_set_listening_channel(::uint32_t value);

  public:
  // optional float volume_adjustment = 2;
  bool has_volume_adjustment() const;
  void clear_volume_adjustment() ;
  float volume_adjustment() const;
  void set_volume_adjustment(float value);

  private:
  float _internal_volume_adjustment() const;
  void _internal_set_volume_adjustment(float value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserState.VolumeAdjustment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserState_VolumeAdjustment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t listening_channel_;
    float volume_adjustment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserState_VolumeAdjustment_class_data_;
// -------------------------------------------------------------------

class UserRemove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserRemove) */ {
 public:
  inline UserRemove() : UserRemove(nullptr) {}
  ~UserRemove() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserRemove* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserRemove));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserRemove(::google::protobuf::internal::ConstantInitialized);

  inline UserRemove(const UserRemove& from) : UserRemove(nullptr, from) {}
  inline UserRemove(UserRemove&& from) noexcept
      : UserRemove(nullptr, ::std::move(from)) {}
  inline UserRemove& operator=(const UserRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRemove& operator=(UserRemove&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRemove& default_instance() {
    return *reinterpret_cast<const UserRemove*>(
        &_UserRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UserRemove& a, UserRemove& b) { a.Swap(&b); }
  inline void Swap(UserRemove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRemove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRemove* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserRemove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserRemove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserRemove& from) { UserRemove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserRemove* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserRemove"; }

 protected:
  explicit UserRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserRemove& from);
  UserRemove(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserRemove&& from) noexcept
      : UserRemove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 3,
    kSessionFieldNumber = 1,
    kActorFieldNumber = 2,
    kBanFieldNumber = 4,
    kBanCertificateFieldNumber = 5,
    kBanIpFieldNumber = 6,
  };
  // optional string reason = 3;
  bool has_reason() const;
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // required uint32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional uint32 actor = 2;
  bool has_actor() const;
  void clear_actor() ;
  ::uint32_t actor() const;
  void set_actor(::uint32_t value);

  private:
  ::uint32_t _internal_actor() const;
  void _internal_set_actor(::uint32_t value);

  public:
  // optional bool ban = 4;
  bool has_ban() const;
  void clear_ban() ;
  bool ban() const;
  void set_ban(bool value);

  private:
  bool _internal_ban() const;
  void _internal_set_ban(bool value);

  public:
  // optional bool ban_certificate = 5;
  bool has_ban_certificate() const;
  void clear_ban_certificate() ;
  bool ban_certificate() const;
  void set_ban_certificate(bool value);

  private:
  bool _internal_ban_certificate() const;
  void _internal_set_ban_certificate(bool value);

  public:
  // optional bool ban_ip = 6;
  bool has_ban_ip() const;
  void clear_ban_ip() ;
  bool ban_ip() const;
  void set_ban_ip(bool value);

  private:
  bool _internal_ban_ip() const;
  void _internal_set_ban_ip(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserRemove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserRemove& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::uint32_t session_;
    ::uint32_t actor_;
    bool ban_;
    bool ban_certificate_;
    bool ban_ip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserRemove_class_data_;
// -------------------------------------------------------------------

class UserList_User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserList.User) */ {
 public:
  inline UserList_User() : UserList_User(nullptr) {}
  ~UserList_User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserList_User* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserList_User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserList_User(::google::protobuf::internal::ConstantInitialized);

  inline UserList_User(const UserList_User& from) : UserList_User(nullptr, from) {}
  inline UserList_User(UserList_User&& from) noexcept
      : UserList_User(nullptr, ::std::move(from)) {}
  inline UserList_User& operator=(const UserList_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList_User& operator=(UserList_User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserList_User& default_instance() {
    return *reinterpret_cast<const UserList_User*>(
        &_UserList_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(UserList_User& a, UserList_User& b) { a.Swap(&b); }
  inline void Swap(UserList_User* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList_User* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList_User* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserList_User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserList_User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserList_User& from) { UserList_User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserList_User* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserList.User"; }

 protected:
  explicit UserList_User(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserList_User(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserList_User& from);
  UserList_User(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserList_User&& from) noexcept
      : UserList_User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kLastSeenFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kLastChannelFieldNumber = 4,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional string last_seen = 3;
  bool has_last_seen() const;
  void clear_last_seen() ;
  const ::std::string& last_seen() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_last_seen(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_last_seen();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_last_seen();
  void set_allocated_last_seen(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_last_seen() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_last_seen(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_last_seen();

  public:
  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id() ;
  ::uint32_t user_id() const;
  void set_user_id(::uint32_t value);

  private:
  ::uint32_t _internal_user_id() const;
  void _internal_set_user_id(::uint32_t value);

  public:
  // optional uint32 last_channel = 4;
  bool has_last_channel() const;
  void clear_last_channel() ;
  ::uint32_t last_channel() const;
  void set_last_channel(::uint32_t value);

  private:
  ::uint32_t _internal_last_channel() const;
  void _internal_set_last_channel(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserList.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserList_User& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr last_seen_;
    ::uint32_t user_id_;
    ::uint32_t last_channel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserList_User_class_data_;
// -------------------------------------------------------------------

class UDPTunnel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UDPTunnel) */ {
 public:
  inline UDPTunnel() : UDPTunnel(nullptr) {}
  ~UDPTunnel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UDPTunnel* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UDPTunnel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UDPTunnel(::google::protobuf::internal::ConstantInitialized);

  inline UDPTunnel(const UDPTunnel& from) : UDPTunnel(nullptr, from) {}
  inline UDPTunnel(UDPTunnel&& from) noexcept
      : UDPTunnel(nullptr, ::std::move(from)) {}
  inline UDPTunnel& operator=(const UDPTunnel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDPTunnel& operator=(UDPTunnel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDPTunnel& default_instance() {
    return *reinterpret_cast<const UDPTunnel*>(
        &_UDPTunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UDPTunnel& a, UDPTunnel& b) { a.Swap(&b); }
  inline void Swap(UDPTunnel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDPTunnel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDPTunnel* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UDPTunnel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UDPTunnel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UDPTunnel& from) { UDPTunnel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UDPTunnel* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UDPTunnel"; }

 protected:
  explicit UDPTunnel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UDPTunnel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UDPTunnel& from);
  UDPTunnel(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UDPTunnel&& from) noexcept
      : UDPTunnel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPacketFieldNumber = 1,
  };
  // required bytes packet = 1;
  bool has_packet() const;
  void clear_packet() ;
  const ::std::string& packet() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_packet(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_packet();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_packet();
  void set_allocated_packet(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_packet() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_packet(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_packet();

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UDPTunnel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UDPTunnel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr packet_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UDPTunnel_class_data_;
// -------------------------------------------------------------------

class TextMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.TextMessage) */ {
 public:
  inline TextMessage() : TextMessage(nullptr) {}
  ~TextMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TextMessage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TextMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TextMessage(::google::protobuf::internal::ConstantInitialized);

  inline TextMessage(const TextMessage& from) : TextMessage(nullptr, from) {}
  inline TextMessage(TextMessage&& from) noexcept
      : TextMessage(nullptr, ::std::move(from)) {}
  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextMessage& operator=(TextMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextMessage& default_instance() {
    return *reinterpret_cast<const TextMessage*>(
        &_TextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TextMessage& a, TextMessage& b) { a.Swap(&b); }
  inline void Swap(TextMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TextMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TextMessage& from) { TextMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TextMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.TextMessage"; }

 protected:
  explicit TextMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TextMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TextMessage& from);
  TextMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TextMessage&& from) noexcept
      : TextMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionFieldNumber = 2,
    kChannelIdFieldNumber = 3,
    kTreeIdFieldNumber = 4,
    kMessageFieldNumber = 5,
    kActorFieldNumber = 1,
  };
  // repeated uint32 session = 2;
  int session_size() const;
  private:
  int _internal_session_size() const;

  public:
  void clear_session() ;
  ::uint32_t session(int index) const;
  void set_session(int index, ::uint32_t value);
  void add_session(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& session() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_session();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_session() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_session();

  public:
  // repeated uint32 channel_id = 3;
  int channel_id_size() const;
  private:
  int _internal_channel_id_size() const;

  public:
  void clear_channel_id() ;
  ::uint32_t channel_id(int index) const;
  void set_channel_id(int index, ::uint32_t value);
  void add_channel_id(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& channel_id() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_channel_id();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_channel_id() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_channel_id();

  public:
  // repeated uint32 tree_id = 4;
  int tree_id_size() const;
  private:
  int _internal_tree_id_size() const;

  public:
  void clear_tree_id() ;
  ::uint32_t tree_id(int index) const;
  void set_tree_id(int index, ::uint32_t value);
  void add_tree_id(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& tree_id() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_tree_id();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_tree_id() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_tree_id();

  public:
  // required string message = 5;
  bool has_message() const;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // optional uint32 actor = 1;
  bool has_actor() const;
  void clear_actor() ;
  ::uint32_t actor() const;
  void set_actor(::uint32_t value);

  private:
  ::uint32_t _internal_actor() const;
  void _internal_set_actor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.TextMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TextMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> session_;
    ::google::protobuf::RepeatedField<::uint32_t> channel_id_;
    ::google::protobuf::RepeatedField<::uint32_t> tree_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint32_t actor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TextMessage_class_data_;
// -------------------------------------------------------------------

class SuggestConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.SuggestConfig) */ {
 public:
  inline SuggestConfig() : SuggestConfig(nullptr) {}
  ~SuggestConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SuggestConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SuggestConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestConfig(::google::protobuf::internal::ConstantInitialized);

  inline SuggestConfig(const SuggestConfig& from) : SuggestConfig(nullptr, from) {}
  inline SuggestConfig(SuggestConfig&& from) noexcept
      : SuggestConfig(nullptr, ::std::move(from)) {}
  inline SuggestConfig& operator=(const SuggestConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestConfig& operator=(SuggestConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestConfig& default_instance() {
    return *reinterpret_cast<const SuggestConfig*>(
        &_SuggestConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(SuggestConfig& a, SuggestConfig& b) { a.Swap(&b); }
  inline void Swap(SuggestConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SuggestConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SuggestConfig& from) { SuggestConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SuggestConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.SuggestConfig"; }

 protected:
  explicit SuggestConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SuggestConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SuggestConfig& from);
  SuggestConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SuggestConfig&& from) noexcept
      : SuggestConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionV1FieldNumber = 1,
    kPositionalFieldNumber = 2,
    kPushToTalkFieldNumber = 3,
    kVersionV2FieldNumber = 4,
  };
  // optional uint32 version_v1 = 1;
  bool has_version_v1() const;
  void clear_version_v1() ;
  ::uint32_t version_v1() const;
  void set_version_v1(::uint32_t value);

  private:
  ::uint32_t _internal_version_v1() const;
  void _internal_set_version_v1(::uint32_t value);

  public:
  // optional bool positional = 2;
  bool has_positional() const;
  void clear_positional() ;
  bool positional() const;
  void set_positional(bool value);

  private:
  bool _internal_positional() const;
  void _internal_set_positional(bool value);

  public:
  // optional bool push_to_talk = 3;
  bool has_push_to_talk() const;
  void clear_push_to_talk() ;
  bool push_to_talk() const;
  void set_push_to_talk(bool value);

  private:
  bool _internal_push_to_talk() const;
  void _internal_set_push_to_talk(bool value);

  public:
  // optional uint64 version_v2 = 4;
  bool has_version_v2() const;
  void clear_version_v2() ;
  ::uint64_t version_v2() const;
  void set_version_v2(::uint64_t value);

  private:
  ::uint64_t _internal_version_v2() const;
  void _internal_set_version_v2(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.SuggestConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SuggestConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t version_v1_;
    bool positional_;
    bool push_to_talk_;
    ::uint64_t version_v2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SuggestConfig_class_data_;
// -------------------------------------------------------------------

class ServerSync final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ServerSync) */ {
 public:
  inline ServerSync() : ServerSync(nullptr) {}
  ~ServerSync() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerSync* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerSync));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerSync(::google::protobuf::internal::ConstantInitialized);

  inline ServerSync(const ServerSync& from) : ServerSync(nullptr, from) {}
  inline ServerSync(ServerSync&& from) noexcept
      : ServerSync(nullptr, ::std::move(from)) {}
  inline ServerSync& operator=(const ServerSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerSync& operator=(ServerSync&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerSync& default_instance() {
    return *reinterpret_cast<const ServerSync*>(
        &_ServerSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ServerSync& a, ServerSync& b) { a.Swap(&b); }
  inline void Swap(ServerSync* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerSync* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerSync* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerSync>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerSync& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerSync& from) { ServerSync::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerSync* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ServerSync"; }

 protected:
  explicit ServerSync(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerSync(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerSync& from);
  ServerSync(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerSync&& from) noexcept
      : ServerSync(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWelcomeTextFieldNumber = 3,
    kSessionFieldNumber = 1,
    kMaxBandwidthFieldNumber = 2,
    kPermissionsFieldNumber = 4,
  };
  // optional string welcome_text = 3;
  bool has_welcome_text() const;
  void clear_welcome_text() ;
  const ::std::string& welcome_text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_welcome_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_welcome_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_welcome_text();
  void set_allocated_welcome_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_welcome_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_welcome_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_welcome_text();

  public:
  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional uint32 max_bandwidth = 2;
  bool has_max_bandwidth() const;
  void clear_max_bandwidth() ;
  ::uint32_t max_bandwidth() const;
  void set_max_bandwidth(::uint32_t value);

  private:
  ::uint32_t _internal_max_bandwidth() const;
  void _internal_set_max_bandwidth(::uint32_t value);

  public:
  // optional uint64 permissions = 4;
  bool has_permissions() const;
  void clear_permissions() ;
  ::uint64_t permissions() const;
  void set_permissions(::uint64_t value);

  private:
  ::uint64_t _internal_permissions() const;
  void _internal_set_permissions(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ServerSync)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ServerSync& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr welcome_text_;
    ::uint32_t session_;
    ::uint32_t max_bandwidth_;
    ::uint64_t permissions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerSync_class_data_;
// -------------------------------------------------------------------

class ServerConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ServerConfig) */ {
 public:
  inline ServerConfig() : ServerConfig(nullptr) {}
  ~ServerConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerConfig(::google::protobuf::internal::ConstantInitialized);

  inline ServerConfig(const ServerConfig& from) : ServerConfig(nullptr, from) {}
  inline ServerConfig(ServerConfig&& from) noexcept
      : ServerConfig(nullptr, ::std::move(from)) {}
  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerConfig& operator=(ServerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerConfig& default_instance() {
    return *reinterpret_cast<const ServerConfig*>(
        &_ServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ServerConfig& a, ServerConfig& b) { a.Swap(&b); }
  inline void Swap(ServerConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerConfig& from) { ServerConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ServerConfig"; }

 protected:
  explicit ServerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerConfig& from);
  ServerConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerConfig&& from) noexcept
      : ServerConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWelcomeTextFieldNumber = 2,
    kMaxBandwidthFieldNumber = 1,
    kMessageLengthFieldNumber = 4,
    kImageMessageLengthFieldNumber = 5,
    kAllowHtmlFieldNumber = 3,
    kRecordingAllowedFieldNumber = 7,
    kMaxUsersFieldNumber = 6,
  };
  // optional string welcome_text = 2;
  bool has_welcome_text() const;
  void clear_welcome_text() ;
  const ::std::string& welcome_text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_welcome_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_welcome_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_welcome_text();
  void set_allocated_welcome_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_welcome_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_welcome_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_welcome_text();

  public:
  // optional uint32 max_bandwidth = 1;
  bool has_max_bandwidth() const;
  void clear_max_bandwidth() ;
  ::uint32_t max_bandwidth() const;
  void set_max_bandwidth(::uint32_t value);

  private:
  ::uint32_t _internal_max_bandwidth() const;
  void _internal_set_max_bandwidth(::uint32_t value);

  public:
  // optional uint32 message_length = 4;
  bool has_message_length() const;
  void clear_message_length() ;
  ::uint32_t message_length() const;
  void set_message_length(::uint32_t value);

  private:
  ::uint32_t _internal_message_length() const;
  void _internal_set_message_length(::uint32_t value);

  public:
  // optional uint32 image_message_length = 5;
  bool has_image_message_length() const;
  void clear_image_message_length() ;
  ::uint32_t image_message_length() const;
  void set_image_message_length(::uint32_t value);

  private:
  ::uint32_t _internal_image_message_length() const;
  void _internal_set_image_message_length(::uint32_t value);

  public:
  // optional bool allow_html = 3;
  bool has_allow_html() const;
  void clear_allow_html() ;
  bool allow_html() const;
  void set_allow_html(bool value);

  private:
  bool _internal_allow_html() const;
  void _internal_set_allow_html(bool value);

  public:
  // optional bool recording_allowed = 7;
  bool has_recording_allowed() const;
  void clear_recording_allowed() ;
  bool recording_allowed() const;
  void set_recording_allowed(bool value);

  private:
  bool _internal_recording_allowed() const;
  void _internal_set_recording_allowed(bool value);

  public:
  // optional uint32 max_users = 6;
  bool has_max_users() const;
  void clear_max_users() ;
  ::uint32_t max_users() const;
  void set_max_users(::uint32_t value);

  private:
  ::uint32_t _internal_max_users() const;
  void _internal_set_max_users(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ServerConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ServerConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr welcome_text_;
    ::uint32_t max_bandwidth_;
    ::uint32_t message_length_;
    ::uint32_t image_message_length_;
    bool allow_html_;
    bool recording_allowed_;
    ::uint32_t max_users_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerConfig_class_data_;
// -------------------------------------------------------------------

class RequestBlob final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.RequestBlob) */ {
 public:
  inline RequestBlob() : RequestBlob(nullptr) {}
  ~RequestBlob() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RequestBlob* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RequestBlob));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RequestBlob(::google::protobuf::internal::ConstantInitialized);

  inline RequestBlob(const RequestBlob& from) : RequestBlob(nullptr, from) {}
  inline RequestBlob(RequestBlob&& from) noexcept
      : RequestBlob(nullptr, ::std::move(from)) {}
  inline RequestBlob& operator=(const RequestBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBlob& operator=(RequestBlob&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBlob& default_instance() {
    return *reinterpret_cast<const RequestBlob*>(
        &_RequestBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(RequestBlob& a, RequestBlob& b) { a.Swap(&b); }
  inline void Swap(RequestBlob* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBlob* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBlob* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RequestBlob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestBlob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RequestBlob& from) { RequestBlob::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RequestBlob* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.RequestBlob"; }

 protected:
  explicit RequestBlob(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RequestBlob(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RequestBlob& from);
  RequestBlob(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RequestBlob&& from) noexcept
      : RequestBlob(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionTextureFieldNumber = 1,
    kSessionCommentFieldNumber = 2,
    kChannelDescriptionFieldNumber = 3,
  };
  // repeated uint32 session_texture = 1;
  int session_texture_size() const;
  private:
  int _internal_session_texture_size() const;

  public:
  void clear_session_texture() ;
  ::uint32_t session_texture(int index) const;
  void set_session_texture(int index, ::uint32_t value);
  void add_session_texture(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& session_texture() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_session_texture();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_session_texture() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_session_texture();

  public:
  // repeated uint32 session_comment = 2;
  int session_comment_size() const;
  private:
  int _internal_session_comment_size() const;

  public:
  void clear_session_comment() ;
  ::uint32_t session_comment(int index) const;
  void set_session_comment(int index, ::uint32_t value);
  void add_session_comment(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& session_comment() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_session_comment();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_session_comment() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_session_comment();

  public:
  // repeated uint32 channel_description = 3;
  int channel_description_size() const;
  private:
  int _internal_channel_description_size() const;

  public:
  void clear_channel_description() ;
  ::uint32_t channel_description(int index) const;
  void set_channel_description(int index, ::uint32_t value);
  void add_channel_description(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& channel_description() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_channel_description();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_channel_description() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_channel_description();

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.RequestBlob)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RequestBlob& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> session_texture_;
    ::google::protobuf::RepeatedField<::uint32_t> session_comment_;
    ::google::protobuf::RepeatedField<::uint32_t> channel_description_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RequestBlob_class_data_;
// -------------------------------------------------------------------

class Reject final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.Reject) */ {
 public:
  inline Reject() : Reject(nullptr) {}
  ~Reject() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Reject* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Reject));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Reject(::google::protobuf::internal::ConstantInitialized);

  inline Reject(const Reject& from) : Reject(nullptr, from) {}
  inline Reject(Reject&& from) noexcept
      : Reject(nullptr, ::std::move(from)) {}
  inline Reject& operator=(const Reject& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reject& operator=(Reject&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reject& default_instance() {
    return *reinterpret_cast<const Reject*>(
        &_Reject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Reject& a, Reject& b) { a.Swap(&b); }
  inline void Swap(Reject* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reject* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reject* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Reject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Reject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Reject& from) { Reject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Reject* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.Reject"; }

 protected:
  explicit Reject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Reject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Reject& from);
  Reject(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Reject&& from) noexcept
      : Reject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RejectType = Reject_RejectType;
  static constexpr RejectType None = Reject_RejectType_None;
  static constexpr RejectType WrongVersion = Reject_RejectType_WrongVersion;
  static constexpr RejectType InvalidUsername = Reject_RejectType_InvalidUsername;
  static constexpr RejectType WrongUserPW = Reject_RejectType_WrongUserPW;
  static constexpr RejectType WrongServerPW = Reject_RejectType_WrongServerPW;
  static constexpr RejectType UsernameInUse = Reject_RejectType_UsernameInUse;
  static constexpr RejectType ServerFull = Reject_RejectType_ServerFull;
  static constexpr RejectType NoCertificate = Reject_RejectType_NoCertificate;
  static constexpr RejectType AuthenticatorFail = Reject_RejectType_AuthenticatorFail;
  static constexpr RejectType NoNewConnections = Reject_RejectType_NoNewConnections;
  static inline bool RejectType_IsValid(int value) {
    return Reject_RejectType_IsValid(value);
  }
  static constexpr RejectType RejectType_MIN = Reject_RejectType_RejectType_MIN;
  static constexpr RejectType RejectType_MAX = Reject_RejectType_RejectType_MAX;
  static constexpr int RejectType_ARRAYSIZE = Reject_RejectType_RejectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RejectType_descriptor() {
    return Reject_RejectType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& RejectType_Name(T value) {
    return Reject_RejectType_Name(value);
  }
  static inline bool RejectType_Parse(
      ::absl::string_view name, RejectType* PROTOBUF_NONNULL value) {
    return Reject_RejectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string reason = 2;
  bool has_reason() const;
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // optional .NoxProto.Reject.RejectType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::NoxProto::Reject_RejectType type() const;
  void set_type(::NoxProto::Reject_RejectType value);

  private:
  ::NoxProto::Reject_RejectType _internal_type() const;
  void _internal_set_type(::NoxProto::Reject_RejectType value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.Reject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 30,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Reject& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Reject_class_data_;
// -------------------------------------------------------------------

class QueryUsers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.QueryUsers) */ {
 public:
  inline QueryUsers() : QueryUsers(nullptr) {}
  ~QueryUsers() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueryUsers* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueryUsers));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryUsers(::google::protobuf::internal::ConstantInitialized);

  inline QueryUsers(const QueryUsers& from) : QueryUsers(nullptr, from) {}
  inline QueryUsers(QueryUsers&& from) noexcept
      : QueryUsers(nullptr, ::std::move(from)) {}
  inline QueryUsers& operator=(const QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUsers& operator=(QueryUsers&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUsers& default_instance() {
    return *reinterpret_cast<const QueryUsers*>(
        &_QueryUsers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(QueryUsers& a, QueryUsers& b) { a.Swap(&b); }
  inline void Swap(QueryUsers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUsers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUsers* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueryUsers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryUsers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryUsers& from) { QueryUsers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueryUsers* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.QueryUsers"; }

 protected:
  explicit QueryUsers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QueryUsers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueryUsers& from);
  QueryUsers(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QueryUsers&& from) noexcept
      : QueryUsers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdsFieldNumber = 1,
    kNamesFieldNumber = 2,
  };
  // repeated uint32 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  ::uint32_t ids(int index) const;
  void set_ids(int index, ::uint32_t value);
  void add_ids(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& ids() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_ids();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_ids() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_ids();

  public:
  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const ::std::string& names(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_names(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_names();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_names();

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.QueryUsers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QueryUsers& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> ids_;
    ::google::protobuf::RepeatedPtrField<::std::string> names_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QueryUsers_class_data_;
// -------------------------------------------------------------------

class PluginDataTransmission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.PluginDataTransmission) */ {
 public:
  inline PluginDataTransmission() : PluginDataTransmission(nullptr) {}
  ~PluginDataTransmission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PluginDataTransmission* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PluginDataTransmission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PluginDataTransmission(::google::protobuf::internal::ConstantInitialized);

  inline PluginDataTransmission(const PluginDataTransmission& from) : PluginDataTransmission(nullptr, from) {}
  inline PluginDataTransmission(PluginDataTransmission&& from) noexcept
      : PluginDataTransmission(nullptr, ::std::move(from)) {}
  inline PluginDataTransmission& operator=(const PluginDataTransmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginDataTransmission& operator=(PluginDataTransmission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginDataTransmission& default_instance() {
    return *reinterpret_cast<const PluginDataTransmission*>(
        &_PluginDataTransmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(PluginDataTransmission& a, PluginDataTransmission& b) { a.Swap(&b); }
  inline void Swap(PluginDataTransmission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginDataTransmission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginDataTransmission* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PluginDataTransmission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginDataTransmission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PluginDataTransmission& from) { PluginDataTransmission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PluginDataTransmission* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.PluginDataTransmission"; }

 protected:
  explicit PluginDataTransmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PluginDataTransmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PluginDataTransmission& from);
  PluginDataTransmission(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PluginDataTransmission&& from) noexcept
      : PluginDataTransmission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReceiverSessionsFieldNumber = 2,
    kDataFieldNumber = 3,
    kDataIDFieldNumber = 4,
    kSenderSessionFieldNumber = 1,
  };
  // repeated uint32 receiverSessions = 2 [packed = true];
  int receiversessions_size() const;
  private:
  int _internal_receiversessions_size() const;

  public:
  void clear_receiversessions() ;
  ::uint32_t receiversessions(int index) const;
  void set_receiversessions(int index, ::uint32_t value);
  void add_receiversessions(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& receiversessions() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_receiversessions();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_receiversessions() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_receiversessions();

  public:
  // optional bytes data = 3;
  bool has_data() const;
  void clear_data() ;
  const ::std::string& data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data();
  void set_allocated_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // optional string dataID = 4;
  bool has_dataid() const;
  void clear_dataid() ;
  const ::std::string& dataid() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dataid(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dataid();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dataid();
  void set_allocated_dataid(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dataid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dataid(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dataid();

  public:
  // optional uint32 senderSession = 1;
  bool has_sendersession() const;
  void clear_sendersession() ;
  ::uint32_t sendersession() const;
  void set_sendersession(::uint32_t value);

  private:
  ::uint32_t _internal_sendersession() const;
  void _internal_set_sendersession(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.PluginDataTransmission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PluginDataTransmission& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> receiversessions_;
    ::google::protobuf::internal::CachedSize _receiversessions_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr dataid_;
    ::uint32_t sendersession_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PluginDataTransmission_class_data_;
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Ping* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, ::std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Ping* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Ping& from);
  Ping(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
    kGoodFieldNumber = 2,
    kLateFieldNumber = 3,
    kLostFieldNumber = 4,
    kResyncFieldNumber = 5,
    kUdpPacketsFieldNumber = 6,
    kTcpPacketsFieldNumber = 7,
    kUdpPingAvgFieldNumber = 8,
    kUdpPingVarFieldNumber = 9,
    kTcpPingAvgFieldNumber = 10,
    kTcpPingVarFieldNumber = 11,
  };
  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional uint32 good = 2;
  bool has_good() const;
  void clear_good() ;
  ::uint32_t good() const;
  void set_good(::uint32_t value);

  private:
  ::uint32_t _internal_good() const;
  void _internal_set_good(::uint32_t value);

  public:
  // optional uint32 late = 3;
  bool has_late() const;
  void clear_late() ;
  ::uint32_t late() const;
  void set_late(::uint32_t value);

  private:
  ::uint32_t _internal_late() const;
  void _internal_set_late(::uint32_t value);

  public:
  // optional uint32 lost = 4;
  bool has_lost() const;
  void clear_lost() ;
  ::uint32_t lost() const;
  void set_lost(::uint32_t value);

  private:
  ::uint32_t _internal_lost() const;
  void _internal_set_lost(::uint32_t value);

  public:
  // optional uint32 resync = 5;
  bool has_resync() const;
  void clear_resync() ;
  ::uint32_t resync() const;
  void set_resync(::uint32_t value);

  private:
  ::uint32_t _internal_resync() const;
  void _internal_set_resync(::uint32_t value);

  public:
  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  void clear_udp_packets() ;
  ::uint32_t udp_packets() const;
  void set_udp_packets(::uint32_t value);

  private:
  ::uint32_t _internal_udp_packets() const;
  void _internal_set_udp_packets(::uint32_t value);

  public:
  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  void clear_tcp_packets() ;
  ::uint32_t tcp_packets() const;
  void set_tcp_packets(::uint32_t value);

  private:
  ::uint32_t _internal_tcp_packets() const;
  void _internal_set_tcp_packets(::uint32_t value);

  public:
  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  void clear_udp_ping_avg() ;
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);

  private:
  float _internal_udp_ping_avg() const;
  void _internal_set_udp_ping_avg(float value);

  public:
  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  void clear_udp_ping_var() ;
  float udp_ping_var() const;
  void set_udp_ping_var(float value);

  private:
  float _internal_udp_ping_var() const;
  void _internal_set_udp_ping_var(float value);

  public:
  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  void clear_tcp_ping_avg() ;
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);

  private:
  float _internal_tcp_ping_avg() const;
  void _internal_set_tcp_ping_avg(float value);

  public:
  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  void clear_tcp_ping_var() ;
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);

  private:
  float _internal_tcp_ping_var() const;
  void _internal_set_tcp_ping_var(float value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Ping& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t timestamp_;
    ::uint32_t good_;
    ::uint32_t late_;
    ::uint32_t lost_;
    ::uint32_t resync_;
    ::uint32_t udp_packets_;
    ::uint32_t tcp_packets_;
    float udp_ping_avg_;
    float udp_ping_var_;
    float tcp_ping_avg_;
    float tcp_ping_var_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
// -------------------------------------------------------------------

class PermissionQuery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.PermissionQuery) */ {
 public:
  inline PermissionQuery() : PermissionQuery(nullptr) {}
  ~PermissionQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PermissionQuery* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PermissionQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PermissionQuery(::google::protobuf::internal::ConstantInitialized);

  inline PermissionQuery(const PermissionQuery& from) : PermissionQuery(nullptr, from) {}
  inline PermissionQuery(PermissionQuery&& from) noexcept
      : PermissionQuery(nullptr, ::std::move(from)) {}
  inline PermissionQuery& operator=(const PermissionQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionQuery& operator=(PermissionQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionQuery& default_instance() {
    return *reinterpret_cast<const PermissionQuery*>(
        &_PermissionQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(PermissionQuery& a, PermissionQuery& b) { a.Swap(&b); }
  inline void Swap(PermissionQuery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionQuery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionQuery* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PermissionQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PermissionQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PermissionQuery& from) { PermissionQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PermissionQuery* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.PermissionQuery"; }

 protected:
  explicit PermissionQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PermissionQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PermissionQuery& from);
  PermissionQuery(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PermissionQuery&& from) noexcept
      : PermissionQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelIdFieldNumber = 1,
    kPermissionsFieldNumber = 2,
    kFlushFieldNumber = 3,
  };
  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional uint32 permissions = 2;
  bool has_permissions() const;
  void clear_permissions() ;
  ::uint32_t permissions() const;
  void set_permissions(::uint32_t value);

  private:
  ::uint32_t _internal_permissions() const;
  void _internal_set_permissions(::uint32_t value);

  public:
  // optional bool flush = 3 [default = false];
  bool has_flush() const;
  void clear_flush() ;
  bool flush() const;
  void set_flush(bool value);

  private:
  bool _internal_flush() const;
  void _internal_set_flush(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.PermissionQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PermissionQuery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t channel_id_;
    ::uint32_t permissions_;
    bool flush_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PermissionQuery_class_data_;
// -------------------------------------------------------------------

class PermissionDenied final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.PermissionDenied) */ {
 public:
  inline PermissionDenied() : PermissionDenied(nullptr) {}
  ~PermissionDenied() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PermissionDenied* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PermissionDenied));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PermissionDenied(::google::protobuf::internal::ConstantInitialized);

  inline PermissionDenied(const PermissionDenied& from) : PermissionDenied(nullptr, from) {}
  inline PermissionDenied(PermissionDenied&& from) noexcept
      : PermissionDenied(nullptr, ::std::move(from)) {}
  inline PermissionDenied& operator=(const PermissionDenied& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionDenied& operator=(PermissionDenied&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionDenied& default_instance() {
    return *reinterpret_cast<const PermissionDenied*>(
        &_PermissionDenied_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(PermissionDenied& a, PermissionDenied& b) { a.Swap(&b); }
  inline void Swap(PermissionDenied* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionDenied* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionDenied* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PermissionDenied>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PermissionDenied& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PermissionDenied& from) { PermissionDenied::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PermissionDenied* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.PermissionDenied"; }

 protected:
  explicit PermissionDenied(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PermissionDenied(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PermissionDenied& from);
  PermissionDenied(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PermissionDenied&& from) noexcept
      : PermissionDenied(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DenyType = PermissionDenied_DenyType;
  static constexpr DenyType Text = PermissionDenied_DenyType_Text;
  static constexpr DenyType Permission = PermissionDenied_DenyType_Permission;
  static constexpr DenyType SuperUser = PermissionDenied_DenyType_SuperUser;
  static constexpr DenyType ChannelName = PermissionDenied_DenyType_ChannelName;
  static constexpr DenyType TextTooLong = PermissionDenied_DenyType_TextTooLong;
  static constexpr DenyType H9K = PermissionDenied_DenyType_H9K;
  static constexpr DenyType TemporaryChannel = PermissionDenied_DenyType_TemporaryChannel;
  static constexpr DenyType MissingCertificate = PermissionDenied_DenyType_MissingCertificate;
  static constexpr DenyType UserName = PermissionDenied_DenyType_UserName;
  static constexpr DenyType ChannelFull = PermissionDenied_DenyType_ChannelFull;
  static constexpr DenyType NestingLimit = PermissionDenied_DenyType_NestingLimit;
  static constexpr DenyType ChannelCountLimit = PermissionDenied_DenyType_ChannelCountLimit;
  static constexpr DenyType ChannelListenerLimit = PermissionDenied_DenyType_ChannelListenerLimit;
  static constexpr DenyType UserListenerLimit = PermissionDenied_DenyType_UserListenerLimit;
  static inline bool DenyType_IsValid(int value) {
    return PermissionDenied_DenyType_IsValid(value);
  }
  static constexpr DenyType DenyType_MIN = PermissionDenied_DenyType_DenyType_MIN;
  static constexpr DenyType DenyType_MAX = PermissionDenied_DenyType_DenyType_MAX;
  static constexpr int DenyType_ARRAYSIZE = PermissionDenied_DenyType_DenyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DenyType_descriptor() {
    return PermissionDenied_DenyType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& DenyType_Name(T value) {
    return PermissionDenied_DenyType_Name(value);
  }
  static inline bool DenyType_Parse(
      ::absl::string_view name, DenyType* PROTOBUF_NONNULL value) {
    return PermissionDenied_DenyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 4,
    kNameFieldNumber = 6,
    kPermissionFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kSessionFieldNumber = 3,
    kTypeFieldNumber = 5,
  };
  // optional string reason = 4;
  bool has_reason() const;
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // optional string name = 6;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional uint32 permission = 1;
  bool has_permission() const;
  void clear_permission() ;
  ::uint32_t permission() const;
  void set_permission(::uint32_t value);

  private:
  ::uint32_t _internal_permission() const;
  void _internal_set_permission(::uint32_t value);

  public:
  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional uint32 session = 3;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional .NoxProto.PermissionDenied.DenyType type = 5;
  bool has_type() const;
  void clear_type() ;
  ::NoxProto::PermissionDenied_DenyType type() const;
  void set_type(::NoxProto::PermissionDenied_DenyType value);

  private:
  ::NoxProto::PermissionDenied_DenyType _internal_type() const;
  void _internal_set_type(::NoxProto::PermissionDenied_DenyType value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.PermissionDenied)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PermissionDenied& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t permission_;
    ::uint32_t channel_id_;
    ::uint32_t session_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PermissionDenied_class_data_;
// -------------------------------------------------------------------

class CryptSetup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.CryptSetup) */ {
 public:
  inline CryptSetup() : CryptSetup(nullptr) {}
  ~CryptSetup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CryptSetup* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CryptSetup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CryptSetup(::google::protobuf::internal::ConstantInitialized);

  inline CryptSetup(const CryptSetup& from) : CryptSetup(nullptr, from) {}
  inline CryptSetup(CryptSetup&& from) noexcept
      : CryptSetup(nullptr, ::std::move(from)) {}
  inline CryptSetup& operator=(const CryptSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptSetup& operator=(CryptSetup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptSetup& default_instance() {
    return *reinterpret_cast<const CryptSetup*>(
        &_CryptSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(CryptSetup& a, CryptSetup& b) { a.Swap(&b); }
  inline void Swap(CryptSetup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptSetup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptSetup* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CryptSetup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CryptSetup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CryptSetup& from) { CryptSetup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CryptSetup* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.CryptSetup"; }

 protected:
  explicit CryptSetup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CryptSetup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CryptSetup& from);
  CryptSetup(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CryptSetup&& from) noexcept
      : CryptSetup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kClientNonceFieldNumber = 2,
    kServerNonceFieldNumber = 3,
  };
  // optional bytes key = 1;
  bool has_key() const;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional bytes client_nonce = 2;
  bool has_client_nonce() const;
  void clear_client_nonce() ;
  const ::std::string& client_nonce() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_client_nonce(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_client_nonce();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_client_nonce();
  void set_allocated_client_nonce(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_client_nonce() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_client_nonce(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_client_nonce();

  public:
  // optional bytes server_nonce = 3;
  bool has_server_nonce() const;
  void clear_server_nonce() ;
  const ::std::string& server_nonce() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_server_nonce(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_server_nonce();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_server_nonce();
  void set_allocated_server_nonce(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_server_nonce() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_server_nonce(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_server_nonce();

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.CryptSetup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CryptSetup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr client_nonce_;
    ::google::protobuf::internal::ArenaStringPtr server_nonce_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CryptSetup_class_data_;
// -------------------------------------------------------------------

class ContextActionModify final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ContextActionModify) */ {
 public:
  inline ContextActionModify() : ContextActionModify(nullptr) {}
  ~ContextActionModify() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContextActionModify* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContextActionModify));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContextActionModify(::google::protobuf::internal::ConstantInitialized);

  inline ContextActionModify(const ContextActionModify& from) : ContextActionModify(nullptr, from) {}
  inline ContextActionModify(ContextActionModify&& from) noexcept
      : ContextActionModify(nullptr, ::std::move(from)) {}
  inline ContextActionModify& operator=(const ContextActionModify& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextActionModify& operator=(ContextActionModify&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextActionModify& default_instance() {
    return *reinterpret_cast<const ContextActionModify*>(
        &_ContextActionModify_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ContextActionModify& a, ContextActionModify& b) { a.Swap(&b); }
  inline void Swap(ContextActionModify* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextActionModify* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextActionModify* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContextActionModify>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContextActionModify& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContextActionModify& from) { ContextActionModify::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContextActionModify* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ContextActionModify"; }

 protected:
  explicit ContextActionModify(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ContextActionModify(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ContextActionModify& from);
  ContextActionModify(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ContextActionModify&& from) noexcept
      : ContextActionModify(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Context = ContextActionModify_Context;
  static constexpr Context Server = ContextActionModify_Context_Server;
  static constexpr Context Channel = ContextActionModify_Context_Channel;
  static constexpr Context User = ContextActionModify_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextActionModify_Context_IsValid(value);
  }
  static constexpr Context Context_MIN = ContextActionModify_Context_Context_MIN;
  static constexpr Context Context_MAX = ContextActionModify_Context_Context_MAX;
  static constexpr int Context_ARRAYSIZE = ContextActionModify_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Context_descriptor() {
    return ContextActionModify_Context_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Context_Name(T value) {
    return ContextActionModify_Context_Name(value);
  }
  static inline bool Context_Parse(
      ::absl::string_view name, Context* PROTOBUF_NONNULL value) {
    return ContextActionModify_Context_Parse(name, value);
  }
  using Operation = ContextActionModify_Operation;
  static constexpr Operation Add = ContextActionModify_Operation_Add;
  static constexpr Operation Remove = ContextActionModify_Operation_Remove;
  static inline bool Operation_IsValid(int value) {
    return ContextActionModify_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN = ContextActionModify_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX = ContextActionModify_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE = ContextActionModify_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Operation_descriptor() {
    return ContextActionModify_Operation_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Operation_Name(T value) {
    return ContextActionModify_Operation_Name(value);
  }
  static inline bool Operation_Parse(
      ::absl::string_view name, Operation* PROTOBUF_NONNULL value) {
    return ContextActionModify_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kActionFieldNumber = 1,
    kTextFieldNumber = 2,
    kContextFieldNumber = 3,
    kOperationFieldNumber = 4,
  };
  // required string action = 1;
  bool has_action() const;
  void clear_action() ;
  const ::std::string& action() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_action();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_action();
  void set_allocated_action(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_action() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_action(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_action();

  public:
  // optional string text = 2;
  bool has_text() const;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // optional uint32 context = 3;
  bool has_context() const;
  void clear_context() ;
  ::uint32_t context() const;
  void set_context(::uint32_t value);

  private:
  ::uint32_t _internal_context() const;
  void _internal_set_context(::uint32_t value);

  public:
  // optional .NoxProto.ContextActionModify.Operation operation = 4;
  bool has_operation() const;
  void clear_operation() ;
  ::NoxProto::ContextActionModify_Operation operation() const;
  void set_operation(::NoxProto::ContextActionModify_Operation value);

  private:
  ::NoxProto::ContextActionModify_Operation _internal_operation() const;
  void _internal_set_operation(::NoxProto::ContextActionModify_Operation value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ContextActionModify)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ContextActionModify& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::uint32_t context_;
    int operation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ContextActionModify_class_data_;
// -------------------------------------------------------------------

class ContextAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ContextAction) */ {
 public:
  inline ContextAction() : ContextAction(nullptr) {}
  ~ContextAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContextAction* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContextAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContextAction(::google::protobuf::internal::ConstantInitialized);

  inline ContextAction(const ContextAction& from) : ContextAction(nullptr, from) {}
  inline ContextAction(ContextAction&& from) noexcept
      : ContextAction(nullptr, ::std::move(from)) {}
  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextAction& operator=(ContextAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextAction& default_instance() {
    return *reinterpret_cast<const ContextAction*>(
        &_ContextAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ContextAction& a, ContextAction& b) { a.Swap(&b); }
  inline void Swap(ContextAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextAction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContextAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContextAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContextAction& from) { ContextAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContextAction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ContextAction"; }

 protected:
  explicit ContextAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ContextAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ContextAction& from);
  ContextAction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ContextAction&& from) noexcept
      : ContextAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionFieldNumber = 3,
    kSessionFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required string action = 3;
  bool has_action() const;
  void clear_action() ;
  const ::std::string& action() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_action();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_action();
  void set_allocated_action(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_action() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_action(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_action();

  public:
  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ContextAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ContextAction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::uint32_t session_;
    ::uint32_t channel_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ContextAction_class_data_;
// -------------------------------------------------------------------

class CodecVersion final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.CodecVersion) */ {
 public:
  inline CodecVersion() : CodecVersion(nullptr) {}
  ~CodecVersion() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CodecVersion* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CodecVersion));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CodecVersion(::google::protobuf::internal::ConstantInitialized);

  inline CodecVersion(const CodecVersion& from) : CodecVersion(nullptr, from) {}
  inline CodecVersion(CodecVersion&& from) noexcept
      : CodecVersion(nullptr, ::std::move(from)) {}
  inline CodecVersion& operator=(const CodecVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodecVersion& operator=(CodecVersion&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodecVersion& default_instance() {
    return *reinterpret_cast<const CodecVersion*>(
        &_CodecVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(CodecVersion& a, CodecVersion& b) { a.Swap(&b); }
  inline void Swap(CodecVersion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodecVersion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodecVersion* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CodecVersion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CodecVersion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CodecVersion& from) { CodecVersion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CodecVersion* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.CodecVersion"; }

 protected:
  explicit CodecVersion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CodecVersion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CodecVersion& from);
  CodecVersion(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CodecVersion&& from) noexcept
      : CodecVersion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlphaFieldNumber = 1,
    kBetaFieldNumber = 2,
    kOpusFieldNumber = 4,
    kPreferAlphaFieldNumber = 3,
  };
  // required int32 alpha = 1;
  bool has_alpha() const;
  void clear_alpha() ;
  ::int32_t alpha() const;
  void set_alpha(::int32_t value);

  private:
  ::int32_t _internal_alpha() const;
  void _internal_set_alpha(::int32_t value);

  public:
  // required int32 beta = 2;
  bool has_beta() const;
  void clear_beta() ;
  ::int32_t beta() const;
  void set_beta(::int32_t value);

  private:
  ::int32_t _internal_beta() const;
  void _internal_set_beta(::int32_t value);

  public:
  // optional bool opus = 4 [default = false];
  bool has_opus() const;
  void clear_opus() ;
  bool opus() const;
  void set_opus(bool value);

  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);

  public:
  // required bool prefer_alpha = 3 [default = true];
  bool has_prefer_alpha() const;
  void clear_prefer_alpha() ;
  bool prefer_alpha() const;
  void set_prefer_alpha(bool value);

  private:
  bool _internal_prefer_alpha() const;
  void _internal_set_prefer_alpha(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.CodecVersion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CodecVersion& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t alpha_;
    ::int32_t beta_;
    bool opus_;
    bool prefer_alpha_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CodecVersion_class_data_;
// -------------------------------------------------------------------

class ChannelState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ChannelState) */ {
 public:
  inline ChannelState() : ChannelState(nullptr) {}
  ~ChannelState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChannelState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChannelState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelState(::google::protobuf::internal::ConstantInitialized);

  inline ChannelState(const ChannelState& from) : ChannelState(nullptr, from) {}
  inline ChannelState(ChannelState&& from) noexcept
      : ChannelState(nullptr, ::std::move(from)) {}
  inline ChannelState& operator=(const ChannelState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelState& operator=(ChannelState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelState& default_instance() {
    return *reinterpret_cast<const ChannelState*>(
        &_ChannelState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ChannelState& a, ChannelState& b) { a.Swap(&b); }
  inline void Swap(ChannelState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChannelState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChannelState& from) { ChannelState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChannelState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ChannelState"; }

 protected:
  explicit ChannelState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChannelState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelState& from);
  ChannelState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChannelState&& from) noexcept
      : ChannelState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinksFieldNumber = 4,
    kLinksAddFieldNumber = 6,
    kLinksRemoveFieldNumber = 7,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 5,
    kDescriptionHashFieldNumber = 10,
    kChannelIdFieldNumber = 1,
    kParentFieldNumber = 2,
    kPositionFieldNumber = 9,
    kMaxUsersFieldNumber = 11,
    kTemporaryFieldNumber = 8,
    kIsEnterRestrictedFieldNumber = 12,
    kCanEnterFieldNumber = 13,
  };
  // repeated uint32 links = 4;
  int links_size() const;
  private:
  int _internal_links_size() const;

  public:
  void clear_links() ;
  ::uint32_t links(int index) const;
  void set_links(int index, ::uint32_t value);
  void add_links(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& links() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_links();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_links() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_links();

  public:
  // repeated uint32 links_add = 6;
  int links_add_size() const;
  private:
  int _internal_links_add_size() const;

  public:
  void clear_links_add() ;
  ::uint32_t links_add(int index) const;
  void set_links_add(int index, ::uint32_t value);
  void add_links_add(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& links_add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_links_add();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_links_add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_links_add();

  public:
  // repeated uint32 links_remove = 7;
  int links_remove_size() const;
  private:
  int _internal_links_remove_size() const;

  public:
  void clear_links_remove() ;
  ::uint32_t links_remove(int index) const;
  void set_links_remove(int index, ::uint32_t value);
  void add_links_remove(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& links_remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_links_remove();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_links_remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_links_remove();

  public:
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional string description = 5;
  bool has_description() const;
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // optional bytes description_hash = 10;
  bool has_description_hash() const;
  void clear_description_hash() ;
  const ::std::string& description_hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description_hash();
  void set_allocated_description_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description_hash();

  public:
  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional uint32 parent = 2;
  bool has_parent() const;
  void clear_parent() ;
  ::uint32_t parent() const;
  void set_parent(::uint32_t value);

  private:
  ::uint32_t _internal_parent() const;
  void _internal_set_parent(::uint32_t value);

  public:
  // optional int32 position = 9 [default = 0];
  bool has_position() const;
  void clear_position() ;
  ::int32_t position() const;
  void set_position(::int32_t value);

  private:
  ::int32_t _internal_position() const;
  void _internal_set_position(::int32_t value);

  public:
  // optional uint32 max_users = 11;
  bool has_max_users() const;
  void clear_max_users() ;
  ::uint32_t max_users() const;
  void set_max_users(::uint32_t value);

  private:
  ::uint32_t _internal_max_users() const;
  void _internal_set_max_users(::uint32_t value);

  public:
  // optional bool temporary = 8 [default = false];
  bool has_temporary() const;
  void clear_temporary() ;
  bool temporary() const;
  void set_temporary(bool value);

  private:
  bool _internal_temporary() const;
  void _internal_set_temporary(bool value);

  public:
  // optional bool is_enter_restricted = 12;
  bool has_is_enter_restricted() const;
  void clear_is_enter_restricted() ;
  bool is_enter_restricted() const;
  void set_is_enter_restricted(bool value);

  private:
  bool _internal_is_enter_restricted() const;
  void _internal_set_is_enter_restricted(bool value);

  public:
  // optional bool can_enter = 13;
  bool has_can_enter() const;
  void clear_can_enter() ;
  bool can_enter() const;
  void set_can_enter(bool value);

  private:
  bool _internal_can_enter() const;
  void _internal_set_can_enter(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ChannelState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChannelState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> links_;
    ::google::protobuf::RepeatedField<::uint32_t> links_add_;
    ::google::protobuf::RepeatedField<::uint32_t> links_remove_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr description_hash_;
    ::uint32_t channel_id_;
    ::uint32_t parent_;
    ::int32_t position_;
    ::uint32_t max_users_;
    bool temporary_;
    bool is_enter_restricted_;
    bool can_enter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChannelState_class_data_;
// -------------------------------------------------------------------

class ChannelRemove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ChannelRemove) */ {
 public:
  inline ChannelRemove() : ChannelRemove(nullptr) {}
  ~ChannelRemove() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChannelRemove* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChannelRemove));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelRemove(::google::protobuf::internal::ConstantInitialized);

  inline ChannelRemove(const ChannelRemove& from) : ChannelRemove(nullptr, from) {}
  inline ChannelRemove(ChannelRemove&& from) noexcept
      : ChannelRemove(nullptr, ::std::move(from)) {}
  inline ChannelRemove& operator=(const ChannelRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelRemove& operator=(ChannelRemove&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelRemove& default_instance() {
    return *reinterpret_cast<const ChannelRemove*>(
        &_ChannelRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ChannelRemove& a, ChannelRemove& b) { a.Swap(&b); }
  inline void Swap(ChannelRemove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelRemove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelRemove* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChannelRemove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelRemove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChannelRemove& from) { ChannelRemove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChannelRemove* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ChannelRemove"; }

 protected:
  explicit ChannelRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChannelRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelRemove& from);
  ChannelRemove(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChannelRemove&& from) noexcept
      : ChannelRemove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ChannelRemove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChannelRemove& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t channel_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChannelRemove_class_data_;
// -------------------------------------------------------------------

class BanList_BanEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.BanList.BanEntry) */ {
 public:
  inline BanList_BanEntry() : BanList_BanEntry(nullptr) {}
  ~BanList_BanEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BanList_BanEntry* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BanList_BanEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BanList_BanEntry(::google::protobuf::internal::ConstantInitialized);

  inline BanList_BanEntry(const BanList_BanEntry& from) : BanList_BanEntry(nullptr, from) {}
  inline BanList_BanEntry(BanList_BanEntry&& from) noexcept
      : BanList_BanEntry(nullptr, ::std::move(from)) {}
  inline BanList_BanEntry& operator=(const BanList_BanEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BanList_BanEntry& operator=(BanList_BanEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BanList_BanEntry& default_instance() {
    return *reinterpret_cast<const BanList_BanEntry*>(
        &_BanList_BanEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(BanList_BanEntry& a, BanList_BanEntry& b) { a.Swap(&b); }
  inline void Swap(BanList_BanEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BanList_BanEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BanList_BanEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BanList_BanEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BanList_BanEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BanList_BanEntry& from) { BanList_BanEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BanList_BanEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.BanList.BanEntry"; }

 protected:
  explicit BanList_BanEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BanList_BanEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BanList_BanEntry& from);
  BanList_BanEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BanList_BanEntry&& from) noexcept
      : BanList_BanEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 1,
    kNameFieldNumber = 3,
    kHashFieldNumber = 4,
    kReasonFieldNumber = 5,
    kStartFieldNumber = 6,
    kMaskFieldNumber = 2,
    kDurationFieldNumber = 7,
  };
  // required bytes address = 1;
  bool has_address() const;
  void clear_address() ;
  const ::std::string& address() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_address();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_address();
  void set_allocated_address(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_address() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_address(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_address();

  public:
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional string hash = 4;
  bool has_hash() const;
  void clear_hash() ;
  const ::std::string& hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hash();
  void set_allocated_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hash();

  public:
  // optional string reason = 5;
  bool has_reason() const;
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // optional string start = 6;
  bool has_start() const;
  void clear_start() ;
  const ::std::string& start() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_start(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_start();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_start();
  void set_allocated_start(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_start() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_start(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_start();

  public:
  // required uint32 mask = 2;
  bool has_mask() const;
  void clear_mask() ;
  ::uint32_t mask() const;
  void set_mask(::uint32_t value);

  private:
  ::uint32_t _internal_mask() const;
  void _internal_set_mask(::uint32_t value);

  public:
  // optional uint32 duration = 7;
  bool has_duration() const;
  void clear_duration() ;
  ::uint32_t duration() const;
  void set_duration(::uint32_t value);

  private:
  ::uint32_t _internal_duration() const;
  void _internal_set_duration(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.BanList.BanEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BanList_BanEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr start_;
    ::uint32_t mask_;
    ::uint32_t duration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BanList_BanEntry_class_data_;
// -------------------------------------------------------------------

class Authenticate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.Authenticate) */ {
 public:
  inline Authenticate() : Authenticate(nullptr) {}
  ~Authenticate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Authenticate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Authenticate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Authenticate(::google::protobuf::internal::ConstantInitialized);

  inline Authenticate(const Authenticate& from) : Authenticate(nullptr, from) {}
  inline Authenticate(Authenticate&& from) noexcept
      : Authenticate(nullptr, ::std::move(from)) {}
  inline Authenticate& operator=(const Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authenticate& operator=(Authenticate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Authenticate& default_instance() {
    return *reinterpret_cast<const Authenticate*>(
        &_Authenticate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Authenticate& a, Authenticate& b) { a.Swap(&b); }
  inline void Swap(Authenticate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Authenticate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Authenticate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Authenticate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Authenticate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Authenticate& from) { Authenticate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Authenticate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.Authenticate"; }

 protected:
  explicit Authenticate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Authenticate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Authenticate& from);
  Authenticate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Authenticate&& from) noexcept
      : Authenticate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokensFieldNumber = 3,
    kCeltVersionsFieldNumber = 4,
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOpusFieldNumber = 5,
    kClientTypeFieldNumber = 6,
  };
  // repeated string tokens = 3;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;

  public:
  void clear_tokens() ;
  const ::std::string& tokens(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_tokens(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_tokens(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_tokens();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_tokens(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tokens() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_tokens();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_tokens() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_tokens();

  public:
  // repeated int32 celt_versions = 4;
  int celt_versions_size() const;
  private:
  int _internal_celt_versions_size() const;

  public:
  void clear_celt_versions() ;
  ::int32_t celt_versions(int index) const;
  void set_celt_versions(int index, ::int32_t value);
  void add_celt_versions(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& celt_versions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_celt_versions();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_celt_versions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_celt_versions();

  public:
  // optional string username = 1;
  bool has_username() const;
  void clear_username() ;
  const ::std::string& username() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_username();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_username();
  void set_allocated_username(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_username() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_username(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_username();

  public:
  // optional string password = 2;
  bool has_password() const;
  void clear_password() ;
  const ::std::string& password() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_password();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_password();
  void set_allocated_password(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_password() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_password(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_password();

  public:
  // optional bool opus = 5 [default = false];
  bool has_opus() const;
  void clear_opus() ;
  bool opus() const;
  void set_opus(bool value);

  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);

  public:
  // optional int32 client_type = 6 [default = 0];
  bool has_client_type() const;
  void clear_client_type() ;
  ::int32_t client_type() const;
  void set_client_type(::int32_t value);

  private:
  ::int32_t _internal_client_type() const;
  void _internal_set_client_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.Authenticate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Authenticate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> tokens_;
    ::google::protobuf::RepeatedField<::int32_t> celt_versions_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    bool opus_;
    ::int32_t client_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Authenticate_class_data_;
// -------------------------------------------------------------------

class ACL_ChanGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ACL.ChanGroup) */ {
 public:
  inline ACL_ChanGroup() : ACL_ChanGroup(nullptr) {}
  ~ACL_ChanGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ACL_ChanGroup* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ACL_ChanGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ACL_ChanGroup(::google::protobuf::internal::ConstantInitialized);

  inline ACL_ChanGroup(const ACL_ChanGroup& from) : ACL_ChanGroup(nullptr, from) {}
  inline ACL_ChanGroup(ACL_ChanGroup&& from) noexcept
      : ACL_ChanGroup(nullptr, ::std::move(from)) {}
  inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL_ChanGroup& operator=(ACL_ChanGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACL_ChanGroup& default_instance() {
    return *reinterpret_cast<const ACL_ChanGroup*>(
        &_ACL_ChanGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ACL_ChanGroup& a, ACL_ChanGroup& b) { a.Swap(&b); }
  inline void Swap(ACL_ChanGroup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL_ChanGroup* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACL_ChanGroup* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ACL_ChanGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACL_ChanGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ACL_ChanGroup& from) { ACL_ChanGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ACL_ChanGroup* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ACL.ChanGroup"; }

 protected:
  explicit ACL_ChanGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ACL_ChanGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ACL_ChanGroup& from);
  ACL_ChanGroup(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ACL_ChanGroup&& from) noexcept
      : ACL_ChanGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddFieldNumber = 5,
    kRemoveFieldNumber = 6,
    kInheritedMembersFieldNumber = 7,
    kNameFieldNumber = 1,
    kInheritedFieldNumber = 2,
    kInheritFieldNumber = 3,
    kInheritableFieldNumber = 4,
  };
  // repeated uint32 add = 5;
  int add_size() const;
  private:
  int _internal_add_size() const;

  public:
  void clear_add() ;
  ::uint32_t add(int index) const;
  void set_add(int index, ::uint32_t value);
  void add_add(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_add();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_add();

  public:
  // repeated uint32 remove = 6;
  int remove_size() const;
  private:
  int _internal_remove_size() const;

  public:
  void clear_remove() ;
  ::uint32_t remove(int index) const;
  void set_remove(int index, ::uint32_t value);
  void add_remove(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_remove();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_remove();

  public:
  // repeated uint32 inherited_members = 7;
  int inherited_members_size() const;
  private:
  int _internal_inherited_members_size() const;

  public:
  void clear_inherited_members() ;
  ::uint32_t inherited_members(int index) const;
  void set_inherited_members(int index, ::uint32_t value);
  void add_inherited_members(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& inherited_members() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_inherited_members();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_inherited_members() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_inherited_members();

  public:
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional bool inherited = 2 [default = true];
  bool has_inherited() const;
  void clear_inherited() ;
  bool inherited() const;
  void set_inherited(bool value);

  private:
  bool _internal_inherited() const;
  void _internal_set_inherited(bool value);

  public:
  // optional bool inherit = 3 [default = true];
  bool has_inherit() const;
  void clear_inherit() ;
  bool inherit() const;
  void set_inherit(bool value);

  private:
  bool _internal_inherit() const;
  void _internal_set_inherit(bool value);

  public:
  // optional bool inheritable = 4 [default = true];
  bool has_inheritable() const;
  void clear_inheritable() ;
  bool inheritable() const;
  void set_inheritable(bool value);

  private:
  bool _internal_inheritable() const;
  void _internal_set_inheritable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ACL.ChanGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ACL_ChanGroup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> add_;
    ::google::protobuf::RepeatedField<::uint32_t> remove_;
    ::google::protobuf::RepeatedField<::uint32_t> inherited_members_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool inherited_;
    bool inherit_;
    bool inheritable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ACL_ChanGroup_class_data_;
// -------------------------------------------------------------------

class ACL_ChanACL final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ACL.ChanACL) */ {
 public:
  inline ACL_ChanACL() : ACL_ChanACL(nullptr) {}
  ~ACL_ChanACL() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ACL_ChanACL* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ACL_ChanACL));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ACL_ChanACL(::google::protobuf::internal::ConstantInitialized);

  inline ACL_ChanACL(const ACL_ChanACL& from) : ACL_ChanACL(nullptr, from) {}
  inline ACL_ChanACL(ACL_ChanACL&& from) noexcept
      : ACL_ChanACL(nullptr, ::std::move(from)) {}
  inline ACL_ChanACL& operator=(const ACL_ChanACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL_ChanACL& operator=(ACL_ChanACL&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACL_ChanACL& default_instance() {
    return *reinterpret_cast<const ACL_ChanACL*>(
        &_ACL_ChanACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ACL_ChanACL& a, ACL_ChanACL& b) { a.Swap(&b); }
  inline void Swap(ACL_ChanACL* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL_ChanACL* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACL_ChanACL* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ACL_ChanACL>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACL_ChanACL& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ACL_ChanACL& from) { ACL_ChanACL::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ACL_ChanACL* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ACL.ChanACL"; }

 protected:
  explicit ACL_ChanACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ACL_ChanACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ACL_ChanACL& from);
  ACL_ChanACL(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ACL_ChanACL&& from) noexcept
      : ACL_ChanACL(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupFieldNumber = 5,
    kUserIdFieldNumber = 4,
    kGrantFieldNumber = 6,
    kDenyFieldNumber = 7,
    kApplyHereFieldNumber = 1,
    kApplySubsFieldNumber = 2,
    kInheritedFieldNumber = 3,
  };
  // optional string group = 5;
  bool has_group() const;
  void clear_group() ;
  const ::std::string& group() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group();
  void set_allocated_group(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group();

  public:
  // optional uint32 user_id = 4;
  bool has_user_id() const;
  void clear_user_id() ;
  ::uint32_t user_id() const;
  void set_user_id(::uint32_t value);

  private:
  ::uint32_t _internal_user_id() const;
  void _internal_set_user_id(::uint32_t value);

  public:
  // optional uint32 grant = 6;
  bool has_grant() const;
  void clear_grant() ;
  ::uint32_t grant() const;
  void set_grant(::uint32_t value);

  private:
  ::uint32_t _internal_grant() const;
  void _internal_set_grant(::uint32_t value);

  public:
  // optional uint32 deny = 7;
  bool has_deny() const;
  void clear_deny() ;
  ::uint32_t deny() const;
  void set_deny(::uint32_t value);

  private:
  ::uint32_t _internal_deny() const;
  void _internal_set_deny(::uint32_t value);

  public:
  // optional bool apply_here = 1 [default = true];
  bool has_apply_here() const;
  void clear_apply_here() ;
  bool apply_here() const;
  void set_apply_here(bool value);

  private:
  bool _internal_apply_here() const;
  void _internal_set_apply_here(bool value);

  public:
  // optional bool apply_subs = 2 [default = true];
  bool has_apply_subs() const;
  void clear_apply_subs() ;
  bool apply_subs() const;
  void set_apply_subs(bool value);

  private:
  bool _internal_apply_subs() const;
  void _internal_set_apply_subs(bool value);

  public:
  // optional bool inherited = 3 [default = true];
  bool has_inherited() const;
  void clear_inherited() ;
  bool inherited() const;
  void set_inherited(bool value);

  private:
  bool _internal_inherited() const;
  void _internal_set_inherited(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ACL.ChanACL)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ACL_ChanACL& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::uint32_t user_id_;
    ::uint32_t grant_;
    ::uint32_t deny_;
    bool apply_here_;
    bool apply_subs_;
    bool inherited_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ACL_ChanACL_class_data_;
// -------------------------------------------------------------------

class VoiceTarget final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.VoiceTarget) */ {
 public:
  inline VoiceTarget() : VoiceTarget(nullptr) {}
  ~VoiceTarget() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VoiceTarget* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VoiceTarget));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoiceTarget(::google::protobuf::internal::ConstantInitialized);

  inline VoiceTarget(const VoiceTarget& from) : VoiceTarget(nullptr, from) {}
  inline VoiceTarget(VoiceTarget&& from) noexcept
      : VoiceTarget(nullptr, ::std::move(from)) {}
  inline VoiceTarget& operator=(const VoiceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceTarget& operator=(VoiceTarget&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceTarget& default_instance() {
    return *reinterpret_cast<const VoiceTarget*>(
        &_VoiceTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(VoiceTarget& a, VoiceTarget& b) { a.Swap(&b); }
  inline void Swap(VoiceTarget* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceTarget* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceTarget* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VoiceTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoiceTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoiceTarget& from) { VoiceTarget::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VoiceTarget* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.VoiceTarget"; }

 protected:
  explicit VoiceTarget(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VoiceTarget(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VoiceTarget& from);
  VoiceTarget(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VoiceTarget&& from) noexcept
      : VoiceTarget(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Target = VoiceTarget_Target;

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .NoxProto.VoiceTarget.Target targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::NoxProto::VoiceTarget_Target* PROTOBUF_NONNULL mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>* PROTOBUF_NONNULL mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>* PROTOBUF_NONNULL _internal_mutable_targets();
  public:
  const ::NoxProto::VoiceTarget_Target& targets(int index) const;
  ::NoxProto::VoiceTarget_Target* PROTOBUF_NONNULL add_targets();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>& targets() const;
  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.VoiceTarget)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VoiceTarget& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NoxProto::VoiceTarget_Target > targets_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VoiceTarget_class_data_;
// -------------------------------------------------------------------

class UserStats_RollingStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserStats.RollingStats) */ {
 public:
  inline UserStats_RollingStats() : UserStats_RollingStats(nullptr) {}
  ~UserStats_RollingStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserStats_RollingStats* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserStats_RollingStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserStats_RollingStats(::google::protobuf::internal::ConstantInitialized);

  inline UserStats_RollingStats(const UserStats_RollingStats& from) : UserStats_RollingStats(nullptr, from) {}
  inline UserStats_RollingStats(UserStats_RollingStats&& from) noexcept
      : UserStats_RollingStats(nullptr, ::std::move(from)) {}
  inline UserStats_RollingStats& operator=(const UserStats_RollingStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStats_RollingStats& operator=(UserStats_RollingStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStats_RollingStats& default_instance() {
    return *reinterpret_cast<const UserStats_RollingStats*>(
        &_UserStats_RollingStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(UserStats_RollingStats& a, UserStats_RollingStats& b) { a.Swap(&b); }
  inline void Swap(UserStats_RollingStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStats_RollingStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStats_RollingStats* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserStats_RollingStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserStats_RollingStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserStats_RollingStats& from) { UserStats_RollingStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserStats_RollingStats* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserStats.RollingStats"; }

 protected:
  explicit UserStats_RollingStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserStats_RollingStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserStats_RollingStats& from);
  UserStats_RollingStats(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserStats_RollingStats&& from) noexcept
      : UserStats_RollingStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromClientFieldNumber = 2,
    kFromServerFieldNumber = 3,
    kTimeWindowFieldNumber = 1,
  };
  // optional .NoxProto.UserStats.Stats from_client = 2;
  bool has_from_client() const;
  void clear_from_client() ;
  const ::NoxProto::UserStats_Stats& from_client() const;
  [[nodiscard]] ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE release_from_client();
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL mutable_from_client();
  void set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE unsafe_arena_release_from_client();

  private:
  const ::NoxProto::UserStats_Stats& _internal_from_client() const;
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL _internal_mutable_from_client();

  public:
  // optional .NoxProto.UserStats.Stats from_server = 3;
  bool has_from_server() const;
  void clear_from_server() ;
  const ::NoxProto::UserStats_Stats& from_server() const;
  [[nodiscard]] ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE release_from_server();
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL mutable_from_server();
  void set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE unsafe_arena_release_from_server();

  private:
  const ::NoxProto::UserStats_Stats& _internal_from_server() const;
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL _internal_mutable_from_server();

  public:
  // optional uint32 time_window = 1;
  bool has_time_window() const;
  void clear_time_window() ;
  ::uint32_t time_window() const;
  void set_time_window(::uint32_t value);

  private:
  ::uint32_t _internal_time_window() const;
  void _internal_set_time_window(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserStats.RollingStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserStats_RollingStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE from_client_;
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE from_server_;
    ::uint32_t time_window_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserStats_RollingStats_class_data_;
// -------------------------------------------------------------------

class UserState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserState) */ {
 public:
  inline UserState() : UserState(nullptr) {}
  ~UserState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserState(::google::protobuf::internal::ConstantInitialized);

  inline UserState(const UserState& from) : UserState(nullptr, from) {}
  inline UserState(UserState&& from) noexcept
      : UserState(nullptr, ::std::move(from)) {}
  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserState& operator=(UserState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserState& default_instance() {
    return *reinterpret_cast<const UserState*>(
        &_UserState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(UserState& a, UserState& b) { a.Swap(&b); }
  inline void Swap(UserState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserState& from) { UserState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserState"; }

 protected:
  explicit UserState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserState& from);
  UserState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserState&& from) noexcept
      : UserState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using VolumeAdjustment = UserState_VolumeAdjustment;

  // accessors -------------------------------------------------------
  enum : int {
    kTemporaryAccessTokensFieldNumber = 20,
    kListeningChannelAddFieldNumber = 21,
    kListeningChannelRemoveFieldNumber = 22,
    kListeningVolumeAdjustmentFieldNumber = 23,
    kNameFieldNumber = 3,
    kTextureFieldNumber = 11,
    kPluginContextFieldNumber = 12,
    kPluginIdentityFieldNumber = 13,
    kCommentFieldNumber = 14,
    kHashFieldNumber = 15,
    kCommentHashFieldNumber = 16,
    kTextureHashFieldNumber = 17,
    kSessionFieldNumber = 1,
    kActorFieldNumber = 2,
    kUserIdFieldNumber = 4,
    kChannelIdFieldNumber = 5,
    kMuteFieldNumber = 6,
    kDeafFieldNumber = 7,
    kSuppressFieldNumber = 8,
    kSelfMuteFieldNumber = 9,
    kSelfDeafFieldNumber = 10,
    kPrioritySpeakerFieldNumber = 18,
    kRecordingFieldNumber = 19,
  };
  // repeated string temporary_access_tokens = 20;
  int temporary_access_tokens_size() const;
  private:
  int _internal_temporary_access_tokens_size() const;

  public:
  void clear_temporary_access_tokens() ;
  const ::std::string& temporary_access_tokens(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_temporary_access_tokens(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_temporary_access_tokens(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_temporary_access_tokens();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_temporary_access_tokens(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& temporary_access_tokens() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_temporary_access_tokens();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_temporary_access_tokens() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_temporary_access_tokens();

  public:
  // repeated uint32 listening_channel_add = 21;
  int listening_channel_add_size() const;
  private:
  int _internal_listening_channel_add_size() const;

  public:
  void clear_listening_channel_add() ;
  ::uint32_t listening_channel_add(int index) const;
  void set_listening_channel_add(int index, ::uint32_t value);
  void add_listening_channel_add(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& listening_channel_add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_listening_channel_add();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_listening_channel_add() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_listening_channel_add();

  public:
  // repeated uint32 listening_channel_remove = 22;
  int listening_channel_remove_size() const;
  private:
  int _internal_listening_channel_remove_size() const;

  public:
  void clear_listening_channel_remove() ;
  ::uint32_t listening_channel_remove(int index) const;
  void set_listening_channel_remove(int index, ::uint32_t value);
  void add_listening_channel_remove(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& listening_channel_remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_listening_channel_remove();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_listening_channel_remove() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_listening_channel_remove();

  public:
  // repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
  int listening_volume_adjustment_size() const;
  private:
  int _internal_listening_volume_adjustment_size() const;

  public:
  void clear_listening_volume_adjustment() ;
  ::NoxProto::UserState_VolumeAdjustment* PROTOBUF_NONNULL mutable_listening_volume_adjustment(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>* PROTOBUF_NONNULL mutable_listening_volume_adjustment();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>& _internal_listening_volume_adjustment() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>* PROTOBUF_NONNULL _internal_mutable_listening_volume_adjustment();
  public:
  const ::NoxProto::UserState_VolumeAdjustment& listening_volume_adjustment(int index) const;
  ::NoxProto::UserState_VolumeAdjustment* PROTOBUF_NONNULL add_listening_volume_adjustment();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>& listening_volume_adjustment() const;
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional bytes texture = 11;
  bool has_texture() const;
  void clear_texture() ;
  const ::std::string& texture() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_texture(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_texture();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_texture();
  void set_allocated_texture(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_texture() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_texture(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_texture();

  public:
  // optional bytes plugin_context = 12;
  bool has_plugin_context() const;
  void clear_plugin_context() ;
  const ::std::string& plugin_context() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_plugin_context(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_plugin_context();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_plugin_context();
  void set_allocated_plugin_context(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_plugin_context() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_context(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_plugin_context();

  public:
  // optional string plugin_identity = 13;
  bool has_plugin_identity() const;
  void clear_plugin_identity() ;
  const ::std::string& plugin_identity() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_plugin_identity(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_plugin_identity();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_plugin_identity();
  void set_allocated_plugin_identity(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_plugin_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_identity(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_plugin_identity();

  public:
  // optional string comment = 14;
  bool has_comment() const;
  void clear_comment() ;
  const ::std::string& comment() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_comment();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_comment();
  void set_allocated_comment(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_comment() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_comment();

  public:
  // optional string hash = 15;
  bool has_hash() const;
  void clear_hash() ;
  const ::std::string& hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hash();
  void set_allocated_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hash();

  public:
  // optional bytes comment_hash = 16;
  bool has_comment_hash() const;
  void clear_comment_hash() ;
  const ::std::string& comment_hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_comment_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_comment_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_comment_hash();
  void set_allocated_comment_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_comment_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_comment_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_comment_hash();

  public:
  // optional bytes texture_hash = 17;
  bool has_texture_hash() const;
  void clear_texture_hash() ;
  const ::std::string& texture_hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_texture_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_texture_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_texture_hash();
  void set_allocated_texture_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_texture_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_texture_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_texture_hash();

  public:
  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional uint32 actor = 2;
  bool has_actor() const;
  void clear_actor() ;
  ::uint32_t actor() const;
  void set_actor(::uint32_t value);

  private:
  ::uint32_t _internal_actor() const;
  void _internal_set_actor(::uint32_t value);

  public:
  // optional uint32 user_id = 4;
  bool has_user_id() const;
  void clear_user_id() ;
  ::uint32_t user_id() const;
  void set_user_id(::uint32_t value);

  private:
  ::uint32_t _internal_user_id() const;
  void _internal_set_user_id(::uint32_t value);

  public:
  // optional uint32 channel_id = 5;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional bool mute = 6;
  bool has_mute() const;
  void clear_mute() ;
  bool mute() const;
  void set_mute(bool value);

  private:
  bool _internal_mute() const;
  void _internal_set_mute(bool value);

  public:
  // optional bool deaf = 7;
  bool has_deaf() const;
  void clear_deaf() ;
  bool deaf() const;
  void set_deaf(bool value);

  private:
  bool _internal_deaf() const;
  void _internal_set_deaf(bool value);

  public:
  // optional bool suppress = 8;
  bool has_suppress() const;
  void clear_suppress() ;
  bool suppress() const;
  void set_suppress(bool value);

  private:
  bool _internal_suppress() const;
  void _internal_set_suppress(bool value);

  public:
  // optional bool self_mute = 9;
  bool has_self_mute() const;
  void clear_self_mute() ;
  bool self_mute() const;
  void set_self_mute(bool value);

  private:
  bool _internal_self_mute() const;
  void _internal_set_self_mute(bool value);

  public:
  // optional bool self_deaf = 10;
  bool has_self_deaf() const;
  void clear_self_deaf() ;
  bool self_deaf() const;
  void set_self_deaf(bool value);

  private:
  bool _internal_self_deaf() const;
  void _internal_set_self_deaf(bool value);

  public:
  // optional bool priority_speaker = 18;
  bool has_priority_speaker() const;
  void clear_priority_speaker() ;
  bool priority_speaker() const;
  void set_priority_speaker(bool value);

  private:
  bool _internal_priority_speaker() const;
  void _internal_set_priority_speaker(bool value);

  public:
  // optional bool recording = 19;
  bool has_recording() const;
  void clear_recording() ;
  bool recording() const;
  void set_recording(bool value);

  private:
  bool _internal_recording() const;
  void _internal_set_recording(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 23,
                                   1, 96,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> temporary_access_tokens_;
    ::google::protobuf::RepeatedField<::uint32_t> listening_channel_add_;
    ::google::protobuf::RepeatedField<::uint32_t> listening_channel_remove_;
    ::google::protobuf::RepeatedPtrField< ::NoxProto::UserState_VolumeAdjustment > listening_volume_adjustment_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr texture_;
    ::google::protobuf::internal::ArenaStringPtr plugin_context_;
    ::google::protobuf::internal::ArenaStringPtr plugin_identity_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::google::protobuf::internal::ArenaStringPtr comment_hash_;
    ::google::protobuf::internal::ArenaStringPtr texture_hash_;
    ::uint32_t session_;
    ::uint32_t actor_;
    ::uint32_t user_id_;
    ::uint32_t channel_id_;
    bool mute_;
    bool deaf_;
    bool suppress_;
    bool self_mute_;
    bool self_deaf_;
    bool priority_speaker_;
    bool recording_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserState_class_data_;
// -------------------------------------------------------------------

class UserList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {}
  ~UserList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserList(::google::protobuf::internal::ConstantInitialized);

  inline UserList(const UserList& from) : UserList(nullptr, from) {}
  inline UserList(UserList&& from) noexcept
      : UserList(nullptr, ::std::move(from)) {}
  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserList& default_instance() {
    return *reinterpret_cast<const UserList*>(
        &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(UserList& a, UserList& b) { a.Swap(&b); }
  inline void Swap(UserList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserList& from) { UserList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserList"; }

 protected:
  explicit UserList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserList& from);
  UserList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserList&& from) noexcept
      : UserList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using User = UserList_User;

  // accessors -------------------------------------------------------
  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .NoxProto.UserList.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;

  public:
  void clear_users() ;
  ::NoxProto::UserList_User* PROTOBUF_NONNULL mutable_users(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>* PROTOBUF_NONNULL mutable_users();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>& _internal_users() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>* PROTOBUF_NONNULL _internal_mutable_users();
  public:
  const ::NoxProto::UserList_User& users(int index) const;
  ::NoxProto::UserList_User* PROTOBUF_NONNULL add_users();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>& users() const;
  // @@protoc_insertion_point(class_scope:NoxProto.UserList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::NoxProto::UserList_User > users_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserList_class_data_;
// -------------------------------------------------------------------

class BanList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.BanList) */ {
 public:
  inline BanList() : BanList(nullptr) {}
  ~BanList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BanList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BanList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BanList(::google::protobuf::internal::ConstantInitialized);

  inline BanList(const BanList& from) : BanList(nullptr, from) {}
  inline BanList(BanList&& from) noexcept
      : BanList(nullptr, ::std::move(from)) {}
  inline BanList& operator=(const BanList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BanList& operator=(BanList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BanList& default_instance() {
    return *reinterpret_cast<const BanList*>(
        &_BanList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(BanList& a, BanList& b) { a.Swap(&b); }
  inline void Swap(BanList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BanList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BanList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BanList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BanList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BanList& from) { BanList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BanList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.BanList"; }

 protected:
  explicit BanList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BanList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BanList& from);
  BanList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BanList&& from) noexcept
      : BanList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BanEntry = BanList_BanEntry;

  // accessors -------------------------------------------------------
  enum : int {
    kBansFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // repeated .NoxProto.BanList.BanEntry bans = 1;
  int bans_size() const;
  private:
  int _internal_bans_size() const;

  public:
  void clear_bans() ;
  ::NoxProto::BanList_BanEntry* PROTOBUF_NONNULL mutable_bans(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>* PROTOBUF_NONNULL mutable_bans();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>& _internal_bans() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>* PROTOBUF_NONNULL _internal_mutable_bans();
  public:
  const ::NoxProto::BanList_BanEntry& bans(int index) const;
  ::NoxProto::BanList_BanEntry* PROTOBUF_NONNULL add_bans();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>& bans() const;
  // optional bool query = 2 [default = false];
  bool has_query() const;
  void clear_query() ;
  bool query() const;
  void set_query(bool value);

  private:
  bool _internal_query() const;
  void _internal_set_query(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.BanList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BanList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NoxProto::BanList_BanEntry > bans_;
    bool query_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BanList_class_data_;
// -------------------------------------------------------------------

class ACL final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.ACL) */ {
 public:
  inline ACL() : ACL(nullptr) {}
  ~ACL() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ACL* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ACL));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ACL(::google::protobuf::internal::ConstantInitialized);

  inline ACL(const ACL& from) : ACL(nullptr, from) {}
  inline ACL(ACL&& from) noexcept
      : ACL(nullptr, ::std::move(from)) {}
  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL& operator=(ACL&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACL& default_instance() {
    return *reinterpret_cast<const ACL*>(
        &_ACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ACL& a, ACL& b) { a.Swap(&b); }
  inline void Swap(ACL* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACL* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ACL>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACL& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ACL& from) { ACL::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ACL* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.ACL"; }

 protected:
  explicit ACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ACL& from);
  ACL(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ACL&& from) noexcept
      : ACL(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ChanGroup = ACL_ChanGroup;
  using ChanACL = ACL_ChanACL;

  // accessors -------------------------------------------------------
  enum : int {
    kGroupsFieldNumber = 3,
    kAclsFieldNumber = 4,
    kChannelIdFieldNumber = 1,
    kQueryFieldNumber = 5,
    kInheritAclsFieldNumber = 2,
  };
  // repeated .NoxProto.ACL.ChanGroup groups = 3;
  int groups_size() const;
  private:
  int _internal_groups_size() const;

  public:
  void clear_groups() ;
  ::NoxProto::ACL_ChanGroup* PROTOBUF_NONNULL mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>* PROTOBUF_NONNULL mutable_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>& _internal_groups() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>* PROTOBUF_NONNULL _internal_mutable_groups();
  public:
  const ::NoxProto::ACL_ChanGroup& groups(int index) const;
  ::NoxProto::ACL_ChanGroup* PROTOBUF_NONNULL add_groups();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>& groups() const;
  // repeated .NoxProto.ACL.ChanACL acls = 4;
  int acls_size() const;
  private:
  int _internal_acls_size() const;

  public:
  void clear_acls() ;
  ::NoxProto::ACL_ChanACL* PROTOBUF_NONNULL mutable_acls(int index);
  ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>* PROTOBUF_NONNULL mutable_acls();

  private:
  const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>& _internal_acls() const;
  ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>* PROTOBUF_NONNULL _internal_mutable_acls();
  public:
  const ::NoxProto::ACL_ChanACL& acls(int index) const;
  ::NoxProto::ACL_ChanACL* PROTOBUF_NONNULL add_acls();
  const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>& acls() const;
  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // optional bool query = 5 [default = false];
  bool has_query() const;
  void clear_query() ;
  bool query() const;
  void set_query(bool value);

  private:
  bool _internal_query() const;
  void _internal_set_query(bool value);

  public:
  // optional bool inherit_acls = 2 [default = true];
  bool has_inherit_acls() const;
  void clear_inherit_acls() ;
  bool inherit_acls() const;
  void set_inherit_acls(bool value);

  private:
  bool _internal_inherit_acls() const;
  void _internal_set_inherit_acls(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.ACL)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ACL& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NoxProto::ACL_ChanGroup > groups_;
    ::google::protobuf::RepeatedPtrField< ::NoxProto::ACL_ChanACL > acls_;
    ::uint32_t channel_id_;
    bool query_;
    bool inherit_acls_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ACL_class_data_;
// -------------------------------------------------------------------

class UserStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoxProto.UserStats) */ {
 public:
  inline UserStats() : UserStats(nullptr) {}
  ~UserStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserStats* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserStats(::google::protobuf::internal::ConstantInitialized);

  inline UserStats(const UserStats& from) : UserStats(nullptr, from) {}
  inline UserStats(UserStats&& from) noexcept
      : UserStats(nullptr, ::std::move(from)) {}
  inline UserStats& operator=(const UserStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStats& operator=(UserStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStats& default_instance() {
    return *reinterpret_cast<const UserStats*>(
        &_UserStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(UserStats& a, UserStats& b) { a.Swap(&b); }
  inline void Swap(UserStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStats* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserStats& from) { UserStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserStats* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoxProto.UserStats"; }

 protected:
  explicit UserStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserStats& from);
  UserStats(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserStats&& from) noexcept
      : UserStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Stats = UserStats_Stats;
  using RollingStats = UserStats_RollingStats;

  // accessors -------------------------------------------------------
  enum : int {
    kCertificatesFieldNumber = 3,
    kCeltVersionsFieldNumber = 13,
    kAddressFieldNumber = 14,
    kFromClientFieldNumber = 4,
    kFromServerFieldNumber = 5,
    kVersionFieldNumber = 12,
    kRollingStatsFieldNumber = 20,
    kSessionFieldNumber = 1,
    kUdpPacketsFieldNumber = 6,
    kTcpPacketsFieldNumber = 7,
    kUdpPingAvgFieldNumber = 8,
    kUdpPingVarFieldNumber = 9,
    kTcpPingAvgFieldNumber = 10,
    kTcpPingVarFieldNumber = 11,
    kStatsOnlyFieldNumber = 2,
    kStrongCertificateFieldNumber = 18,
    kOpusFieldNumber = 19,
    kBandwidthFieldNumber = 15,
    kOnlinesecsFieldNumber = 16,
    kIdlesecsFieldNumber = 17,
  };
  // repeated bytes certificates = 3;
  int certificates_size() const;
  private:
  int _internal_certificates_size() const;

  public:
  void clear_certificates() ;
  const ::std::string& certificates(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_certificates(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_certificates(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_certificates();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_certificates(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& certificates() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_certificates();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_certificates() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_certificates();

  public:
  // repeated int32 celt_versions = 13;
  int celt_versions_size() const;
  private:
  int _internal_celt_versions_size() const;

  public:
  void clear_celt_versions() ;
  ::int32_t celt_versions(int index) const;
  void set_celt_versions(int index, ::int32_t value);
  void add_celt_versions(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& celt_versions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_celt_versions();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_celt_versions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_celt_versions();

  public:
  // optional bytes address = 14;
  bool has_address() const;
  void clear_address() ;
  const ::std::string& address() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_address();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_address();
  void set_allocated_address(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_address() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_address(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_address();

  public:
  // optional .NoxProto.UserStats.Stats from_client = 4;
  bool has_from_client() const;
  void clear_from_client() ;
  const ::NoxProto::UserStats_Stats& from_client() const;
  [[nodiscard]] ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE release_from_client();
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL mutable_from_client();
  void set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE unsafe_arena_release_from_client();

  private:
  const ::NoxProto::UserStats_Stats& _internal_from_client() const;
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL _internal_mutable_from_client();

  public:
  // optional .NoxProto.UserStats.Stats from_server = 5;
  bool has_from_server() const;
  void clear_from_server() ;
  const ::NoxProto::UserStats_Stats& from_server() const;
  [[nodiscard]] ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE release_from_server();
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL mutable_from_server();
  void set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value);
  ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE unsafe_arena_release_from_server();

  private:
  const ::NoxProto::UserStats_Stats& _internal_from_server() const;
  ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL _internal_mutable_from_server();

  public:
  // optional .NoxProto.Version version = 12;
  bool has_version() const;
  void clear_version() ;
  const ::NoxProto::Version& version() const;
  [[nodiscard]] ::NoxProto::Version* PROTOBUF_NULLABLE release_version();
  ::NoxProto::Version* PROTOBUF_NONNULL mutable_version();
  void set_allocated_version(::NoxProto::Version* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_version(::NoxProto::Version* PROTOBUF_NULLABLE value);
  ::NoxProto::Version* PROTOBUF_NULLABLE unsafe_arena_release_version();

  private:
  const ::NoxProto::Version& _internal_version() const;
  ::NoxProto::Version* PROTOBUF_NONNULL _internal_mutable_version();

  public:
  // optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
  bool has_rolling_stats() const;
  void clear_rolling_stats() ;
  const ::NoxProto::UserStats_RollingStats& rolling_stats() const;
  [[nodiscard]] ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE release_rolling_stats();
  ::NoxProto::UserStats_RollingStats* PROTOBUF_NONNULL mutable_rolling_stats();
  void set_allocated_rolling_stats(::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rolling_stats(::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE value);
  ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE unsafe_arena_release_rolling_stats();

  private:
  const ::NoxProto::UserStats_RollingStats& _internal_rolling_stats() const;
  ::NoxProto::UserStats_RollingStats* PROTOBUF_NONNULL _internal_mutable_rolling_stats();

  public:
  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::uint32_t session() const;
  void set_session(::uint32_t value);

  private:
  ::uint32_t _internal_session() const;
  void _internal_set_session(::uint32_t value);

  public:
  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  void clear_udp_packets() ;
  ::uint32_t udp_packets() const;
  void set_udp_packets(::uint32_t value);

  private:
  ::uint32_t _internal_udp_packets() const;
  void _internal_set_udp_packets(::uint32_t value);

  public:
  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  void clear_tcp_packets() ;
  ::uint32_t tcp_packets() const;
  void set_tcp_packets(::uint32_t value);

  private:
  ::uint32_t _internal_tcp_packets() const;
  void _internal_set_tcp_packets(::uint32_t value);

  public:
  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  void clear_udp_ping_avg() ;
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);

  private:
  float _internal_udp_ping_avg() const;
  void _internal_set_udp_ping_avg(float value);

  public:
  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  void clear_udp_ping_var() ;
  float udp_ping_var() const;
  void set_udp_ping_var(float value);

  private:
  float _internal_udp_ping_var() const;
  void _internal_set_udp_ping_var(float value);

  public:
  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  void clear_tcp_ping_avg() ;
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);

  private:
  float _internal_tcp_ping_avg() const;
  void _internal_set_tcp_ping_avg(float value);

  public:
  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  void clear_tcp_ping_var() ;
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);

  private:
  float _internal_tcp_ping_var() const;
  void _internal_set_tcp_ping_var(float value);

  public:
  // optional bool stats_only = 2 [default = false];
  bool has_stats_only() const;
  void clear_stats_only() ;
  bool stats_only() const;
  void set_stats_only(bool value);

  private:
  bool _internal_stats_only() const;
  void _internal_set_stats_only(bool value);

  public:
  // optional bool strong_certificate = 18 [default = false];
  bool has_strong_certificate() const;
  void clear_strong_certificate() ;
  bool strong_certificate() const;
  void set_strong_certificate(bool value);

  private:
  bool _internal_strong_certificate() const;
  void _internal_set_strong_certificate(bool value);

  public:
  // optional bool opus = 19 [default = false];
  bool has_opus() const;
  void clear_opus() ;
  bool opus() const;
  void set_opus(bool value);

  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);

  public:
  // optional uint32 bandwidth = 15;
  bool has_bandwidth() const;
  void clear_bandwidth() ;
  ::uint32_t bandwidth() const;
  void set_bandwidth(::uint32_t value);

  private:
  ::uint32_t _internal_bandwidth() const;
  void _internal_set_bandwidth(::uint32_t value);

  public:
  // optional uint32 onlinesecs = 16;
  bool has_onlinesecs() const;
  void clear_onlinesecs() ;
  ::uint32_t onlinesecs() const;
  void set_onlinesecs(::uint32_t value);

  private:
  ::uint32_t _internal_onlinesecs() const;
  void _internal_set_onlinesecs(::uint32_t value);

  public:
  // optional uint32 idlesecs = 17;
  bool has_idlesecs() const;
  void clear_idlesecs() ;
  ::uint32_t idlesecs() const;
  void set_idlesecs(::uint32_t value);

  private:
  ::uint32_t _internal_idlesecs() const;
  void _internal_set_idlesecs(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoxProto.UserStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 20,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> certificates_;
    ::google::protobuf::RepeatedField<::int32_t> celt_versions_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE from_client_;
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE from_server_;
    ::NoxProto::Version* PROTOBUF_NULLABLE version_;
    ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE rolling_stats_;
    ::uint32_t session_;
    ::uint32_t udp_packets_;
    ::uint32_t tcp_packets_;
    float udp_ping_avg_;
    float udp_ping_var_;
    float tcp_ping_avg_;
    float tcp_ping_var_;
    bool stats_only_;
    bool strong_certificate_;
    bool opus_;
    ::uint32_t bandwidth_;
    ::uint32_t onlinesecs_;
    ::uint32_t idlesecs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Nox_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserStats_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Version

// optional uint32 version_v1 = 1;
inline bool Version::has_version_v1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Version::clear_version_v1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Version::version_v1() const {
  // @@protoc_insertion_point(field_get:NoxProto.Version.version_v1)
  return _internal_version_v1();
}
inline void Version::set_version_v1(::uint32_t value) {
  _internal_set_version_v1(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.Version.version_v1)
}
inline ::uint32_t Version::_internal_version_v1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_v1_;
}
inline void Version::_internal_set_version_v1(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v1_ = value;
}

// optional uint64 version_v2 = 5;
inline bool Version::has_version_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Version::clear_version_v2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v2_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t Version::version_v2() const {
  // @@protoc_insertion_point(field_get:NoxProto.Version.version_v2)
  return _internal_version_v2();
}
inline void Version::set_version_v2(::uint64_t value) {
  _internal_set_version_v2(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.Version.version_v2)
}
inline ::uint64_t Version::_internal_version_v2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_v2_;
}
inline void Version::_internal_set_version_v2(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v2_ = value;
}

// optional string release = 2;
inline bool Version::has_release() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Version::clear_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Version::release() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Version.release)
  return _internal_release();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Version::set_release(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.release_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Version.release)
}
inline ::std::string* PROTOBUF_NONNULL Version::mutable_release()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_release();
  // @@protoc_insertion_point(field_mutable:NoxProto.Version.release)
  return _s;
}
inline const ::std::string& Version::_internal_release() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.release_.Get();
}
inline void Version::_internal_set_release(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.release_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Version::_internal_mutable_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.release_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Version::release_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Version.release)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.release_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.release_.Set("", GetArena());
  }
  return released;
}
inline void Version::set_allocated_release(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.release_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.release_.IsDefault()) {
    _impl_.release_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Version.release)
}

// optional string os = 3;
inline bool Version::has_os() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Version::clear_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Version::os() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Version.os)
  return _internal_os();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Version::set_os(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Version.os)
}
inline ::std::string* PROTOBUF_NONNULL Version::mutable_os()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:NoxProto.Version.os)
  return _s;
}
inline const ::std::string& Version::_internal_os() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.os_.Get();
}
inline void Version::_internal_set_os(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Version::_internal_mutable_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.os_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Version::release_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Version.os)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.os_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.os_.Set("", GetArena());
  }
  return released;
}
inline void Version::set_allocated_os(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Version.os)
}

// optional string os_version = 4;
inline bool Version::has_os_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Version::clear_os_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Version::os_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Version.os_version)
  return _internal_os_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Version::set_os_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.os_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Version.os_version)
}
inline ::std::string* PROTOBUF_NONNULL Version::mutable_os_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:NoxProto.Version.os_version)
  return _s;
}
inline const ::std::string& Version::_internal_os_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.os_version_.Get();
}
inline void Version::_internal_set_os_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.os_version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Version::_internal_mutable_os_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.os_version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Version::release_os_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Version.os_version)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.os_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.os_version_.Set("", GetArena());
  }
  return released;
}
inline void Version::set_allocated_os_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.os_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Version.os_version)
}

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
inline bool UDPTunnel::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UDPTunnel::clear_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UDPTunnel::packet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UDPTunnel.packet)
  return _internal_packet();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UDPTunnel::set_packet(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.packet_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UDPTunnel.packet)
}
inline ::std::string* PROTOBUF_NONNULL UDPTunnel::mutable_packet()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:NoxProto.UDPTunnel.packet)
  return _s;
}
inline const ::std::string& UDPTunnel::_internal_packet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packet_.Get();
}
inline void UDPTunnel::_internal_set_packet(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.packet_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UDPTunnel::_internal_mutable_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.packet_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UDPTunnel::release_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UDPTunnel.packet)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.packet_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.packet_.Set("", GetArena());
  }
  return released;
}
inline void UDPTunnel::set_allocated_packet(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.packet_.IsDefault()) {
    _impl_.packet_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UDPTunnel.packet)
}

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
inline bool Authenticate::has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Authenticate::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Authenticate::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Authenticate::set_username(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.username)
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::mutable_username()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:NoxProto.Authenticate.username)
  return _s;
}
inline const ::std::string& Authenticate::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void Authenticate::_internal_set_username(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Authenticate::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Authenticate.username)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.username_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.username_.Set("", GetArena());
  }
  return released;
}
inline void Authenticate::set_allocated_username(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Authenticate.username)
}

// optional string password = 2;
inline bool Authenticate::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Authenticate::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Authenticate::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Authenticate::set_password(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.password)
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::mutable_password()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:NoxProto.Authenticate.password)
  return _s;
}
inline const ::std::string& Authenticate::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void Authenticate::_internal_set_password(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Authenticate::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Authenticate.password)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_.Set("", GetArena());
  }
  return released;
}
inline void Authenticate::set_allocated_password(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Authenticate.password)
}

// repeated string tokens = 3;
inline int Authenticate::_internal_tokens_size() const {
  return _internal_tokens().size();
}
inline int Authenticate::tokens_size() const {
  return _internal_tokens_size();
}
inline void Authenticate::clear_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::add_tokens()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_tokens()->Add();
  // @@protoc_insertion_point(field_add_mutable:NoxProto.Authenticate.tokens)
  return _s;
}
inline const ::std::string& Authenticate::tokens(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.tokens)
  return _internal_tokens().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Authenticate::mutable_tokens(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.Authenticate.tokens)
  return _internal_mutable_tokens()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Authenticate::set_tokens(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_tokens()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.tokens)
}
template <typename Arg_, typename... Args_>
inline void Authenticate::add_tokens(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tokens(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:NoxProto.Authenticate.tokens)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Authenticate::tokens()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.Authenticate.tokens)
  return _internal_tokens();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Authenticate::mutable_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.Authenticate.tokens)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tokens();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Authenticate::_internal_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tokens_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Authenticate::_internal_mutable_tokens() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tokens_;
}

// repeated int32 celt_versions = 4;
inline int Authenticate::_internal_celt_versions_size() const {
  return _internal_celt_versions().size();
}
inline int Authenticate::celt_versions_size() const {
  return _internal_celt_versions_size();
}
inline void Authenticate::clear_celt_versions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.celt_versions_.Clear();
}
inline ::int32_t Authenticate::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.celt_versions)
  return _internal_celt_versions().Get(index);
}
inline void Authenticate::set_celt_versions(int index, ::int32_t value) {
  _internal_mutable_celt_versions()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.celt_versions)
}
inline void Authenticate::add_celt_versions(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_celt_versions()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.Authenticate.celt_versions)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Authenticate::celt_versions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.Authenticate.celt_versions)
  return _internal_celt_versions();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL Authenticate::mutable_celt_versions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.Authenticate.celt_versions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_celt_versions();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Authenticate::_internal_celt_versions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.celt_versions_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
Authenticate::_internal_mutable_celt_versions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.celt_versions_;
}

// optional bool opus = 5 [default = false];
inline bool Authenticate::has_opus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Authenticate::clear_opus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Authenticate::opus() const {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.opus)
  return _internal_opus();
}
inline void Authenticate::set_opus(bool value) {
  _internal_set_opus(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.opus)
}
inline bool Authenticate::_internal_opus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opus_;
}
inline void Authenticate::_internal_set_opus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = value;
}

// optional int32 client_type = 6 [default = 0];
inline bool Authenticate::has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Authenticate::clear_client_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Authenticate::client_type() const {
  // @@protoc_insertion_point(field_get:NoxProto.Authenticate.client_type)
  return _internal_client_type();
}
inline void Authenticate::set_client_type(::int32_t value) {
  _internal_set_client_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.Authenticate.client_type)
}
inline ::int32_t Authenticate::_internal_client_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_type_;
}
inline void Authenticate::_internal_set_client_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_type_ = value;
}

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
inline bool Ping::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Ping::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.timestamp)
  return _internal_timestamp();
}
inline void Ping::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.timestamp)
}
inline ::uint64_t Ping::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Ping::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional uint32 good = 2;
inline bool Ping::has_good() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Ping::clear_good() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.good_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Ping::good() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.good)
  return _internal_good();
}
inline void Ping::set_good(::uint32_t value) {
  _internal_set_good(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.good)
}
inline ::uint32_t Ping::_internal_good() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.good_;
}
inline void Ping::_internal_set_good(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.good_ = value;
}

// optional uint32 late = 3;
inline bool Ping::has_late() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Ping::clear_late() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.late_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Ping::late() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.late)
  return _internal_late();
}
inline void Ping::set_late(::uint32_t value) {
  _internal_set_late(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.late)
}
inline ::uint32_t Ping::_internal_late() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.late_;
}
inline void Ping::_internal_set_late(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.late_ = value;
}

// optional uint32 lost = 4;
inline bool Ping::has_lost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Ping::clear_lost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lost_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Ping::lost() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.lost)
  return _internal_lost();
}
inline void Ping::set_lost(::uint32_t value) {
  _internal_set_lost(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.lost)
}
inline ::uint32_t Ping::_internal_lost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lost_;
}
inline void Ping::_internal_set_lost(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lost_ = value;
}

// optional uint32 resync = 5;
inline bool Ping::has_resync() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Ping::clear_resync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resync_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Ping::resync() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.resync)
  return _internal_resync();
}
inline void Ping::set_resync(::uint32_t value) {
  _internal_set_resync(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.resync)
}
inline ::uint32_t Ping::_internal_resync() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resync_;
}
inline void Ping::_internal_set_resync(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resync_ = value;
}

// optional uint32 udp_packets = 6;
inline bool Ping::has_udp_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Ping::clear_udp_packets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t Ping::udp_packets() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.udp_packets)
  return _internal_udp_packets();
}
inline void Ping::set_udp_packets(::uint32_t value) {
  _internal_set_udp_packets(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.udp_packets)
}
inline ::uint32_t Ping::_internal_udp_packets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_packets_;
}
inline void Ping::_internal_set_udp_packets(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_packets_ = value;
}

// optional uint32 tcp_packets = 7;
inline bool Ping::has_tcp_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Ping::clear_tcp_packets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t Ping::tcp_packets() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.tcp_packets)
  return _internal_tcp_packets();
}
inline void Ping::set_tcp_packets(::uint32_t value) {
  _internal_set_tcp_packets(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.tcp_packets)
}
inline ::uint32_t Ping::_internal_tcp_packets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_packets_;
}
inline void Ping::_internal_set_tcp_packets(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_packets_ = value;
}

// optional float udp_ping_avg = 8;
inline bool Ping::has_udp_ping_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Ping::clear_udp_ping_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_avg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Ping::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.udp_ping_avg)
  return _internal_udp_ping_avg();
}
inline void Ping::set_udp_ping_avg(float value) {
  _internal_set_udp_ping_avg(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.udp_ping_avg)
}
inline float Ping::_internal_udp_ping_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_ping_avg_;
}
inline void Ping::_internal_set_udp_ping_avg(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_avg_ = value;
}

// optional float udp_ping_var = 9;
inline bool Ping::has_udp_ping_var() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Ping::clear_udp_ping_var() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_var_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Ping::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.udp_ping_var)
  return _internal_udp_ping_var();
}
inline void Ping::set_udp_ping_var(float value) {
  _internal_set_udp_ping_var(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.udp_ping_var)
}
inline float Ping::_internal_udp_ping_var() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_ping_var_;
}
inline void Ping::_internal_set_udp_ping_var(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_var_ = value;
}

// optional float tcp_ping_avg = 10;
inline bool Ping::has_tcp_ping_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Ping::clear_tcp_ping_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_avg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Ping::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.tcp_ping_avg)
  return _internal_tcp_ping_avg();
}
inline void Ping::set_tcp_ping_avg(float value) {
  _internal_set_tcp_ping_avg(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.tcp_ping_avg)
}
inline float Ping::_internal_tcp_ping_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_ping_avg_;
}
inline void Ping::_internal_set_tcp_ping_avg(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_avg_ = value;
}

// optional float tcp_ping_var = 11;
inline bool Ping::has_tcp_ping_var() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void Ping::clear_tcp_ping_var() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_var_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Ping::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:NoxProto.Ping.tcp_ping_var)
  return _internal_tcp_ping_var();
}
inline void Ping::set_tcp_ping_var(float value) {
  _internal_set_tcp_ping_var(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:NoxProto.Ping.tcp_ping_var)
}
inline float Ping::_internal_tcp_ping_var() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_ping_var_;
}
inline void Ping::_internal_set_tcp_ping_var(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_var_ = value;
}

// -------------------------------------------------------------------

// Reject

// optional .NoxProto.Reject.RejectType type = 1;
inline bool Reject::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Reject::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::NoxProto::Reject_RejectType Reject::type() const {
  // @@protoc_insertion_point(field_get:NoxProto.Reject.type)
  return _internal_type();
}
inline void Reject::set_type(::NoxProto::Reject_RejectType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.Reject.type)
}
inline ::NoxProto::Reject_RejectType Reject::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::NoxProto::Reject_RejectType>(_impl_.type_);
}
inline void Reject::_internal_set_type(::NoxProto::Reject_RejectType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::NoxProto::Reject_RejectType_internal_data_));
                                          _impl_.type_ = value;
}

// optional string reason = 2;
inline bool Reject::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Reject::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Reject::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.Reject.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Reject::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.Reject.reason)
}
inline ::std::string* PROTOBUF_NONNULL Reject::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:NoxProto.Reject.reason)
  return _s;
}
inline const ::std::string& Reject::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void Reject::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Reject::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Reject::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.Reject.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void Reject::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.Reject.reason)
}

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
inline bool ServerSync::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ServerSync::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ServerSync::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerSync.session)
  return _internal_session();
}
inline void ServerSync::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerSync.session)
}
inline ::uint32_t ServerSync::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void ServerSync::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional uint32 max_bandwidth = 2;
inline bool ServerSync::has_max_bandwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ServerSync::clear_max_bandwidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bandwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ServerSync::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerSync.max_bandwidth)
  return _internal_max_bandwidth();
}
inline void ServerSync::set_max_bandwidth(::uint32_t value) {
  _internal_set_max_bandwidth(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerSync.max_bandwidth)
}
inline ::uint32_t ServerSync::_internal_max_bandwidth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_bandwidth_;
}
inline void ServerSync::_internal_set_max_bandwidth(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bandwidth_ = value;
}

// optional string welcome_text = 3;
inline bool ServerSync::has_welcome_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServerSync::clear_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.welcome_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ServerSync::welcome_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ServerSync.welcome_text)
  return _internal_welcome_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ServerSync::set_welcome_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.welcome_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ServerSync.welcome_text)
}
inline ::std::string* PROTOBUF_NONNULL ServerSync::mutable_welcome_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_welcome_text();
  // @@protoc_insertion_point(field_mutable:NoxProto.ServerSync.welcome_text)
  return _s;
}
inline const ::std::string& ServerSync::_internal_welcome_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.welcome_text_.Get();
}
inline void ServerSync::_internal_set_welcome_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.welcome_text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ServerSync::_internal_mutable_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.welcome_text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ServerSync::release_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ServerSync.welcome_text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.welcome_text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.welcome_text_.Set("", GetArena());
  }
  return released;
}
inline void ServerSync::set_allocated_welcome_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.welcome_text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.welcome_text_.IsDefault()) {
    _impl_.welcome_text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ServerSync.welcome_text)
}

// optional uint64 permissions = 4;
inline bool ServerSync::has_permissions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServerSync::clear_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t ServerSync::permissions() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerSync.permissions)
  return _internal_permissions();
}
inline void ServerSync::set_permissions(::uint64_t value) {
  _internal_set_permissions(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerSync.permissions)
}
inline ::uint64_t ServerSync::_internal_permissions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permissions_;
}
inline void ServerSync::_internal_set_permissions(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_ = value;
}

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
inline bool ChannelRemove::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelRemove::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ChannelRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelRemove.channel_id)
  return _internal_channel_id();
}
inline void ChannelRemove::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelRemove.channel_id)
}
inline ::uint32_t ChannelRemove::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void ChannelRemove::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
inline bool ChannelState::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChannelState::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ChannelState::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.channel_id)
  return _internal_channel_id();
}
inline void ChannelState::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.channel_id)
}
inline ::uint32_t ChannelState::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void ChannelState::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional uint32 parent = 2;
inline bool ChannelState::has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChannelState::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t ChannelState::parent() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.parent)
  return _internal_parent();
}
inline void ChannelState::set_parent(::uint32_t value) {
  _internal_set_parent(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.parent)
}
inline ::uint32_t ChannelState::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_;
}
inline void ChannelState::_internal_set_parent(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_ = value;
}

// optional string name = 3;
inline bool ChannelState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelState::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChannelState::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChannelState::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.name)
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.ChannelState.name)
  return _s;
}
inline const ::std::string& ChannelState::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ChannelState::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChannelState::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ChannelState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ChannelState::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ChannelState.name)
}

// repeated uint32 links = 4;
inline int ChannelState::_internal_links_size() const {
  return _internal_links().size();
}
inline int ChannelState::links_size() const {
  return _internal_links_size();
}
inline void ChannelState::clear_links() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.links_.Clear();
}
inline ::uint32_t ChannelState::links(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.links)
  return _internal_links().Get(index);
}
inline void ChannelState::set_links(int index, ::uint32_t value) {
  _internal_mutable_links()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.links)
}
inline void ChannelState::add_links(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_links()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ChannelState.links)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ChannelState::links() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ChannelState.links)
  return _internal_links();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ChannelState::mutable_links()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ChannelState.links)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_links();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ChannelState::_internal_links() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.links_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ChannelState::_internal_mutable_links() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.links_;
}

// optional string description = 5;
inline bool ChannelState::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelState::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ChannelState::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChannelState::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.description)
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:NoxProto.ChannelState.description)
  return _s;
}
inline const ::std::string& ChannelState::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void ChannelState::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChannelState::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ChannelState.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void ChannelState::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ChannelState.description)
}

// repeated uint32 links_add = 6;
inline int ChannelState::_internal_links_add_size() const {
  return _internal_links_add().size();
}
inline int ChannelState::links_add_size() const {
  return _internal_links_add_size();
}
inline void ChannelState::clear_links_add() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.links_add_.Clear();
}
inline ::uint32_t ChannelState::links_add(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.links_add)
  return _internal_links_add().Get(index);
}
inline void ChannelState::set_links_add(int index, ::uint32_t value) {
  _internal_mutable_links_add()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.links_add)
}
inline void ChannelState::add_links_add(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_links_add()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ChannelState.links_add)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ChannelState::links_add() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ChannelState.links_add)
  return _internal_links_add();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ChannelState::mutable_links_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ChannelState.links_add)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_links_add();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ChannelState::_internal_links_add() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.links_add_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ChannelState::_internal_mutable_links_add() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.links_add_;
}

// repeated uint32 links_remove = 7;
inline int ChannelState::_internal_links_remove_size() const {
  return _internal_links_remove().size();
}
inline int ChannelState::links_remove_size() const {
  return _internal_links_remove_size();
}
inline void ChannelState::clear_links_remove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.links_remove_.Clear();
}
inline ::uint32_t ChannelState::links_remove(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.links_remove)
  return _internal_links_remove().Get(index);
}
inline void ChannelState::set_links_remove(int index, ::uint32_t value) {
  _internal_mutable_links_remove()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.links_remove)
}
inline void ChannelState::add_links_remove(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_links_remove()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ChannelState.links_remove)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ChannelState::links_remove() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ChannelState.links_remove)
  return _internal_links_remove();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ChannelState::mutable_links_remove()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ChannelState.links_remove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_links_remove();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ChannelState::_internal_links_remove() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.links_remove_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ChannelState::_internal_mutable_links_remove() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.links_remove_;
}

// optional bool temporary = 8 [default = false];
inline bool ChannelState::has_temporary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ChannelState::clear_temporary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ChannelState::temporary() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.temporary)
  return _internal_temporary();
}
inline void ChannelState::set_temporary(bool value) {
  _internal_set_temporary(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.temporary)
}
inline bool ChannelState::_internal_temporary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.temporary_;
}
inline void ChannelState::_internal_set_temporary(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_ = value;
}

// optional int32 position = 9 [default = 0];
inline bool ChannelState::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ChannelState::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t ChannelState::position() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.position)
  return _internal_position();
}
inline void ChannelState::set_position(::int32_t value) {
  _internal_set_position(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.position)
}
inline ::int32_t ChannelState::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_;
}
inline void ChannelState::_internal_set_position(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_ = value;
}

// optional bytes description_hash = 10;
inline bool ChannelState::has_description_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelState::clear_description_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ChannelState::description_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.description_hash)
  return _internal_description_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChannelState::set_description_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.description_hash)
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::mutable_description_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description_hash();
  // @@protoc_insertion_point(field_mutable:NoxProto.ChannelState.description_hash)
  return _s;
}
inline const ::std::string& ChannelState::_internal_description_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_hash_.Get();
}
inline void ChannelState::_internal_set_description_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChannelState::_internal_mutable_description_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChannelState::release_description_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ChannelState.description_hash)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_hash_.Set("", GetArena());
  }
  return released;
}
inline void ChannelState::set_allocated_description_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_hash_.IsDefault()) {
    _impl_.description_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ChannelState.description_hash)
}

// optional uint32 max_users = 11;
inline bool ChannelState::has_max_users() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ChannelState::clear_max_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_users_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t ChannelState::max_users() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.max_users)
  return _internal_max_users();
}
inline void ChannelState::set_max_users(::uint32_t value) {
  _internal_set_max_users(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.max_users)
}
inline ::uint32_t ChannelState::_internal_max_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_users_;
}
inline void ChannelState::_internal_set_max_users(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_users_ = value;
}

// optional bool is_enter_restricted = 12;
inline bool ChannelState::has_is_enter_restricted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ChannelState::clear_is_enter_restricted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_enter_restricted_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ChannelState::is_enter_restricted() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.is_enter_restricted)
  return _internal_is_enter_restricted();
}
inline void ChannelState::set_is_enter_restricted(bool value) {
  _internal_set_is_enter_restricted(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.is_enter_restricted)
}
inline bool ChannelState::_internal_is_enter_restricted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_enter_restricted_;
}
inline void ChannelState::_internal_set_is_enter_restricted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_enter_restricted_ = value;
}

// optional bool can_enter = 13;
inline bool ChannelState::has_can_enter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ChannelState::clear_can_enter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_enter_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ChannelState::can_enter() const {
  // @@protoc_insertion_point(field_get:NoxProto.ChannelState.can_enter)
  return _internal_can_enter();
}
inline void ChannelState::set_can_enter(bool value) {
  _internal_set_can_enter(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:NoxProto.ChannelState.can_enter)
}
inline bool ChannelState::_internal_can_enter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.can_enter_;
}
inline void ChannelState::_internal_set_can_enter(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_enter_ = value;
}

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
inline bool UserRemove::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserRemove::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserRemove::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.session)
  return _internal_session();
}
inline void UserRemove::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.session)
}
inline ::uint32_t UserRemove::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void UserRemove::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional uint32 actor = 2;
inline bool UserRemove::has_actor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserRemove::clear_actor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserRemove::actor() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.actor)
  return _internal_actor();
}
inline void UserRemove::set_actor(::uint32_t value) {
  _internal_set_actor(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.actor)
}
inline ::uint32_t UserRemove::_internal_actor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actor_;
}
inline void UserRemove::_internal_set_actor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = value;
}

// optional string reason = 3;
inline bool UserRemove::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserRemove::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserRemove::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserRemove::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.reason)
}
inline ::std::string* PROTOBUF_NONNULL UserRemove::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserRemove.reason)
  return _s;
}
inline const ::std::string& UserRemove::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void UserRemove::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserRemove::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserRemove::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserRemove.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void UserRemove::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserRemove.reason)
}

// optional bool ban = 4;
inline bool UserRemove::has_ban() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserRemove::clear_ban() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool UserRemove::ban() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.ban)
  return _internal_ban();
}
inline void UserRemove::set_ban(bool value) {
  _internal_set_ban(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.ban)
}
inline bool UserRemove::_internal_ban() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ban_;
}
inline void UserRemove::_internal_set_ban(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_ = value;
}

// optional bool ban_certificate = 5;
inline bool UserRemove::has_ban_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserRemove::clear_ban_certificate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_certificate_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool UserRemove::ban_certificate() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.ban_certificate)
  return _internal_ban_certificate();
}
inline void UserRemove::set_ban_certificate(bool value) {
  _internal_set_ban_certificate(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.ban_certificate)
}
inline bool UserRemove::_internal_ban_certificate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ban_certificate_;
}
inline void UserRemove::_internal_set_ban_certificate(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_certificate_ = value;
}

// optional bool ban_ip = 6;
inline bool UserRemove::has_ban_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserRemove::clear_ban_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_ip_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UserRemove::ban_ip() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserRemove.ban_ip)
  return _internal_ban_ip();
}
inline void UserRemove::set_ban_ip(bool value) {
  _internal_set_ban_ip(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.UserRemove.ban_ip)
}
inline bool UserRemove::_internal_ban_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ban_ip_;
}
inline void UserRemove::_internal_set_ban_ip(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ban_ip_ = value;
}

// -------------------------------------------------------------------

// UserState_VolumeAdjustment

// optional uint32 listening_channel = 1;
inline bool UserState_VolumeAdjustment::has_listening_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserState_VolumeAdjustment::clear_listening_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listening_channel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UserState_VolumeAdjustment::listening_channel() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.VolumeAdjustment.listening_channel)
  return _internal_listening_channel();
}
inline void UserState_VolumeAdjustment::set_listening_channel(::uint32_t value) {
  _internal_set_listening_channel(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.VolumeAdjustment.listening_channel)
}
inline ::uint32_t UserState_VolumeAdjustment::_internal_listening_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listening_channel_;
}
inline void UserState_VolumeAdjustment::_internal_set_listening_channel(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listening_channel_ = value;
}

// optional float volume_adjustment = 2;
inline bool UserState_VolumeAdjustment::has_volume_adjustment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserState_VolumeAdjustment::clear_volume_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.volume_adjustment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UserState_VolumeAdjustment::volume_adjustment() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.VolumeAdjustment.volume_adjustment)
  return _internal_volume_adjustment();
}
inline void UserState_VolumeAdjustment::set_volume_adjustment(float value) {
  _internal_set_volume_adjustment(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.VolumeAdjustment.volume_adjustment)
}
inline float UserState_VolumeAdjustment::_internal_volume_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.volume_adjustment_;
}
inline void UserState_VolumeAdjustment::_internal_set_volume_adjustment(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.volume_adjustment_ = value;
}

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
inline bool UserState::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserState::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t UserState::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.session)
  return _internal_session();
}
inline void UserState::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.session)
}
inline ::uint32_t UserState::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void UserState::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional uint32 actor = 2;
inline bool UserState::has_actor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserState::clear_actor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t UserState::actor() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.actor)
  return _internal_actor();
}
inline void UserState::set_actor(::uint32_t value) {
  _internal_set_actor(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.actor)
}
inline ::uint32_t UserState::_internal_actor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actor_;
}
inline void UserState::_internal_set_actor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = value;
}

// optional string name = 3;
inline bool UserState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserState::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserState::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.name)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.name)
  return _s;
}
inline const ::std::string& UserState::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void UserState::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.name)
}

// optional uint32 user_id = 4;
inline bool UserState::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UserState::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t UserState::user_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.user_id)
  return _internal_user_id();
}
inline void UserState::set_user_id(::uint32_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.user_id)
}
inline ::uint32_t UserState::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void UserState::_internal_set_user_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// optional uint32 channel_id = 5;
inline bool UserState::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void UserState::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t UserState::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.channel_id)
  return _internal_channel_id();
}
inline void UserState::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.channel_id)
}
inline ::uint32_t UserState::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void UserState::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional bool mute = 6;
inline bool UserState::has_mute() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void UserState::clear_mute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mute_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool UserState::mute() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.mute)
  return _internal_mute();
}
inline void UserState::set_mute(bool value) {
  _internal_set_mute(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.mute)
}
inline bool UserState::_internal_mute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mute_;
}
inline void UserState::_internal_set_mute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mute_ = value;
}

// optional bool deaf = 7;
inline bool UserState::has_deaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void UserState::clear_deaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deaf_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool UserState::deaf() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.deaf)
  return _internal_deaf();
}
inline void UserState::set_deaf(bool value) {
  _internal_set_deaf(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.deaf)
}
inline bool UserState::_internal_deaf() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deaf_;
}
inline void UserState::_internal_set_deaf(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deaf_ = value;
}

// optional bool suppress = 8;
inline bool UserState::has_suppress() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void UserState::clear_suppress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suppress_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool UserState::suppress() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.suppress)
  return _internal_suppress();
}
inline void UserState::set_suppress(bool value) {
  _internal_set_suppress(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.suppress)
}
inline bool UserState::_internal_suppress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suppress_;
}
inline void UserState::_internal_set_suppress(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suppress_ = value;
}

// optional bool self_mute = 9;
inline bool UserState::has_self_mute() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void UserState::clear_self_mute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_mute_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool UserState::self_mute() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.self_mute)
  return _internal_self_mute();
}
inline void UserState::set_self_mute(bool value) {
  _internal_set_self_mute(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.self_mute)
}
inline bool UserState::_internal_self_mute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.self_mute_;
}
inline void UserState::_internal_set_self_mute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_mute_ = value;
}

// optional bool self_deaf = 10;
inline bool UserState::has_self_deaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void UserState::clear_self_deaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_deaf_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool UserState::self_deaf() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.self_deaf)
  return _internal_self_deaf();
}
inline void UserState::set_self_deaf(bool value) {
  _internal_set_self_deaf(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.self_deaf)
}
inline bool UserState::_internal_self_deaf() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.self_deaf_;
}
inline void UserState::_internal_set_self_deaf(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_deaf_ = value;
}

// optional bytes texture = 11;
inline bool UserState::has_texture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserState::clear_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texture_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& UserState::texture() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.texture)
  return _internal_texture();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_texture(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.texture_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.texture)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_texture();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.texture)
  return _s;
}
inline const ::std::string& UserState::_internal_texture() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.texture_.Get();
}
inline void UserState::_internal_set_texture(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.texture_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.texture_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.texture)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.texture_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.texture_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_texture(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.texture_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.texture_.IsDefault()) {
    _impl_.texture_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.texture)
}

// optional bytes plugin_context = 12;
inline bool UserState::has_plugin_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserState::clear_plugin_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_context_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& UserState::plugin_context() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.plugin_context)
  return _internal_plugin_context();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_plugin_context(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.plugin_context_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.plugin_context)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_plugin_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_plugin_context();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.plugin_context)
  return _s;
}
inline const ::std::string& UserState::_internal_plugin_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plugin_context_.Get();
}
inline void UserState::_internal_set_plugin_context(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.plugin_context_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_plugin_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.plugin_context_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_plugin_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.plugin_context)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.plugin_context_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.plugin_context_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_plugin_context(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.plugin_context_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.plugin_context_.IsDefault()) {
    _impl_.plugin_context_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.plugin_context)
}

// optional string plugin_identity = 13;
inline bool UserState::has_plugin_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserState::clear_plugin_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& UserState::plugin_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.plugin_identity)
  return _internal_plugin_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_plugin_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.plugin_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.plugin_identity)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_plugin_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_plugin_identity();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.plugin_identity)
  return _s;
}
inline const ::std::string& UserState::_internal_plugin_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plugin_identity_.Get();
}
inline void UserState::_internal_set_plugin_identity(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.plugin_identity_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_plugin_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.plugin_identity_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_plugin_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.plugin_identity)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.plugin_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.plugin_identity_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_plugin_identity(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.plugin_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.plugin_identity_.IsDefault()) {
    _impl_.plugin_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.plugin_identity)
}

// optional string comment = 14;
inline bool UserState::has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserState::clear_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& UserState::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_comment(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.comment)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_comment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.comment)
  return _s;
}
inline const ::std::string& UserState::_internal_comment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.comment_.Get();
}
inline void UserState::_internal_set_comment(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.comment_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.comment_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.comment)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.comment_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.comment_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_comment(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.comment_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.comment)
}

// optional string hash = 15;
inline bool UserState::has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserState::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& UserState::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.hash)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.hash)
  return _s;
}
inline const ::std::string& UserState::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void UserState::_internal_set_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.hash)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.hash)
}

// optional bytes comment_hash = 16;
inline bool UserState::has_comment_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserState::clear_comment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& UserState::comment_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.comment_hash)
  return _internal_comment_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_comment_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.comment_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.comment_hash)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_comment_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_comment_hash();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.comment_hash)
  return _s;
}
inline const ::std::string& UserState::_internal_comment_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.comment_hash_.Get();
}
inline void UserState::_internal_set_comment_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.comment_hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_comment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.comment_hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_comment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.comment_hash)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.comment_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.comment_hash_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_comment_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.comment_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.comment_hash_.IsDefault()) {
    _impl_.comment_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.comment_hash)
}

// optional bytes texture_hash = 17;
inline bool UserState::has_texture_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserState::clear_texture_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texture_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::std::string& UserState::texture_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.texture_hash)
  return _internal_texture_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserState::set_texture_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.texture_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserState.texture_hash)
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_texture_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_texture_hash();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.texture_hash)
  return _s;
}
inline const ::std::string& UserState::_internal_texture_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.texture_hash_.Get();
}
inline void UserState::_internal_set_texture_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.texture_hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserState::_internal_mutable_texture_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.texture_hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserState::release_texture_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserState.texture_hash)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.texture_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.texture_hash_.Set("", GetArena());
  }
  return released;
}
inline void UserState::set_allocated_texture_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.texture_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.texture_hash_.IsDefault()) {
    _impl_.texture_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserState.texture_hash)
}

// optional bool priority_speaker = 18;
inline bool UserState::has_priority_speaker() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void UserState::clear_priority_speaker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_speaker_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool UserState::priority_speaker() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.priority_speaker)
  return _internal_priority_speaker();
}
inline void UserState::set_priority_speaker(bool value) {
  _internal_set_priority_speaker(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.priority_speaker)
}
inline bool UserState::_internal_priority_speaker() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_speaker_;
}
inline void UserState::_internal_set_priority_speaker(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_speaker_ = value;
}

// optional bool recording = 19;
inline bool UserState::has_recording() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void UserState::clear_recording() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recording_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool UserState::recording() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.recording)
  return _internal_recording();
}
inline void UserState::set_recording(bool value) {
  _internal_set_recording(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserState.recording)
}
inline bool UserState::_internal_recording() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recording_;
}
inline void UserState::_internal_set_recording(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recording_ = value;
}

// repeated string temporary_access_tokens = 20;
inline int UserState::_internal_temporary_access_tokens_size() const {
  return _internal_temporary_access_tokens().size();
}
inline int UserState::temporary_access_tokens_size() const {
  return _internal_temporary_access_tokens_size();
}
inline void UserState::clear_temporary_access_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_access_tokens_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL UserState::add_temporary_access_tokens()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_temporary_access_tokens()->Add();
  // @@protoc_insertion_point(field_add_mutable:NoxProto.UserState.temporary_access_tokens)
  return _s;
}
inline const ::std::string& UserState::temporary_access_tokens(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.temporary_access_tokens)
  return _internal_temporary_access_tokens().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL UserState::mutable_temporary_access_tokens(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.temporary_access_tokens)
  return _internal_mutable_temporary_access_tokens()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UserState::set_temporary_access_tokens(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_temporary_access_tokens()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:NoxProto.UserState.temporary_access_tokens)
}
template <typename Arg_, typename... Args_>
inline void UserState::add_temporary_access_tokens(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_temporary_access_tokens(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:NoxProto.UserState.temporary_access_tokens)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& UserState::temporary_access_tokens()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserState.temporary_access_tokens)
  return _internal_temporary_access_tokens();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UserState::mutable_temporary_access_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserState.temporary_access_tokens)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_temporary_access_tokens();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
UserState::_internal_temporary_access_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.temporary_access_tokens_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UserState::_internal_mutable_temporary_access_tokens() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.temporary_access_tokens_;
}

// repeated uint32 listening_channel_add = 21;
inline int UserState::_internal_listening_channel_add_size() const {
  return _internal_listening_channel_add().size();
}
inline int UserState::listening_channel_add_size() const {
  return _internal_listening_channel_add_size();
}
inline void UserState::clear_listening_channel_add() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listening_channel_add_.Clear();
}
inline ::uint32_t UserState::listening_channel_add(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.listening_channel_add)
  return _internal_listening_channel_add().Get(index);
}
inline void UserState::set_listening_channel_add(int index, ::uint32_t value) {
  _internal_mutable_listening_channel_add()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.UserState.listening_channel_add)
}
inline void UserState::add_listening_channel_add(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_listening_channel_add()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.UserState.listening_channel_add)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UserState::listening_channel_add() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserState.listening_channel_add)
  return _internal_listening_channel_add();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL UserState::mutable_listening_channel_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserState.listening_channel_add)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_listening_channel_add();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UserState::_internal_listening_channel_add() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listening_channel_add_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
UserState::_internal_mutable_listening_channel_add() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.listening_channel_add_;
}

// repeated uint32 listening_channel_remove = 22;
inline int UserState::_internal_listening_channel_remove_size() const {
  return _internal_listening_channel_remove().size();
}
inline int UserState::listening_channel_remove_size() const {
  return _internal_listening_channel_remove_size();
}
inline void UserState::clear_listening_channel_remove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listening_channel_remove_.Clear();
}
inline ::uint32_t UserState::listening_channel_remove(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.listening_channel_remove)
  return _internal_listening_channel_remove().Get(index);
}
inline void UserState::set_listening_channel_remove(int index, ::uint32_t value) {
  _internal_mutable_listening_channel_remove()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.UserState.listening_channel_remove)
}
inline void UserState::add_listening_channel_remove(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_listening_channel_remove()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.UserState.listening_channel_remove)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UserState::listening_channel_remove() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserState.listening_channel_remove)
  return _internal_listening_channel_remove();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL UserState::mutable_listening_channel_remove()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserState.listening_channel_remove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_listening_channel_remove();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UserState::_internal_listening_channel_remove() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listening_channel_remove_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
UserState::_internal_mutable_listening_channel_remove() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.listening_channel_remove_;
}

// repeated .NoxProto.UserState.VolumeAdjustment listening_volume_adjustment = 23;
inline int UserState::_internal_listening_volume_adjustment_size() const {
  return _internal_listening_volume_adjustment().size();
}
inline int UserState::listening_volume_adjustment_size() const {
  return _internal_listening_volume_adjustment_size();
}
inline void UserState::clear_listening_volume_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listening_volume_adjustment_.Clear();
}
inline ::NoxProto::UserState_VolumeAdjustment* PROTOBUF_NONNULL UserState::mutable_listening_volume_adjustment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.UserState.listening_volume_adjustment)
  return _internal_mutable_listening_volume_adjustment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>* PROTOBUF_NONNULL UserState::mutable_listening_volume_adjustment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserState.listening_volume_adjustment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_listening_volume_adjustment();
}
inline const ::NoxProto::UserState_VolumeAdjustment& UserState::listening_volume_adjustment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserState.listening_volume_adjustment)
  return _internal_listening_volume_adjustment().Get(index);
}
inline ::NoxProto::UserState_VolumeAdjustment* PROTOBUF_NONNULL UserState::add_listening_volume_adjustment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::UserState_VolumeAdjustment* _add = _internal_mutable_listening_volume_adjustment()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.UserState.listening_volume_adjustment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>& UserState::listening_volume_adjustment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserState.listening_volume_adjustment)
  return _internal_listening_volume_adjustment();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>&
UserState::_internal_listening_volume_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listening_volume_adjustment_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::UserState_VolumeAdjustment>* PROTOBUF_NONNULL
UserState::_internal_mutable_listening_volume_adjustment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.listening_volume_adjustment_;
}

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
inline bool BanList_BanEntry::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BanList_BanEntry::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BanList_BanEntry::set_address(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.address)
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::mutable_address()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.BanEntry.address)
  return _s;
}
inline const ::std::string& BanList_BanEntry::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void BanList_BanEntry::_internal_set_address(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BanList_BanEntry::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.BanList.BanEntry.address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.address_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.address_.Set("", GetArena());
  }
  return released;
}
inline void BanList_BanEntry::set_allocated_address(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.BanList.BanEntry.address)
}

// required uint32 mask = 2;
inline bool BanList_BanEntry::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t BanList_BanEntry::mask() const {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.mask)
  return _internal_mask();
}
inline void BanList_BanEntry::set_mask(::uint32_t value) {
  _internal_set_mask(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.mask)
}
inline ::uint32_t BanList_BanEntry::_internal_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mask_;
}
inline void BanList_BanEntry::_internal_set_mask(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mask_ = value;
}

// optional string name = 3;
inline bool BanList_BanEntry::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BanList_BanEntry::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BanList_BanEntry::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.name)
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.BanEntry.name)
  return _s;
}
inline const ::std::string& BanList_BanEntry::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BanList_BanEntry::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BanList_BanEntry::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.BanList.BanEntry.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void BanList_BanEntry::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.BanList.BanEntry.name)
}

// optional string hash = 4;
inline bool BanList_BanEntry::has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BanList_BanEntry::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BanList_BanEntry::set_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.hash)
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::mutable_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.BanEntry.hash)
  return _s;
}
inline const ::std::string& BanList_BanEntry::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void BanList_BanEntry::_internal_set_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BanList_BanEntry::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.BanList.BanEntry.hash)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_.Set("", GetArena());
  }
  return released;
}
inline void BanList_BanEntry::set_allocated_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.BanList.BanEntry.hash)
}

// optional string reason = 5;
inline bool BanList_BanEntry::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& BanList_BanEntry::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BanList_BanEntry::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.reason)
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.BanEntry.reason)
  return _s;
}
inline const ::std::string& BanList_BanEntry::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void BanList_BanEntry::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BanList_BanEntry::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.BanList.BanEntry.reason)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void BanList_BanEntry::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.BanList.BanEntry.reason)
}

// optional string start = 6;
inline bool BanList_BanEntry::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& BanList_BanEntry::start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.start)
  return _internal_start();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BanList_BanEntry::set_start(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.start)
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::mutable_start()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.BanEntry.start)
  return _s;
}
inline const ::std::string& BanList_BanEntry::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_.Get();
}
inline void BanList_BanEntry::_internal_set_start(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.start_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BanList_BanEntry::_internal_mutable_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.start_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BanList_BanEntry::release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.BanList.BanEntry.start)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.start_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_.Set("", GetArena());
  }
  return released;
}
inline void BanList_BanEntry::set_allocated_start(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.start_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_.IsDefault()) {
    _impl_.start_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.BanList.BanEntry.start)
}

// optional uint32 duration = 7;
inline bool BanList_BanEntry::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BanList_BanEntry::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t BanList_BanEntry::duration() const {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.BanEntry.duration)
  return _internal_duration();
}
inline void BanList_BanEntry::set_duration(::uint32_t value) {
  _internal_set_duration(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.BanList.BanEntry.duration)
}
inline ::uint32_t BanList_BanEntry::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void BanList_BanEntry::_internal_set_duration(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// -------------------------------------------------------------------

// BanList

// repeated .NoxProto.BanList.BanEntry bans = 1;
inline int BanList::_internal_bans_size() const {
  return _internal_bans().size();
}
inline int BanList::bans_size() const {
  return _internal_bans_size();
}
inline void BanList::clear_bans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bans_.Clear();
}
inline ::NoxProto::BanList_BanEntry* PROTOBUF_NONNULL BanList::mutable_bans(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.BanList.bans)
  return _internal_mutable_bans()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>* PROTOBUF_NONNULL BanList::mutable_bans()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.BanList.bans)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bans();
}
inline const ::NoxProto::BanList_BanEntry& BanList::bans(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.bans)
  return _internal_bans().Get(index);
}
inline ::NoxProto::BanList_BanEntry* PROTOBUF_NONNULL BanList::add_bans()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::BanList_BanEntry* _add = _internal_mutable_bans()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.BanList.bans)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>& BanList::bans() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.BanList.bans)
  return _internal_bans();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>&
BanList::_internal_bans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bans_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::BanList_BanEntry>* PROTOBUF_NONNULL
BanList::_internal_mutable_bans() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bans_;
}

// optional bool query = 2 [default = false];
inline bool BanList::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BanList::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BanList::query() const {
  // @@protoc_insertion_point(field_get:NoxProto.BanList.query)
  return _internal_query();
}
inline void BanList::set_query(bool value) {
  _internal_set_query(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.BanList.query)
}
inline bool BanList::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_;
}
inline void BanList::_internal_set_query(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_ = value;
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
inline bool TextMessage::has_actor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TextMessage::clear_actor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TextMessage::actor() const {
  // @@protoc_insertion_point(field_get:NoxProto.TextMessage.actor)
  return _internal_actor();
}
inline void TextMessage::set_actor(::uint32_t value) {
  _internal_set_actor(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.TextMessage.actor)
}
inline ::uint32_t TextMessage::_internal_actor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actor_;
}
inline void TextMessage::_internal_set_actor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = value;
}

// repeated uint32 session = 2;
inline int TextMessage::_internal_session_size() const {
  return _internal_session().size();
}
inline int TextMessage::session_size() const {
  return _internal_session_size();
}
inline void TextMessage::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_.Clear();
}
inline ::uint32_t TextMessage::session(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.TextMessage.session)
  return _internal_session().Get(index);
}
inline void TextMessage::set_session(int index, ::uint32_t value) {
  _internal_mutable_session()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.TextMessage.session)
}
inline void TextMessage::add_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_session()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.TextMessage.session)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TextMessage::session() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.TextMessage.session)
  return _internal_session();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL TextMessage::mutable_session()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.TextMessage.session)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_session();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
TextMessage::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
TextMessage::_internal_mutable_session() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.session_;
}

// repeated uint32 channel_id = 3;
inline int TextMessage::_internal_channel_id_size() const {
  return _internal_channel_id().size();
}
inline int TextMessage::channel_id_size() const {
  return _internal_channel_id_size();
}
inline void TextMessage::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_.Clear();
}
inline ::uint32_t TextMessage::channel_id(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.TextMessage.channel_id)
  return _internal_channel_id().Get(index);
}
inline void TextMessage::set_channel_id(int index, ::uint32_t value) {
  _internal_mutable_channel_id()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.TextMessage.channel_id)
}
inline void TextMessage::add_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_id()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.TextMessage.channel_id)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TextMessage::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.TextMessage.channel_id)
  return _internal_channel_id();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL TextMessage::mutable_channel_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.TextMessage.channel_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channel_id();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
TextMessage::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
TextMessage::_internal_mutable_channel_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channel_id_;
}

// repeated uint32 tree_id = 4;
inline int TextMessage::_internal_tree_id_size() const {
  return _internal_tree_id().size();
}
inline int TextMessage::tree_id_size() const {
  return _internal_tree_id_size();
}
inline void TextMessage::clear_tree_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_id_.Clear();
}
inline ::uint32_t TextMessage::tree_id(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.TextMessage.tree_id)
  return _internal_tree_id().Get(index);
}
inline void TextMessage::set_tree_id(int index, ::uint32_t value) {
  _internal_mutable_tree_id()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.TextMessage.tree_id)
}
inline void TextMessage::add_tree_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tree_id()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.TextMessage.tree_id)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TextMessage::tree_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.TextMessage.tree_id)
  return _internal_tree_id();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL TextMessage::mutable_tree_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.TextMessage.tree_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tree_id();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
TextMessage::_internal_tree_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tree_id_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
TextMessage::_internal_mutable_tree_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tree_id_;
}

// required string message = 5;
inline bool TextMessage::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TextMessage::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TextMessage::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.TextMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TextMessage::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.TextMessage.message)
}
inline ::std::string* PROTOBUF_NONNULL TextMessage::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:NoxProto.TextMessage.message)
  return _s;
}
inline const ::std::string& TextMessage::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void TextMessage::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TextMessage::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TextMessage::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.TextMessage.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void TextMessage::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.TextMessage.message)
}

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
inline bool PermissionDenied::has_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PermissionDenied::clear_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permission_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t PermissionDenied::permission() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.permission)
  return _internal_permission();
}
inline void PermissionDenied::set_permission(::uint32_t value) {
  _internal_set_permission(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.permission)
}
inline ::uint32_t PermissionDenied::_internal_permission() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permission_;
}
inline void PermissionDenied::_internal_set_permission(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permission_ = value;
}

// optional uint32 channel_id = 2;
inline bool PermissionDenied::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PermissionDenied::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t PermissionDenied::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.channel_id)
  return _internal_channel_id();
}
inline void PermissionDenied::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.channel_id)
}
inline ::uint32_t PermissionDenied::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void PermissionDenied::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional uint32 session = 3;
inline bool PermissionDenied::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PermissionDenied::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t PermissionDenied::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.session)
  return _internal_session();
}
inline void PermissionDenied::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.session)
}
inline ::uint32_t PermissionDenied::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void PermissionDenied::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional string reason = 4;
inline bool PermissionDenied::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PermissionDenied::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PermissionDenied::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PermissionDenied::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.reason)
}
inline ::std::string* PROTOBUF_NONNULL PermissionDenied::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:NoxProto.PermissionDenied.reason)
  return _s;
}
inline const ::std::string& PermissionDenied::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void PermissionDenied::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PermissionDenied::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PermissionDenied::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.PermissionDenied.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void PermissionDenied::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.PermissionDenied.reason)
}

// optional .NoxProto.PermissionDenied.DenyType type = 5;
inline bool PermissionDenied::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PermissionDenied::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::NoxProto::PermissionDenied_DenyType PermissionDenied::type() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.type)
  return _internal_type();
}
inline void PermissionDenied::set_type(::NoxProto::PermissionDenied_DenyType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.type)
}
inline ::NoxProto::PermissionDenied_DenyType PermissionDenied::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::NoxProto::PermissionDenied_DenyType>(_impl_.type_);
}
inline void PermissionDenied::_internal_set_type(::NoxProto::PermissionDenied_DenyType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::NoxProto::PermissionDenied_DenyType_internal_data_));
                                          _impl_.type_ = value;
}

// optional string name = 6;
inline bool PermissionDenied::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PermissionDenied::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& PermissionDenied::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionDenied.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PermissionDenied::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.PermissionDenied.name)
}
inline ::std::string* PROTOBUF_NONNULL PermissionDenied::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.PermissionDenied.name)
  return _s;
}
inline const ::std::string& PermissionDenied::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PermissionDenied::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PermissionDenied::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PermissionDenied::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.PermissionDenied.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void PermissionDenied::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.PermissionDenied.name)
}

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
inline bool ACL_ChanGroup::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACL_ChanGroup::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ACL_ChanGroup::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ACL_ChanGroup::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.name)
}
inline ::std::string* PROTOBUF_NONNULL ACL_ChanGroup::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.ACL.ChanGroup.name)
  return _s;
}
inline const ::std::string& ACL_ChanGroup::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ACL_ChanGroup::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ACL_ChanGroup::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ACL_ChanGroup::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ACL.ChanGroup.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ACL_ChanGroup::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ACL.ChanGroup.name)
}

// optional bool inherited = 2 [default = true];
inline bool ACL_ChanGroup::has_inherited() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACL_ChanGroup::clear_inherited() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherited_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ACL_ChanGroup::inherited() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.inherited)
  return _internal_inherited();
}
inline void ACL_ChanGroup::set_inherited(bool value) {
  _internal_set_inherited(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.inherited)
}
inline bool ACL_ChanGroup::_internal_inherited() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inherited_;
}
inline void ACL_ChanGroup::_internal_set_inherited(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherited_ = value;
}

// optional bool inherit = 3 [default = true];
inline bool ACL_ChanGroup::has_inherit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ACL_ChanGroup::clear_inherit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherit_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ACL_ChanGroup::inherit() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.inherit)
  return _internal_inherit();
}
inline void ACL_ChanGroup::set_inherit(bool value) {
  _internal_set_inherit(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.inherit)
}
inline bool ACL_ChanGroup::_internal_inherit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inherit_;
}
inline void ACL_ChanGroup::_internal_set_inherit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherit_ = value;
}

// optional bool inheritable = 4 [default = true];
inline bool ACL_ChanGroup::has_inheritable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ACL_ChanGroup::clear_inheritable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inheritable_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ACL_ChanGroup::inheritable() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.inheritable)
  return _internal_inheritable();
}
inline void ACL_ChanGroup::set_inheritable(bool value) {
  _internal_set_inheritable(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.inheritable)
}
inline bool ACL_ChanGroup::_internal_inheritable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inheritable_;
}
inline void ACL_ChanGroup::_internal_set_inheritable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inheritable_ = value;
}

// repeated uint32 add = 5;
inline int ACL_ChanGroup::_internal_add_size() const {
  return _internal_add().size();
}
inline int ACL_ChanGroup::add_size() const {
  return _internal_add_size();
}
inline void ACL_ChanGroup::clear_add() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.add_.Clear();
}
inline ::uint32_t ACL_ChanGroup::add(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.add)
  return _internal_add().Get(index);
}
inline void ACL_ChanGroup::set_add(int index, ::uint32_t value) {
  _internal_mutable_add()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.add)
}
inline void ACL_ChanGroup::add_add(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_add()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ACL.ChanGroup.add)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ACL_ChanGroup::add() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ACL.ChanGroup.add)
  return _internal_add();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ACL_ChanGroup::mutable_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ACL.ChanGroup.add)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_add();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ACL_ChanGroup::_internal_add() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.add_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ACL_ChanGroup::_internal_mutable_add() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.add_;
}

// repeated uint32 remove = 6;
inline int ACL_ChanGroup::_internal_remove_size() const {
  return _internal_remove().size();
}
inline int ACL_ChanGroup::remove_size() const {
  return _internal_remove_size();
}
inline void ACL_ChanGroup::clear_remove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remove_.Clear();
}
inline ::uint32_t ACL_ChanGroup::remove(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.remove)
  return _internal_remove().Get(index);
}
inline void ACL_ChanGroup::set_remove(int index, ::uint32_t value) {
  _internal_mutable_remove()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.remove)
}
inline void ACL_ChanGroup::add_remove(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_remove()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ACL.ChanGroup.remove)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ACL_ChanGroup::remove() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ACL.ChanGroup.remove)
  return _internal_remove();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ACL_ChanGroup::mutable_remove()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ACL.ChanGroup.remove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_remove();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ACL_ChanGroup::_internal_remove() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remove_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ACL_ChanGroup::_internal_mutable_remove() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.remove_;
}

// repeated uint32 inherited_members = 7;
inline int ACL_ChanGroup::_internal_inherited_members_size() const {
  return _internal_inherited_members().size();
}
inline int ACL_ChanGroup::inherited_members_size() const {
  return _internal_inherited_members_size();
}
inline void ACL_ChanGroup::clear_inherited_members() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherited_members_.Clear();
}
inline ::uint32_t ACL_ChanGroup::inherited_members(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanGroup.inherited_members)
  return _internal_inherited_members().Get(index);
}
inline void ACL_ChanGroup::set_inherited_members(int index, ::uint32_t value) {
  _internal_mutable_inherited_members()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanGroup.inherited_members)
}
inline void ACL_ChanGroup::add_inherited_members(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_inherited_members()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.ACL.ChanGroup.inherited_members)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ACL_ChanGroup::inherited_members() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ACL.ChanGroup.inherited_members)
  return _internal_inherited_members();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ACL_ChanGroup::mutable_inherited_members()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ACL.ChanGroup.inherited_members)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inherited_members();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ACL_ChanGroup::_internal_inherited_members() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inherited_members_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ACL_ChanGroup::_internal_mutable_inherited_members() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inherited_members_;
}

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
inline bool ACL_ChanACL::has_apply_here() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_apply_here() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_here_ = true;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ACL_ChanACL::apply_here() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.apply_here)
  return _internal_apply_here();
}
inline void ACL_ChanACL::set_apply_here(bool value) {
  _internal_set_apply_here(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.apply_here)
}
inline bool ACL_ChanACL::_internal_apply_here() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apply_here_;
}
inline void ACL_ChanACL::_internal_set_apply_here(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_here_ = value;
}

// optional bool apply_subs = 2 [default = true];
inline bool ACL_ChanACL::has_apply_subs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_apply_subs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_subs_ = true;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ACL_ChanACL::apply_subs() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.apply_subs)
  return _internal_apply_subs();
}
inline void ACL_ChanACL::set_apply_subs(bool value) {
  _internal_set_apply_subs(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.apply_subs)
}
inline bool ACL_ChanACL::_internal_apply_subs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apply_subs_;
}
inline void ACL_ChanACL::_internal_set_apply_subs(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_subs_ = value;
}

// optional bool inherited = 3 [default = true];
inline bool ACL_ChanACL::has_inherited() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_inherited() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherited_ = true;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ACL_ChanACL::inherited() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.inherited)
  return _internal_inherited();
}
inline void ACL_ChanACL::set_inherited(bool value) {
  _internal_set_inherited(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.inherited)
}
inline bool ACL_ChanACL::_internal_inherited() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inherited_;
}
inline void ACL_ChanACL::_internal_set_inherited(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherited_ = value;
}

// optional uint32 user_id = 4;
inline bool ACL_ChanACL::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ACL_ChanACL::user_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.user_id)
  return _internal_user_id();
}
inline void ACL_ChanACL::set_user_id(::uint32_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.user_id)
}
inline ::uint32_t ACL_ChanACL::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void ACL_ChanACL::_internal_set_user_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// optional string group = 5;
inline bool ACL_ChanACL::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ACL_ChanACL::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ACL_ChanACL::set_group(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.group)
}
inline ::std::string* PROTOBUF_NONNULL ACL_ChanACL::mutable_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:NoxProto.ACL.ChanACL.group)
  return _s;
}
inline const ::std::string& ACL_ChanACL::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_.Get();
}
inline void ACL_ChanACL::_internal_set_group(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ACL_ChanACL::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ACL_ChanACL::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ACL.ChanACL.group)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.group_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_.Set("", GetArena());
  }
  return released;
}
inline void ACL_ChanACL::set_allocated_group(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ACL.ChanACL.group)
}

// optional uint32 grant = 6;
inline bool ACL_ChanACL::has_grant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_grant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grant_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ACL_ChanACL::grant() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.grant)
  return _internal_grant();
}
inline void ACL_ChanACL::set_grant(::uint32_t value) {
  _internal_set_grant(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.grant)
}
inline ::uint32_t ACL_ChanACL::_internal_grant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grant_;
}
inline void ACL_ChanACL::_internal_set_grant(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grant_ = value;
}

// optional uint32 deny = 7;
inline bool ACL_ChanACL::has_deny() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ACL_ChanACL::clear_deny() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deny_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ACL_ChanACL::deny() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.ChanACL.deny)
  return _internal_deny();
}
inline void ACL_ChanACL::set_deny(::uint32_t value) {
  _internal_set_deny(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.ChanACL.deny)
}
inline ::uint32_t ACL_ChanACL::_internal_deny() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deny_;
}
inline void ACL_ChanACL::_internal_set_deny(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deny_ = value;
}

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
inline bool ACL::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACL::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ACL::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.channel_id)
  return _internal_channel_id();
}
inline void ACL::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.channel_id)
}
inline ::uint32_t ACL::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void ACL::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional bool inherit_acls = 2 [default = true];
inline bool ACL::has_inherit_acls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ACL::clear_inherit_acls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherit_acls_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ACL::inherit_acls() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.inherit_acls)
  return _internal_inherit_acls();
}
inline void ACL::set_inherit_acls(bool value) {
  _internal_set_inherit_acls(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.inherit_acls)
}
inline bool ACL::_internal_inherit_acls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inherit_acls_;
}
inline void ACL::_internal_set_inherit_acls(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inherit_acls_ = value;
}

// repeated .NoxProto.ACL.ChanGroup groups = 3;
inline int ACL::_internal_groups_size() const {
  return _internal_groups().size();
}
inline int ACL::groups_size() const {
  return _internal_groups_size();
}
inline void ACL::clear_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.groups_.Clear();
}
inline ::NoxProto::ACL_ChanGroup* PROTOBUF_NONNULL ACL::mutable_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.ACL.groups)
  return _internal_mutable_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>* PROTOBUF_NONNULL ACL::mutable_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ACL.groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_groups();
}
inline const ::NoxProto::ACL_ChanGroup& ACL::groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.groups)
  return _internal_groups().Get(index);
}
inline ::NoxProto::ACL_ChanGroup* PROTOBUF_NONNULL ACL::add_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::ACL_ChanGroup* _add = _internal_mutable_groups()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.ACL.groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>& ACL::groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ACL.groups)
  return _internal_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>&
ACL::_internal_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.groups_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanGroup>* PROTOBUF_NONNULL
ACL::_internal_mutable_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.groups_;
}

// repeated .NoxProto.ACL.ChanACL acls = 4;
inline int ACL::_internal_acls_size() const {
  return _internal_acls().size();
}
inline int ACL::acls_size() const {
  return _internal_acls_size();
}
inline void ACL::clear_acls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acls_.Clear();
}
inline ::NoxProto::ACL_ChanACL* PROTOBUF_NONNULL ACL::mutable_acls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.ACL.acls)
  return _internal_mutable_acls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>* PROTOBUF_NONNULL ACL::mutable_acls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.ACL.acls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_acls();
}
inline const ::NoxProto::ACL_ChanACL& ACL::acls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.acls)
  return _internal_acls().Get(index);
}
inline ::NoxProto::ACL_ChanACL* PROTOBUF_NONNULL ACL::add_acls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::ACL_ChanACL* _add = _internal_mutable_acls()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.ACL.acls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>& ACL::acls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.ACL.acls)
  return _internal_acls();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>&
ACL::_internal_acls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.acls_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::ACL_ChanACL>* PROTOBUF_NONNULL
ACL::_internal_mutable_acls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.acls_;
}

// optional bool query = 5 [default = false];
inline bool ACL::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACL::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ACL::query() const {
  // @@protoc_insertion_point(field_get:NoxProto.ACL.query)
  return _internal_query();
}
inline void ACL::set_query(bool value) {
  _internal_set_query(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ACL.query)
}
inline bool ACL::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_;
}
inline void ACL::_internal_set_query(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_ = value;
}

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
inline int QueryUsers::_internal_ids_size() const {
  return _internal_ids().size();
}
inline int QueryUsers::ids_size() const {
  return _internal_ids_size();
}
inline void QueryUsers::clear_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ids_.Clear();
}
inline ::uint32_t QueryUsers::ids(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.QueryUsers.ids)
  return _internal_ids().Get(index);
}
inline void QueryUsers::set_ids(int index, ::uint32_t value) {
  _internal_mutable_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.QueryUsers.ids)
}
inline void QueryUsers::add_ids(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ids()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.QueryUsers.ids)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& QueryUsers::ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.QueryUsers.ids)
  return _internal_ids();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL QueryUsers::mutable_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.QueryUsers.ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ids();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
QueryUsers::_internal_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ids_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
QueryUsers::_internal_mutable_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ids_;
}

// repeated string names = 2;
inline int QueryUsers::_internal_names_size() const {
  return _internal_names().size();
}
inline int QueryUsers::names_size() const {
  return _internal_names_size();
}
inline void QueryUsers::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL QueryUsers::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:NoxProto.QueryUsers.names)
  return _s;
}
inline const ::std::string& QueryUsers::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.QueryUsers.names)
  return _internal_names().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL QueryUsers::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.QueryUsers.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void QueryUsers::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_names()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:NoxProto.QueryUsers.names)
}
template <typename Arg_, typename... Args_>
inline void QueryUsers::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_names(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:NoxProto.QueryUsers.names)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& QueryUsers::names()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.QueryUsers.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
QueryUsers::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.QueryUsers.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
QueryUsers::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
QueryUsers::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
inline bool CryptSetup::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CryptSetup::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CryptSetup::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.CryptSetup.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CryptSetup::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.CryptSetup.key)
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:NoxProto.CryptSetup.key)
  return _s;
}
inline const ::std::string& CryptSetup::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void CryptSetup::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CryptSetup::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.CryptSetup.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void CryptSetup::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.CryptSetup.key)
}

// optional bytes client_nonce = 2;
inline bool CryptSetup::has_client_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CryptSetup::clear_client_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CryptSetup::client_nonce() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.CryptSetup.client_nonce)
  return _internal_client_nonce();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CryptSetup::set_client_nonce(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_nonce_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.CryptSetup.client_nonce)
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::mutable_client_nonce()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_client_nonce();
  // @@protoc_insertion_point(field_mutable:NoxProto.CryptSetup.client_nonce)
  return _s;
}
inline const ::std::string& CryptSetup::_internal_client_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_nonce_.Get();
}
inline void CryptSetup::_internal_set_client_nonce(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_nonce_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::_internal_mutable_client_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.client_nonce_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CryptSetup::release_client_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.CryptSetup.client_nonce)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.client_nonce_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.client_nonce_.Set("", GetArena());
  }
  return released;
}
inline void CryptSetup::set_allocated_client_nonce(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.client_nonce_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_nonce_.IsDefault()) {
    _impl_.client_nonce_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.CryptSetup.client_nonce)
}

// optional bytes server_nonce = 3;
inline bool CryptSetup::has_server_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CryptSetup::clear_server_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CryptSetup::server_nonce() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.CryptSetup.server_nonce)
  return _internal_server_nonce();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CryptSetup::set_server_nonce(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_nonce_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.CryptSetup.server_nonce)
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::mutable_server_nonce()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_server_nonce();
  // @@protoc_insertion_point(field_mutable:NoxProto.CryptSetup.server_nonce)
  return _s;
}
inline const ::std::string& CryptSetup::_internal_server_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_nonce_.Get();
}
inline void CryptSetup::_internal_set_server_nonce(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_nonce_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CryptSetup::_internal_mutable_server_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.server_nonce_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CryptSetup::release_server_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.CryptSetup.server_nonce)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.server_nonce_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.server_nonce_.Set("", GetArena());
  }
  return released;
}
inline void CryptSetup::set_allocated_server_nonce(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.server_nonce_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_nonce_.IsDefault()) {
    _impl_.server_nonce_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.CryptSetup.server_nonce)
}

// -------------------------------------------------------------------

// ContextActionModify

// required string action = 1;
inline bool ContextActionModify::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ContextActionModify::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ContextActionModify::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ContextActionModify.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ContextActionModify::set_action(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ContextActionModify.action)
}
inline ::std::string* PROTOBUF_NONNULL ContextActionModify::mutable_action()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:NoxProto.ContextActionModify.action)
  return _s;
}
inline const ::std::string& ContextActionModify::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void ContextActionModify::_internal_set_action(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ContextActionModify::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.action_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ContextActionModify::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ContextActionModify.action)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.action_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.action_.Set("", GetArena());
  }
  return released;
}
inline void ContextActionModify::set_allocated_action(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ContextActionModify.action)
}

// optional string text = 2;
inline bool ContextActionModify::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ContextActionModify::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ContextActionModify::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ContextActionModify.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ContextActionModify::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ContextActionModify.text)
}
inline ::std::string* PROTOBUF_NONNULL ContextActionModify::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:NoxProto.ContextActionModify.text)
  return _s;
}
inline const ::std::string& ContextActionModify::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void ContextActionModify::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ContextActionModify::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ContextActionModify::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ContextActionModify.text)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void ContextActionModify::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ContextActionModify.text)
}

// optional uint32 context = 3;
inline bool ContextActionModify::has_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ContextActionModify::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.context_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ContextActionModify::context() const {
  // @@protoc_insertion_point(field_get:NoxProto.ContextActionModify.context)
  return _internal_context();
}
inline void ContextActionModify::set_context(::uint32_t value) {
  _internal_set_context(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ContextActionModify.context)
}
inline ::uint32_t ContextActionModify::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.context_;
}
inline void ContextActionModify::_internal_set_context(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.context_ = value;
}

// optional .NoxProto.ContextActionModify.Operation operation = 4;
inline bool ContextActionModify::has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ContextActionModify::clear_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::NoxProto::ContextActionModify_Operation ContextActionModify::operation() const {
  // @@protoc_insertion_point(field_get:NoxProto.ContextActionModify.operation)
  return _internal_operation();
}
inline void ContextActionModify::set_operation(::NoxProto::ContextActionModify_Operation value) {
  _internal_set_operation(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ContextActionModify.operation)
}
inline ::NoxProto::ContextActionModify_Operation ContextActionModify::_internal_operation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::NoxProto::ContextActionModify_Operation>(_impl_.operation_);
}
inline void ContextActionModify::_internal_set_operation(::NoxProto::ContextActionModify_Operation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::NoxProto::ContextActionModify_Operation_internal_data_));
                                          _impl_.operation_ = value;
}

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
inline bool ContextAction::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ContextAction::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ContextAction::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.ContextAction.session)
  return _internal_session();
}
inline void ContextAction::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ContextAction.session)
}
inline ::uint32_t ContextAction::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void ContextAction::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional uint32 channel_id = 2;
inline bool ContextAction::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ContextAction::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ContextAction::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.ContextAction.channel_id)
  return _internal_channel_id();
}
inline void ContextAction::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ContextAction.channel_id)
}
inline ::uint32_t ContextAction::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void ContextAction::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// required string action = 3;
inline bool ContextAction::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ContextAction::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ContextAction::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ContextAction.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ContextAction::set_action(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ContextAction.action)
}
inline ::std::string* PROTOBUF_NONNULL ContextAction::mutable_action()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:NoxProto.ContextAction.action)
  return _s;
}
inline const ::std::string& ContextAction::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void ContextAction::_internal_set_action(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ContextAction::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.action_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ContextAction::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ContextAction.action)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.action_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.action_.Set("", GetArena());
  }
  return released;
}
inline void ContextAction::set_allocated_action(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ContextAction.action)
}

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
inline bool UserList_User::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserList_User::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserList_User::user_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserList.User.user_id)
  return _internal_user_id();
}
inline void UserList_User::set_user_id(::uint32_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.UserList.User.user_id)
}
inline ::uint32_t UserList_User::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void UserList_User::_internal_set_user_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// optional string name = 2;
inline bool UserList_User::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserList_User::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserList_User::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserList.User.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserList_User::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserList.User.name)
}
inline ::std::string* PROTOBUF_NONNULL UserList_User::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserList.User.name)
  return _s;
}
inline const ::std::string& UserList_User::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void UserList_User::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserList_User::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserList_User::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserList.User.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void UserList_User::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserList.User.name)
}

// optional string last_seen = 3;
inline bool UserList_User::has_last_seen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserList_User::clear_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_seen_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& UserList_User::last_seen() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserList.User.last_seen)
  return _internal_last_seen();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserList_User::set_last_seen(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_seen_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserList.User.last_seen)
}
inline ::std::string* PROTOBUF_NONNULL UserList_User::mutable_last_seen()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_last_seen();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserList.User.last_seen)
  return _s;
}
inline const ::std::string& UserList_User::_internal_last_seen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_seen_.Get();
}
inline void UserList_User::_internal_set_last_seen(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_seen_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserList_User::_internal_mutable_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.last_seen_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserList_User::release_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserList.User.last_seen)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.last_seen_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.last_seen_.Set("", GetArena());
  }
  return released;
}
inline void UserList_User::set_allocated_last_seen(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.last_seen_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_seen_.IsDefault()) {
    _impl_.last_seen_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserList.User.last_seen)
}

// optional uint32 last_channel = 4;
inline bool UserList_User::has_last_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserList_User::clear_last_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_channel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t UserList_User::last_channel() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserList.User.last_channel)
  return _internal_last_channel();
}
inline void UserList_User::set_last_channel(::uint32_t value) {
  _internal_set_last_channel(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.UserList.User.last_channel)
}
inline ::uint32_t UserList_User::_internal_last_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_channel_;
}
inline void UserList_User::_internal_set_last_channel(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_channel_ = value;
}

// -------------------------------------------------------------------

// UserList

// repeated .NoxProto.UserList.User users = 1;
inline int UserList::_internal_users_size() const {
  return _internal_users().size();
}
inline int UserList::users_size() const {
  return _internal_users_size();
}
inline void UserList::clear_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.users_.Clear();
}
inline ::NoxProto::UserList_User* PROTOBUF_NONNULL UserList::mutable_users(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.UserList.users)
  return _internal_mutable_users()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>* PROTOBUF_NONNULL UserList::mutable_users()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserList.users)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_users();
}
inline const ::NoxProto::UserList_User& UserList::users(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserList.users)
  return _internal_users().Get(index);
}
inline ::NoxProto::UserList_User* PROTOBUF_NONNULL UserList::add_users()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::UserList_User* _add = _internal_mutable_users()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.UserList.users)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>& UserList::users() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserList.users)
  return _internal_users();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>&
UserList::_internal_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.users_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::UserList_User>* PROTOBUF_NONNULL
UserList::_internal_mutable_users() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.users_;
}

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
inline int VoiceTarget_Target::_internal_session_size() const {
  return _internal_session().size();
}
inline int VoiceTarget_Target::session_size() const {
  return _internal_session_size();
}
inline void VoiceTarget_Target::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_.Clear();
}
inline ::uint32_t VoiceTarget_Target::session(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.Target.session)
  return _internal_session().Get(index);
}
inline void VoiceTarget_Target::set_session(int index, ::uint32_t value) {
  _internal_mutable_session()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.Target.session)
}
inline void VoiceTarget_Target::add_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_session()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.VoiceTarget.Target.session)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& VoiceTarget_Target::session() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.VoiceTarget.Target.session)
  return _internal_session();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL VoiceTarget_Target::mutable_session()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.VoiceTarget.Target.session)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_session();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
VoiceTarget_Target::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
VoiceTarget_Target::_internal_mutable_session() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.session_;
}

// optional uint32 channel_id = 2;
inline bool VoiceTarget_Target::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VoiceTarget_Target::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t VoiceTarget_Target::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.Target.channel_id)
  return _internal_channel_id();
}
inline void VoiceTarget_Target::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.Target.channel_id)
}
inline ::uint32_t VoiceTarget_Target::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void VoiceTarget_Target::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional string group = 3;
inline bool VoiceTarget_Target::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VoiceTarget_Target::clear_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& VoiceTarget_Target::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.Target.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void VoiceTarget_Target::set_group(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.Target.group)
}
inline ::std::string* PROTOBUF_NONNULL VoiceTarget_Target::mutable_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:NoxProto.VoiceTarget.Target.group)
  return _s;
}
inline const ::std::string& VoiceTarget_Target::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_.Get();
}
inline void VoiceTarget_Target::_internal_set_group(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL VoiceTarget_Target::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE VoiceTarget_Target::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.VoiceTarget.Target.group)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.group_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_.Set("", GetArena());
  }
  return released;
}
inline void VoiceTarget_Target::set_allocated_group(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.VoiceTarget.Target.group)
}

// optional bool links = 4 [default = false];
inline bool VoiceTarget_Target::has_links() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VoiceTarget_Target::clear_links() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.links_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool VoiceTarget_Target::links() const {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.Target.links)
  return _internal_links();
}
inline void VoiceTarget_Target::set_links(bool value) {
  _internal_set_links(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.Target.links)
}
inline bool VoiceTarget_Target::_internal_links() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.links_;
}
inline void VoiceTarget_Target::_internal_set_links(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.links_ = value;
}

// optional bool children = 5 [default = false];
inline bool VoiceTarget_Target::has_children() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VoiceTarget_Target::clear_children() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.children_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool VoiceTarget_Target::children() const {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.Target.children)
  return _internal_children();
}
inline void VoiceTarget_Target::set_children(bool value) {
  _internal_set_children(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.Target.children)
}
inline bool VoiceTarget_Target::_internal_children() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.children_;
}
inline void VoiceTarget_Target::_internal_set_children(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.children_ = value;
}

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
inline bool VoiceTarget::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VoiceTarget::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t VoiceTarget::id() const {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.id)
  return _internal_id();
}
inline void VoiceTarget::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.VoiceTarget.id)
}
inline ::uint32_t VoiceTarget::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void VoiceTarget::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// repeated .NoxProto.VoiceTarget.Target targets = 2;
inline int VoiceTarget::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int VoiceTarget::targets_size() const {
  return _internal_targets_size();
}
inline void VoiceTarget::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline ::NoxProto::VoiceTarget_Target* PROTOBUF_NONNULL VoiceTarget::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.VoiceTarget.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>* PROTOBUF_NONNULL VoiceTarget::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.VoiceTarget.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::NoxProto::VoiceTarget_Target& VoiceTarget::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.VoiceTarget.targets)
  return _internal_targets().Get(index);
}
inline ::NoxProto::VoiceTarget_Target* PROTOBUF_NONNULL VoiceTarget::add_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::NoxProto::VoiceTarget_Target* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:NoxProto.VoiceTarget.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>& VoiceTarget::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.VoiceTarget.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>&
VoiceTarget::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::NoxProto::VoiceTarget_Target>* PROTOBUF_NONNULL
VoiceTarget::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
inline bool PermissionQuery::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PermissionQuery::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PermissionQuery::channel_id() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionQuery.channel_id)
  return _internal_channel_id();
}
inline void PermissionQuery::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionQuery.channel_id)
}
inline ::uint32_t PermissionQuery::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_;
}
inline void PermissionQuery::_internal_set_channel_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_ = value;
}

// optional uint32 permissions = 2;
inline bool PermissionQuery::has_permissions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PermissionQuery::clear_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t PermissionQuery::permissions() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionQuery.permissions)
  return _internal_permissions();
}
inline void PermissionQuery::set_permissions(::uint32_t value) {
  _internal_set_permissions(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionQuery.permissions)
}
inline ::uint32_t PermissionQuery::_internal_permissions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permissions_;
}
inline void PermissionQuery::_internal_set_permissions(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_ = value;
}

// optional bool flush = 3 [default = false];
inline bool PermissionQuery::has_flush() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PermissionQuery::clear_flush() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flush_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PermissionQuery::flush() const {
  // @@protoc_insertion_point(field_get:NoxProto.PermissionQuery.flush)
  return _internal_flush();
}
inline void PermissionQuery::set_flush(bool value) {
  _internal_set_flush(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.PermissionQuery.flush)
}
inline bool PermissionQuery::_internal_flush() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flush_;
}
inline void PermissionQuery::_internal_set_flush(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flush_ = value;
}

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
inline bool CodecVersion::has_alpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CodecVersion::clear_alpha() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alpha_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t CodecVersion::alpha() const {
  // @@protoc_insertion_point(field_get:NoxProto.CodecVersion.alpha)
  return _internal_alpha();
}
inline void CodecVersion::set_alpha(::int32_t value) {
  _internal_set_alpha(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.CodecVersion.alpha)
}
inline ::int32_t CodecVersion::_internal_alpha() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alpha_;
}
inline void CodecVersion::_internal_set_alpha(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alpha_ = value;
}

// required int32 beta = 2;
inline bool CodecVersion::has_beta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CodecVersion::clear_beta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CodecVersion::beta() const {
  // @@protoc_insertion_point(field_get:NoxProto.CodecVersion.beta)
  return _internal_beta();
}
inline void CodecVersion::set_beta(::int32_t value) {
  _internal_set_beta(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.CodecVersion.beta)
}
inline ::int32_t CodecVersion::_internal_beta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beta_;
}
inline void CodecVersion::_internal_set_beta(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beta_ = value;
}

// required bool prefer_alpha = 3 [default = true];
inline bool CodecVersion::has_prefer_alpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CodecVersion::clear_prefer_alpha() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefer_alpha_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CodecVersion::prefer_alpha() const {
  // @@protoc_insertion_point(field_get:NoxProto.CodecVersion.prefer_alpha)
  return _internal_prefer_alpha();
}
inline void CodecVersion::set_prefer_alpha(bool value) {
  _internal_set_prefer_alpha(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.CodecVersion.prefer_alpha)
}
inline bool CodecVersion::_internal_prefer_alpha() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefer_alpha_;
}
inline void CodecVersion::_internal_set_prefer_alpha(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefer_alpha_ = value;
}

// optional bool opus = 4 [default = false];
inline bool CodecVersion::has_opus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CodecVersion::clear_opus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CodecVersion::opus() const {
  // @@protoc_insertion_point(field_get:NoxProto.CodecVersion.opus)
  return _internal_opus();
}
inline void CodecVersion::set_opus(bool value) {
  _internal_set_opus(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.CodecVersion.opus)
}
inline bool CodecVersion::_internal_opus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opus_;
}
inline void CodecVersion::_internal_set_opus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = value;
}

// -------------------------------------------------------------------

// UserStats_Stats

// optional uint32 good = 1;
inline bool UserStats_Stats::has_good() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserStats_Stats::clear_good() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.good_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UserStats_Stats::good() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.Stats.good)
  return _internal_good();
}
inline void UserStats_Stats::set_good(::uint32_t value) {
  _internal_set_good(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.Stats.good)
}
inline ::uint32_t UserStats_Stats::_internal_good() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.good_;
}
inline void UserStats_Stats::_internal_set_good(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.good_ = value;
}

// optional uint32 late = 2;
inline bool UserStats_Stats::has_late() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserStats_Stats::clear_late() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.late_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserStats_Stats::late() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.Stats.late)
  return _internal_late();
}
inline void UserStats_Stats::set_late(::uint32_t value) {
  _internal_set_late(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.Stats.late)
}
inline ::uint32_t UserStats_Stats::_internal_late() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.late_;
}
inline void UserStats_Stats::_internal_set_late(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.late_ = value;
}

// optional uint32 lost = 3;
inline bool UserStats_Stats::has_lost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserStats_Stats::clear_lost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lost_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserStats_Stats::lost() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.Stats.lost)
  return _internal_lost();
}
inline void UserStats_Stats::set_lost(::uint32_t value) {
  _internal_set_lost(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.Stats.lost)
}
inline ::uint32_t UserStats_Stats::_internal_lost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lost_;
}
inline void UserStats_Stats::_internal_set_lost(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lost_ = value;
}

// optional uint32 resync = 4;
inline bool UserStats_Stats::has_resync() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserStats_Stats::clear_resync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resync_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t UserStats_Stats::resync() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.Stats.resync)
  return _internal_resync();
}
inline void UserStats_Stats::set_resync(::uint32_t value) {
  _internal_set_resync(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.Stats.resync)
}
inline ::uint32_t UserStats_Stats::_internal_resync() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resync_;
}
inline void UserStats_Stats::_internal_set_resync(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resync_ = value;
}

// -------------------------------------------------------------------

// UserStats_RollingStats

// optional uint32 time_window = 1;
inline bool UserStats_RollingStats::has_time_window() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserStats_RollingStats::clear_time_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_window_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserStats_RollingStats::time_window() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.RollingStats.time_window)
  return _internal_time_window();
}
inline void UserStats_RollingStats::set_time_window(::uint32_t value) {
  _internal_set_time_window(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.RollingStats.time_window)
}
inline ::uint32_t UserStats_RollingStats::_internal_time_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_window_;
}
inline void UserStats_RollingStats::_internal_set_time_window(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_window_ = value;
}

// optional .NoxProto.UserStats.Stats from_client = 2;
inline bool UserStats_RollingStats::has_from_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_client_ != nullptr);
  return value;
}
inline void UserStats_RollingStats::clear_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_client_ != nullptr) _impl_.from_client_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NoxProto::UserStats_Stats& UserStats_RollingStats::_internal_from_client() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::UserStats_Stats* p = _impl_.from_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::UserStats_Stats&>(::NoxProto::_UserStats_Stats_default_instance_);
}
inline const ::NoxProto::UserStats_Stats& UserStats_RollingStats::from_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.RollingStats.from_client)
  return _internal_from_client();
}
inline void UserStats_RollingStats::unsafe_arena_set_allocated_from_client(
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_client_);
  }
  _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.RollingStats.from_client)
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats_RollingStats::release_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NoxProto::UserStats_Stats* released = _impl_.from_client_;
  _impl_.from_client_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats_RollingStats::unsafe_arena_release_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.RollingStats.from_client)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NoxProto::UserStats_Stats* temp = _impl_.from_client_;
  _impl_.from_client_ = nullptr;
  return temp;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats_RollingStats::_internal_mutable_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::UserStats_Stats>(GetArena());
    _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(p);
  }
  return _impl_.from_client_;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats_RollingStats::mutable_from_client()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NoxProto::UserStats_Stats* _msg = _internal_mutable_from_client();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.RollingStats.from_client)
  return _msg;
}
inline void UserStats_RollingStats::set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.RollingStats.from_client)
}

// optional .NoxProto.UserStats.Stats from_server = 3;
inline bool UserStats_RollingStats::has_from_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_server_ != nullptr);
  return value;
}
inline void UserStats_RollingStats::clear_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_server_ != nullptr) _impl_.from_server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NoxProto::UserStats_Stats& UserStats_RollingStats::_internal_from_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::UserStats_Stats* p = _impl_.from_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::UserStats_Stats&>(::NoxProto::_UserStats_Stats_default_instance_);
}
inline const ::NoxProto::UserStats_Stats& UserStats_RollingStats::from_server() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.RollingStats.from_server)
  return _internal_from_server();
}
inline void UserStats_RollingStats::unsafe_arena_set_allocated_from_server(
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_server_);
  }
  _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.RollingStats.from_server)
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats_RollingStats::release_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NoxProto::UserStats_Stats* released = _impl_.from_server_;
  _impl_.from_server_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats_RollingStats::unsafe_arena_release_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.RollingStats.from_server)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NoxProto::UserStats_Stats* temp = _impl_.from_server_;
  _impl_.from_server_ = nullptr;
  return temp;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats_RollingStats::_internal_mutable_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_server_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::UserStats_Stats>(GetArena());
    _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(p);
  }
  return _impl_.from_server_;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats_RollingStats::mutable_from_server()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NoxProto::UserStats_Stats* _msg = _internal_mutable_from_server();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.RollingStats.from_server)
  return _msg;
}
inline void UserStats_RollingStats::set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.RollingStats.from_server)
}

// -------------------------------------------------------------------

// UserStats

// optional uint32 session = 1;
inline bool UserStats::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserStats::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t UserStats::session() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.session)
  return _internal_session();
}
inline void UserStats::set_session(::uint32_t value) {
  _internal_set_session(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.session)
}
inline ::uint32_t UserStats::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_;
}
inline void UserStats::_internal_set_session(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_ = value;
}

// optional bool stats_only = 2 [default = false];
inline bool UserStats::has_stats_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void UserStats::clear_stats_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stats_only_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool UserStats::stats_only() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.stats_only)
  return _internal_stats_only();
}
inline void UserStats::set_stats_only(bool value) {
  _internal_set_stats_only(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.stats_only)
}
inline bool UserStats::_internal_stats_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stats_only_;
}
inline void UserStats::_internal_set_stats_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stats_only_ = value;
}

// repeated bytes certificates = 3;
inline int UserStats::_internal_certificates_size() const {
  return _internal_certificates().size();
}
inline int UserStats::certificates_size() const {
  return _internal_certificates_size();
}
inline void UserStats::clear_certificates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.certificates_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL UserStats::add_certificates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_certificates()->Add();
  // @@protoc_insertion_point(field_add_mutable:NoxProto.UserStats.certificates)
  return _s;
}
inline const ::std::string& UserStats::certificates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.certificates)
  return _internal_certificates().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL UserStats::mutable_certificates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.certificates)
  return _internal_mutable_certificates()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UserStats::set_certificates(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_certificates()->Mutable(index), ::std::forward<Arg_>(value),
                        args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.certificates)
}
template <typename Arg_, typename... Args_>
inline void UserStats::add_certificates(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_certificates(),
                               ::std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:NoxProto.UserStats.certificates)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& UserStats::certificates()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserStats.certificates)
  return _internal_certificates();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UserStats::mutable_certificates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserStats.certificates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_certificates();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
UserStats::_internal_certificates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.certificates_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UserStats::_internal_mutable_certificates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.certificates_;
}

// optional .NoxProto.UserStats.Stats from_client = 4;
inline bool UserStats::has_from_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_client_ != nullptr);
  return value;
}
inline void UserStats::clear_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_client_ != nullptr) _impl_.from_client_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NoxProto::UserStats_Stats& UserStats::_internal_from_client() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::UserStats_Stats* p = _impl_.from_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::UserStats_Stats&>(::NoxProto::_UserStats_Stats_default_instance_);
}
inline const ::NoxProto::UserStats_Stats& UserStats::from_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.from_client)
  return _internal_from_client();
}
inline void UserStats::unsafe_arena_set_allocated_from_client(
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_client_);
  }
  _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.from_client)
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats::release_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NoxProto::UserStats_Stats* released = _impl_.from_client_;
  _impl_.from_client_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats::unsafe_arena_release_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.from_client)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NoxProto::UserStats_Stats* temp = _impl_.from_client_;
  _impl_.from_client_ = nullptr;
  return temp;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats::_internal_mutable_from_client() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::UserStats_Stats>(GetArena());
    _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(p);
  }
  return _impl_.from_client_;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats::mutable_from_client()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NoxProto::UserStats_Stats* _msg = _internal_mutable_from_client();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.from_client)
  return _msg;
}
inline void UserStats::set_allocated_from_client(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.from_client_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.from_client)
}

// optional .NoxProto.UserStats.Stats from_server = 5;
inline bool UserStats::has_from_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_server_ != nullptr);
  return value;
}
inline void UserStats::clear_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_server_ != nullptr) _impl_.from_server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NoxProto::UserStats_Stats& UserStats::_internal_from_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::UserStats_Stats* p = _impl_.from_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::UserStats_Stats&>(::NoxProto::_UserStats_Stats_default_instance_);
}
inline const ::NoxProto::UserStats_Stats& UserStats::from_server() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.from_server)
  return _internal_from_server();
}
inline void UserStats::unsafe_arena_set_allocated_from_server(
    ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_server_);
  }
  _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.from_server)
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats::release_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NoxProto::UserStats_Stats* released = _impl_.from_server_;
  _impl_.from_server_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE UserStats::unsafe_arena_release_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.from_server)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NoxProto::UserStats_Stats* temp = _impl_.from_server_;
  _impl_.from_server_ = nullptr;
  return temp;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats::_internal_mutable_from_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.from_server_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::UserStats_Stats>(GetArena());
    _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(p);
  }
  return _impl_.from_server_;
}
inline ::NoxProto::UserStats_Stats* PROTOBUF_NONNULL UserStats::mutable_from_server()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::NoxProto::UserStats_Stats* _msg = _internal_mutable_from_server();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.from_server)
  return _msg;
}
inline void UserStats::set_allocated_from_server(::NoxProto::UserStats_Stats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.from_server_ = reinterpret_cast<::NoxProto::UserStats_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.from_server)
}

// optional uint32 udp_packets = 6;
inline bool UserStats::has_udp_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserStats::clear_udp_packets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t UserStats::udp_packets() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.udp_packets)
  return _internal_udp_packets();
}
inline void UserStats::set_udp_packets(::uint32_t value) {
  _internal_set_udp_packets(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.udp_packets)
}
inline ::uint32_t UserStats::_internal_udp_packets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_packets_;
}
inline void UserStats::_internal_set_udp_packets(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_packets_ = value;
}

// optional uint32 tcp_packets = 7;
inline bool UserStats::has_tcp_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserStats::clear_tcp_packets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t UserStats::tcp_packets() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.tcp_packets)
  return _internal_tcp_packets();
}
inline void UserStats::set_tcp_packets(::uint32_t value) {
  _internal_set_tcp_packets(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.tcp_packets)
}
inline ::uint32_t UserStats::_internal_tcp_packets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_packets_;
}
inline void UserStats::_internal_set_tcp_packets(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_packets_ = value;
}

// optional float udp_ping_avg = 8;
inline bool UserStats::has_udp_ping_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserStats::clear_udp_ping_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_avg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float UserStats::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.udp_ping_avg)
  return _internal_udp_ping_avg();
}
inline void UserStats::set_udp_ping_avg(float value) {
  _internal_set_udp_ping_avg(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.udp_ping_avg)
}
inline float UserStats::_internal_udp_ping_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_ping_avg_;
}
inline void UserStats::_internal_set_udp_ping_avg(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_avg_ = value;
}

// optional float udp_ping_var = 9;
inline bool UserStats::has_udp_ping_var() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserStats::clear_udp_ping_var() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_var_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float UserStats::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.udp_ping_var)
  return _internal_udp_ping_var();
}
inline void UserStats::set_udp_ping_var(float value) {
  _internal_set_udp_ping_var(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.udp_ping_var)
}
inline float UserStats::_internal_udp_ping_var() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.udp_ping_var_;
}
inline void UserStats::_internal_set_udp_ping_var(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.udp_ping_var_ = value;
}

// optional float tcp_ping_avg = 10;
inline bool UserStats::has_tcp_ping_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UserStats::clear_tcp_ping_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_avg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float UserStats::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.tcp_ping_avg)
  return _internal_tcp_ping_avg();
}
inline void UserStats::set_tcp_ping_avg(float value) {
  _internal_set_tcp_ping_avg(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.tcp_ping_avg)
}
inline float UserStats::_internal_tcp_ping_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_ping_avg_;
}
inline void UserStats::_internal_set_tcp_ping_avg(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_avg_ = value;
}

// optional float tcp_ping_var = 11;
inline bool UserStats::has_tcp_ping_var() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void UserStats::clear_tcp_ping_var() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_var_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float UserStats::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.tcp_ping_var)
  return _internal_tcp_ping_var();
}
inline void UserStats::set_tcp_ping_var(float value) {
  _internal_set_tcp_ping_var(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.tcp_ping_var)
}
inline float UserStats::_internal_tcp_ping_var() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tcp_ping_var_;
}
inline void UserStats::_internal_set_tcp_ping_var(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tcp_ping_var_ = value;
}

// optional .NoxProto.Version version = 12;
inline bool UserStats::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline void UserStats::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::NoxProto::Version& UserStats::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::Version&>(::NoxProto::_Version_default_instance_);
}
inline const ::NoxProto::Version& UserStats::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.version)
  return _internal_version();
}
inline void UserStats::unsafe_arena_set_allocated_version(
    ::NoxProto::Version* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::NoxProto::Version*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.version)
}
inline ::NoxProto::Version* PROTOBUF_NULLABLE UserStats::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NoxProto::Version* released = _impl_.version_;
  _impl_.version_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::Version* PROTOBUF_NULLABLE UserStats::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.version)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NoxProto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::NoxProto::Version* PROTOBUF_NONNULL UserStats::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::Version>(GetArena());
    _impl_.version_ = reinterpret_cast<::NoxProto::Version*>(p);
  }
  return _impl_.version_;
}
inline ::NoxProto::Version* PROTOBUF_NONNULL UserStats::mutable_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::NoxProto::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.version)
  return _msg;
}
inline void UserStats::set_allocated_version(::NoxProto::Version* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.version_ = reinterpret_cast<::NoxProto::Version*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.version)
}

// repeated int32 celt_versions = 13;
inline int UserStats::_internal_celt_versions_size() const {
  return _internal_celt_versions().size();
}
inline int UserStats::celt_versions_size() const {
  return _internal_celt_versions_size();
}
inline void UserStats::clear_celt_versions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.celt_versions_.Clear();
}
inline ::int32_t UserStats::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.celt_versions)
  return _internal_celt_versions().Get(index);
}
inline void UserStats::set_celt_versions(int index, ::int32_t value) {
  _internal_mutable_celt_versions()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.celt_versions)
}
inline void UserStats::add_celt_versions(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_celt_versions()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.UserStats.celt_versions)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& UserStats::celt_versions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.UserStats.celt_versions)
  return _internal_celt_versions();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL UserStats::mutable_celt_versions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.UserStats.celt_versions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_celt_versions();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
UserStats::_internal_celt_versions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.celt_versions_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
UserStats::_internal_mutable_celt_versions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.celt_versions_;
}

// optional bytes address = 14;
inline bool UserStats::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserStats::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserStats::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserStats::set_address(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.address)
}
inline ::std::string* PROTOBUF_NONNULL UserStats::mutable_address()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.address)
  return _s;
}
inline const ::std::string& UserStats::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void UserStats::_internal_set_address(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserStats::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserStats::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.address_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.address_.Set("", GetArena());
  }
  return released;
}
inline void UserStats::set_allocated_address(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.address)
}

// optional uint32 bandwidth = 15;
inline bool UserStats::has_bandwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void UserStats::clear_bandwidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bandwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint32_t UserStats::bandwidth() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.bandwidth)
  return _internal_bandwidth();
}
inline void UserStats::set_bandwidth(::uint32_t value) {
  _internal_set_bandwidth(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.bandwidth)
}
inline ::uint32_t UserStats::_internal_bandwidth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bandwidth_;
}
inline void UserStats::_internal_set_bandwidth(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bandwidth_ = value;
}

// optional uint32 onlinesecs = 16;
inline bool UserStats::has_onlinesecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void UserStats::clear_onlinesecs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.onlinesecs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t UserStats::onlinesecs() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.onlinesecs)
  return _internal_onlinesecs();
}
inline void UserStats::set_onlinesecs(::uint32_t value) {
  _internal_set_onlinesecs(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.onlinesecs)
}
inline ::uint32_t UserStats::_internal_onlinesecs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.onlinesecs_;
}
inline void UserStats::_internal_set_onlinesecs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.onlinesecs_ = value;
}

// optional uint32 idlesecs = 17;
inline bool UserStats::has_idlesecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void UserStats::clear_idlesecs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idlesecs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t UserStats::idlesecs() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.idlesecs)
  return _internal_idlesecs();
}
inline void UserStats::set_idlesecs(::uint32_t value) {
  _internal_set_idlesecs(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.idlesecs)
}
inline ::uint32_t UserStats::_internal_idlesecs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idlesecs_;
}
inline void UserStats::_internal_set_idlesecs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idlesecs_ = value;
}

// optional bool strong_certificate = 18 [default = false];
inline bool UserStats::has_strong_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void UserStats::clear_strong_certificate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strong_certificate_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool UserStats::strong_certificate() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.strong_certificate)
  return _internal_strong_certificate();
}
inline void UserStats::set_strong_certificate(bool value) {
  _internal_set_strong_certificate(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.strong_certificate)
}
inline bool UserStats::_internal_strong_certificate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strong_certificate_;
}
inline void UserStats::_internal_set_strong_certificate(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strong_certificate_ = value;
}

// optional bool opus = 19 [default = false];
inline bool UserStats::has_opus() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void UserStats::clear_opus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool UserStats::opus() const {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.opus)
  return _internal_opus();
}
inline void UserStats::set_opus(bool value) {
  _internal_set_opus(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:NoxProto.UserStats.opus)
}
inline bool UserStats::_internal_opus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opus_;
}
inline void UserStats::_internal_set_opus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opus_ = value;
}

// optional .NoxProto.UserStats.RollingStats rolling_stats = 20;
inline bool UserStats::has_rolling_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rolling_stats_ != nullptr);
  return value;
}
inline void UserStats::clear_rolling_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rolling_stats_ != nullptr) _impl_.rolling_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::NoxProto::UserStats_RollingStats& UserStats::_internal_rolling_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoxProto::UserStats_RollingStats* p = _impl_.rolling_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoxProto::UserStats_RollingStats&>(::NoxProto::_UserStats_RollingStats_default_instance_);
}
inline const ::NoxProto::UserStats_RollingStats& UserStats::rolling_stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.UserStats.rolling_stats)
  return _internal_rolling_stats();
}
inline void UserStats::unsafe_arena_set_allocated_rolling_stats(
    ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rolling_stats_);
  }
  _impl_.rolling_stats_ = reinterpret_cast<::NoxProto::UserStats_RollingStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NoxProto.UserStats.rolling_stats)
}
inline ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE UserStats::release_rolling_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::NoxProto::UserStats_RollingStats* released = _impl_.rolling_stats_;
  _impl_.rolling_stats_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE UserStats::unsafe_arena_release_rolling_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.UserStats.rolling_stats)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::NoxProto::UserStats_RollingStats* temp = _impl_.rolling_stats_;
  _impl_.rolling_stats_ = nullptr;
  return temp;
}
inline ::NoxProto::UserStats_RollingStats* PROTOBUF_NONNULL UserStats::_internal_mutable_rolling_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rolling_stats_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoxProto::UserStats_RollingStats>(GetArena());
    _impl_.rolling_stats_ = reinterpret_cast<::NoxProto::UserStats_RollingStats*>(p);
  }
  return _impl_.rolling_stats_;
}
inline ::NoxProto::UserStats_RollingStats* PROTOBUF_NONNULL UserStats::mutable_rolling_stats()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::NoxProto::UserStats_RollingStats* _msg = _internal_mutable_rolling_stats();
  // @@protoc_insertion_point(field_mutable:NoxProto.UserStats.rolling_stats)
  return _msg;
}
inline void UserStats::set_allocated_rolling_stats(::NoxProto::UserStats_RollingStats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rolling_stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.rolling_stats_ = reinterpret_cast<::NoxProto::UserStats_RollingStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:NoxProto.UserStats.rolling_stats)
}

// -------------------------------------------------------------------

// RequestBlob

// repeated uint32 session_texture = 1;
inline int RequestBlob::_internal_session_texture_size() const {
  return _internal_session_texture().size();
}
inline int RequestBlob::session_texture_size() const {
  return _internal_session_texture_size();
}
inline void RequestBlob::clear_session_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_texture_.Clear();
}
inline ::uint32_t RequestBlob::session_texture(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.RequestBlob.session_texture)
  return _internal_session_texture().Get(index);
}
inline void RequestBlob::set_session_texture(int index, ::uint32_t value) {
  _internal_mutable_session_texture()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.RequestBlob.session_texture)
}
inline void RequestBlob::add_session_texture(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_session_texture()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.RequestBlob.session_texture)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RequestBlob::session_texture() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.RequestBlob.session_texture)
  return _internal_session_texture();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL RequestBlob::mutable_session_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.RequestBlob.session_texture)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_session_texture();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RequestBlob::_internal_session_texture() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_texture_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
RequestBlob::_internal_mutable_session_texture() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.session_texture_;
}

// repeated uint32 session_comment = 2;
inline int RequestBlob::_internal_session_comment_size() const {
  return _internal_session_comment().size();
}
inline int RequestBlob::session_comment_size() const {
  return _internal_session_comment_size();
}
inline void RequestBlob::clear_session_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_comment_.Clear();
}
inline ::uint32_t RequestBlob::session_comment(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.RequestBlob.session_comment)
  return _internal_session_comment().Get(index);
}
inline void RequestBlob::set_session_comment(int index, ::uint32_t value) {
  _internal_mutable_session_comment()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.RequestBlob.session_comment)
}
inline void RequestBlob::add_session_comment(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_session_comment()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.RequestBlob.session_comment)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RequestBlob::session_comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.RequestBlob.session_comment)
  return _internal_session_comment();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL RequestBlob::mutable_session_comment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.RequestBlob.session_comment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_session_comment();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RequestBlob::_internal_session_comment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_comment_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
RequestBlob::_internal_mutable_session_comment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.session_comment_;
}

// repeated uint32 channel_description = 3;
inline int RequestBlob::_internal_channel_description_size() const {
  return _internal_channel_description().size();
}
inline int RequestBlob::channel_description_size() const {
  return _internal_channel_description_size();
}
inline void RequestBlob::clear_channel_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_description_.Clear();
}
inline ::uint32_t RequestBlob::channel_description(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.RequestBlob.channel_description)
  return _internal_channel_description().Get(index);
}
inline void RequestBlob::set_channel_description(int index, ::uint32_t value) {
  _internal_mutable_channel_description()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.RequestBlob.channel_description)
}
inline void RequestBlob::add_channel_description(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_description()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.RequestBlob.channel_description)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RequestBlob::channel_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.RequestBlob.channel_description)
  return _internal_channel_description();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL RequestBlob::mutable_channel_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.RequestBlob.channel_description)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channel_description();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RequestBlob::_internal_channel_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_description_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
RequestBlob::_internal_mutable_channel_description() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channel_description_;
}

// -------------------------------------------------------------------

// ServerConfig

// optional uint32 max_bandwidth = 1;
inline bool ServerConfig::has_max_bandwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ServerConfig::clear_max_bandwidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bandwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ServerConfig::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.max_bandwidth)
  return _internal_max_bandwidth();
}
inline void ServerConfig::set_max_bandwidth(::uint32_t value) {
  _internal_set_max_bandwidth(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.max_bandwidth)
}
inline ::uint32_t ServerConfig::_internal_max_bandwidth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_bandwidth_;
}
inline void ServerConfig::_internal_set_max_bandwidth(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bandwidth_ = value;
}

// optional string welcome_text = 2;
inline bool ServerConfig::has_welcome_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServerConfig::clear_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.welcome_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ServerConfig::welcome_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.welcome_text)
  return _internal_welcome_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ServerConfig::set_welcome_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.welcome_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.welcome_text)
}
inline ::std::string* PROTOBUF_NONNULL ServerConfig::mutable_welcome_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_welcome_text();
  // @@protoc_insertion_point(field_mutable:NoxProto.ServerConfig.welcome_text)
  return _s;
}
inline const ::std::string& ServerConfig::_internal_welcome_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.welcome_text_.Get();
}
inline void ServerConfig::_internal_set_welcome_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.welcome_text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ServerConfig::_internal_mutable_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.welcome_text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ServerConfig::release_welcome_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.ServerConfig.welcome_text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.welcome_text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.welcome_text_.Set("", GetArena());
  }
  return released;
}
inline void ServerConfig::set_allocated_welcome_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.welcome_text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.welcome_text_.IsDefault()) {
    _impl_.welcome_text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.ServerConfig.welcome_text)
}

// optional bool allow_html = 3;
inline bool ServerConfig::has_allow_html() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ServerConfig::clear_allow_html() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_html_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ServerConfig::allow_html() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.allow_html)
  return _internal_allow_html();
}
inline void ServerConfig::set_allow_html(bool value) {
  _internal_set_allow_html(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.allow_html)
}
inline bool ServerConfig::_internal_allow_html() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allow_html_;
}
inline void ServerConfig::_internal_set_allow_html(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_html_ = value;
}

// optional uint32 message_length = 4;
inline bool ServerConfig::has_message_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ServerConfig::clear_message_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ServerConfig::message_length() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.message_length)
  return _internal_message_length();
}
inline void ServerConfig::set_message_length(::uint32_t value) {
  _internal_set_message_length(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.message_length)
}
inline ::uint32_t ServerConfig::_internal_message_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_length_;
}
inline void ServerConfig::_internal_set_message_length(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_length_ = value;
}

// optional uint32 image_message_length = 5;
inline bool ServerConfig::has_image_message_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServerConfig::clear_image_message_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_message_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ServerConfig::image_message_length() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.image_message_length)
  return _internal_image_message_length();
}
inline void ServerConfig::set_image_message_length(::uint32_t value) {
  _internal_set_image_message_length(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.image_message_length)
}
inline ::uint32_t ServerConfig::_internal_image_message_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_message_length_;
}
inline void ServerConfig::_internal_set_image_message_length(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_message_length_ = value;
}

// optional uint32 max_users = 6;
inline bool ServerConfig::has_max_users() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ServerConfig::clear_max_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_users_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t ServerConfig::max_users() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.max_users)
  return _internal_max_users();
}
inline void ServerConfig::set_max_users(::uint32_t value) {
  _internal_set_max_users(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.max_users)
}
inline ::uint32_t ServerConfig::_internal_max_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_users_;
}
inline void ServerConfig::_internal_set_max_users(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_users_ = value;
}

// optional bool recording_allowed = 7;
inline bool ServerConfig::has_recording_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ServerConfig::clear_recording_allowed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recording_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ServerConfig::recording_allowed() const {
  // @@protoc_insertion_point(field_get:NoxProto.ServerConfig.recording_allowed)
  return _internal_recording_allowed();
}
inline void ServerConfig::set_recording_allowed(bool value) {
  _internal_set_recording_allowed(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:NoxProto.ServerConfig.recording_allowed)
}
inline bool ServerConfig::_internal_recording_allowed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recording_allowed_;
}
inline void ServerConfig::_internal_set_recording_allowed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recording_allowed_ = value;
}

// -------------------------------------------------------------------

// SuggestConfig

// optional uint32 version_v1 = 1;
inline bool SuggestConfig::has_version_v1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SuggestConfig::clear_version_v1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t SuggestConfig::version_v1() const {
  // @@protoc_insertion_point(field_get:NoxProto.SuggestConfig.version_v1)
  return _internal_version_v1();
}
inline void SuggestConfig::set_version_v1(::uint32_t value) {
  _internal_set_version_v1(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:NoxProto.SuggestConfig.version_v1)
}
inline ::uint32_t SuggestConfig::_internal_version_v1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_v1_;
}
inline void SuggestConfig::_internal_set_version_v1(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v1_ = value;
}

// optional uint64 version_v2 = 4;
inline bool SuggestConfig::has_version_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SuggestConfig::clear_version_v2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v2_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SuggestConfig::version_v2() const {
  // @@protoc_insertion_point(field_get:NoxProto.SuggestConfig.version_v2)
  return _internal_version_v2();
}
inline void SuggestConfig::set_version_v2(::uint64_t value) {
  _internal_set_version_v2(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:NoxProto.SuggestConfig.version_v2)
}
inline ::uint64_t SuggestConfig::_internal_version_v2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_v2_;
}
inline void SuggestConfig::_internal_set_version_v2(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_v2_ = value;
}

// optional bool positional = 2;
inline bool SuggestConfig::has_positional() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SuggestConfig::clear_positional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positional_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SuggestConfig::positional() const {
  // @@protoc_insertion_point(field_get:NoxProto.SuggestConfig.positional)
  return _internal_positional();
}
inline void SuggestConfig::set_positional(bool value) {
  _internal_set_positional(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:NoxProto.SuggestConfig.positional)
}
inline bool SuggestConfig::_internal_positional() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positional_;
}
inline void SuggestConfig::_internal_set_positional(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positional_ = value;
}

// optional bool push_to_talk = 3;
inline bool SuggestConfig::has_push_to_talk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SuggestConfig::clear_push_to_talk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.push_to_talk_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SuggestConfig::push_to_talk() const {
  // @@protoc_insertion_point(field_get:NoxProto.SuggestConfig.push_to_talk)
  return _internal_push_to_talk();
}
inline void SuggestConfig::set_push_to_talk(bool value) {
  _internal_set_push_to_talk(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.SuggestConfig.push_to_talk)
}
inline bool SuggestConfig::_internal_push_to_talk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.push_to_talk_;
}
inline void SuggestConfig::_internal_set_push_to_talk(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.push_to_talk_ = value;
}

// -------------------------------------------------------------------

// PluginDataTransmission

// optional uint32 senderSession = 1;
inline bool PluginDataTransmission::has_sendersession() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PluginDataTransmission::clear_sendersession() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sendersession_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t PluginDataTransmission::sendersession() const {
  // @@protoc_insertion_point(field_get:NoxProto.PluginDataTransmission.senderSession)
  return _internal_sendersession();
}
inline void PluginDataTransmission::set_sendersession(::uint32_t value) {
  _internal_set_sendersession(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:NoxProto.PluginDataTransmission.senderSession)
}
inline ::uint32_t PluginDataTransmission::_internal_sendersession() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sendersession_;
}
inline void PluginDataTransmission::_internal_set_sendersession(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sendersession_ = value;
}

// repeated uint32 receiverSessions = 2 [packed = true];
inline int PluginDataTransmission::_internal_receiversessions_size() const {
  return _internal_receiversessions().size();
}
inline int PluginDataTransmission::receiversessions_size() const {
  return _internal_receiversessions_size();
}
inline void PluginDataTransmission::clear_receiversessions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.receiversessions_.Clear();
}
inline ::uint32_t PluginDataTransmission::receiversessions(int index) const {
  // @@protoc_insertion_point(field_get:NoxProto.PluginDataTransmission.receiverSessions)
  return _internal_receiversessions().Get(index);
}
inline void PluginDataTransmission::set_receiversessions(int index, ::uint32_t value) {
  _internal_mutable_receiversessions()->Set(index, value);
  // @@protoc_insertion_point(field_set:NoxProto.PluginDataTransmission.receiverSessions)
}
inline void PluginDataTransmission::add_receiversessions(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_receiversessions()->Add(value);
  // @@protoc_insertion_point(field_add:NoxProto.PluginDataTransmission.receiverSessions)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PluginDataTransmission::receiversessions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NoxProto.PluginDataTransmission.receiverSessions)
  return _internal_receiversessions();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL PluginDataTransmission::mutable_receiversessions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NoxProto.PluginDataTransmission.receiverSessions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_receiversessions();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
PluginDataTransmission::_internal_receiversessions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.receiversessions_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
PluginDataTransmission::_internal_mutable_receiversessions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.receiversessions_;
}

// optional bytes data = 3;
inline bool PluginDataTransmission::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PluginDataTransmission::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PluginDataTransmission::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.PluginDataTransmission.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginDataTransmission::set_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.PluginDataTransmission.data)
}
inline ::std::string* PROTOBUF_NONNULL PluginDataTransmission::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:NoxProto.PluginDataTransmission.data)
  return _s;
}
inline const ::std::string& PluginDataTransmission::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void PluginDataTransmission::_internal_set_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginDataTransmission::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginDataTransmission::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.PluginDataTransmission.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void PluginDataTransmission::set_allocated_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.PluginDataTransmission.data)
}

// optional string dataID = 4;
inline bool PluginDataTransmission::has_dataid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PluginDataTransmission::clear_dataid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dataid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& PluginDataTransmission::dataid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NoxProto.PluginDataTransmission.dataID)
  return _internal_dataid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginDataTransmission::set_dataid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dataid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NoxProto.PluginDataTransmission.dataID)
}
inline ::std::string* PROTOBUF_NONNULL PluginDataTransmission::mutable_dataid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_dataid();
  // @@protoc_insertion_point(field_mutable:NoxProto.PluginDataTransmission.dataID)
  return _s;
}
inline const ::std::string& PluginDataTransmission::_internal_dataid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dataid_.Get();
}
inline void PluginDataTransmission::_internal_set_dataid(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dataid_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginDataTransmission::_internal_mutable_dataid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dataid_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginDataTransmission::release_dataid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:NoxProto.PluginDataTransmission.dataID)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dataid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dataid_.Set("", GetArena());
  }
  return released;
}
inline void PluginDataTransmission::set_allocated_dataid(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dataid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dataid_.IsDefault()) {
    _impl_.dataid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:NoxProto.PluginDataTransmission.dataID)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace NoxProto


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::NoxProto::Reject_RejectType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::NoxProto::Reject_RejectType>() {
  return ::NoxProto::Reject_RejectType_descriptor();
}
template <>
struct is_proto_enum<::NoxProto::PermissionDenied_DenyType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::NoxProto::PermissionDenied_DenyType>() {
  return ::NoxProto::PermissionDenied_DenyType_descriptor();
}
template <>
struct is_proto_enum<::NoxProto::ContextActionModify_Context> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::NoxProto::ContextActionModify_Context>() {
  return ::NoxProto::ContextActionModify_Context_descriptor();
}
template <>
struct is_proto_enum<::NoxProto::ContextActionModify_Operation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::NoxProto::ContextActionModify_Operation>() {
  return ::NoxProto::ContextActionModify_Operation_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // Nox_2eproto_2epb_2eh
